using Lazer.Runtime;

public unsafe static class Primes
{
    internal static string mains8t3 = "primes";
    internal static string lvls8rK = "Main2.hs:13:1-40|function the_filter";
    internal static string lvls8oL = "Result: ";
    internal static string lvls8oJ = "AVG: ";
    internal static string lvls8oH = "MIN: ";
    internal static string lvls8oF = "MAX: ";
    internal static string lvls8mG = "maximum";
    internal static string lvls8mm = "minimum";
    internal static string lvls8mc = "Negative exponent";
    public static Fun p;

    internal static Fun wps8sK;

    internal static Fun sps8sJ;

    internal static Fun sps8sE;

    internal static Fun wDollsps8sw;

    public static Fun w;

    internal static Fun wws8s6;

    public static Fun prime;

    internal static Fun wprimes8rX;

    internal static Fun go2s8rS;

    public static Fun the_filter;

    internal static Updatable lvls8rL;

    public static Fun isdivs;

    internal static Fun wisdivss8rx;
    internal static Fun sevens8mi;

    internal static Updatable lvls8md;

    internal static GHC.Integer.Type.SHash lvls8mf;
    internal static GHC.Integer.Type.SHash lvls8mg;
    internal static GHC.Integer.Type.SHash lvls8mh;
    internal static GHC.Types.DHash lvls8nB;
    internal static GHC.Integer.Type.SHash lvls8nC;
    internal static GHC.Types.IHash lvls8nF;
    internal static GHC.Integer.Type.SHash lvls8o5;

    static Primes()
    {
        p = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(p_Entry));

        wps8sK = new Fun(2, CLR.LoadFunctionPointer<Closure, long, Closure>(wps8sK_Entry));

        sps8sJ = new Fun(2, CLR.LoadFunctionPointer<Closure, GHC.Prim.Void, Closure>(sps8sJ_Entry));

        sps8sE = new Fun(2, CLR.LoadFunctionPointer<Closure, GHC.Prim.Void, Closure>(sps8sE_Entry));

        wDollsps8sw = new Fun(2, CLR.LoadFunctionPointer<long, GHC.Prim.Void, Closure>(wDollsps8sw_Entry));

        w = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(w_Entry));

        wws8s6 = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, long, Closure>(wws8s6_Entry));

        prime = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(prime_Entry));

        wprimes8rX = new Fun(1, CLR.LoadFunctionPointer<long, Closure>(wprimes8rX_Entry));

        go2s8rS = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(go2s8rS_Entry));

        the_filter = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(the_filter_Entry));

        lvls8rL = new Updatable(CLR.LoadFunctionPointer<Closure>(lvls8rL_Entry));

        isdivs = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(isdivs_Entry));

        wisdivss8rx = new Fun(2, CLR.LoadFunctionPointer<long, Closure, Closure>(wisdivss8rx_Entry));

        sevens8mi = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(sevens8mi_Entry));

        lvls8md = new Updatable(CLR.LoadFunctionPointer<Closure>(lvls8md_Entry));

        lvls8o5 = new GHC.Integer.Type.SHash(10);
        lvls8nF = new GHC.Types.IHash(0);
        lvls8nC = new GHC.Integer.Type.SHash(9);
        lvls8nB = new GHC.Types.DHash(10 % 1);
        lvls8mh = new GHC.Integer.Type.SHash(0);
        lvls8mg = new GHC.Integer.Type.SHash(1);
        lvls8mf = new GHC.Integer.Type.SHash(2);
    }

    public static Closure TestEntry()
    {
        return wps8sK_Entry(new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(id)), 0);
    }
    private static Closure id(Closure x) => x;
    public static Closure p_Entry(Closure ws8sT, Closure ws8sU)
    {
        var wws8sV = ws8sT.Eval();
        var wws8sV_CColMonad = wws8sV as GHC.Base.CColMonad;
        var wws8sW = wws8sV_CColMonad.x0;
        var wws8sX = wws8sV_CColMonad.x1;
        var wws8sY = wws8sV_CColMonad.x2;
        var wws8sZ = wws8sV_CColMonad.x3;
        var wws8t0 = wws8sV_CColMonad.x4;
        var wws8t1 = ws8sU.Eval();
        var wws8t1_IHash = wws8t1 as GHC.Types.IHash;
        var wws8t2 = wws8t1_IHash.x0;
        return wps8sK_Entry(wws8sZ, wws8t2);
    }
    public static Closure wps8sK_Entry(Closure wws8sL, long wws8sM)
    {
        var sats8sP = 500 + wws8sM;
        var sats8sN = 100 - wws8sM;
        var sats8sO = new GHC.Types.IHash(sats8sN);
        var ds1s8sQ = wws8s6_Entry(GHC.Classes.eqInt, GHC.Num.fNumInt, sats8sO, sats8sP).Eval();
        var ds1s8sQ_IHash = ds1s8sQ as GHC.Types.IHash;
        var ipvs8sR = ds1s8sQ_IHash.x0;
        return wws8sL.Apply<Closure, Closure>(GHC.Tuple.unit_DataCon);
    }
    public static Closure sps8sJ_Entry(Closure etaB2, GHC.Prim.Void void0E)
    {
        return sps8sE_Entry(etaB2, GHC.Prim.voidHash);
    }
    public static Closure sps8sE_Entry(Closure ws8sF, GHC.Prim.Void void0E)
    {
        var wws8sH = ws8sF.Eval();
        var wws8sH_IHash = wws8sH as GHC.Types.IHash;
        var wws8sI = wws8sH_IHash.x0;
        return wDollsps8sw_Entry(wws8sI, GHC.Prim.voidHash);
    }
    public static Closure wDollsps8sw_Entry(long wws8sx, GHC.Prim.Void void0E)
    {
        var sats8sB = 1500 + wws8sx;
        var sats8sz = 100 - wws8sx;
        var sats8sA = new GHC.Types.IHash(sats8sz);
        var ds1s8sC = wws8s6_Entry(GHC.Classes.eqInt, GHC.Num.fNumInt, sats8sA, sats8sB).Eval();
        var ds1s8sC_IHash = ds1s8sC as GHC.Types.IHash;
        var ipvs8sD = ds1s8sC_IHash.x0; return GHC.Tuple.unit_DataCon;
    }
    public static Closure w_Entry(Closure ws8sn, Closure ws8so, Closure ws8sp, Closure ws8sq)
    {
        var wws8sr = ws8sn.Eval();
        var wws8sr_CColEq = wws8sr as GHC.Classes.CColEq;
        var wws8ss = wws8sr_CColEq.x0;
        var wws8st = wws8sr_CColEq.x1;
        var wws8su = ws8sq.Eval();
        var wws8su_IHash = wws8su as GHC.Types.IHash;
        var wws8sv = wws8su_IHash.x0;
        return wws8s6_Entry(wws8ss, ws8so, ws8sp, wws8sv);
    }
    public static Closure wws8s6_Entry(Closure wws8s7, Closure ws8s8, Closure ws8s9, long wws8sa)
    {
        var lvls8sb = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(lvls8sb_Entry), ws8s8);
        return wws8sc_Entry(wws8s7, ws8s8, lvls8sb, ws8s9, wws8sa);
    }
    public static Closure wws8sc_Entry(Closure wws8s7, Closure ws8s8, Closure lvls8sb, Closure ws8sd, long wws8se)
    {
        var wilds8sf = wws8s7.Apply<Closure, Closure, Closure>(ws8sd, lvls8sb).Eval();
        var wilds8sfTags8sf = wilds8sf.Tag;
        switch (wilds8sfTags8sf)
        {
            default: { throw new ImpossibleException(); }
            case 1:
                {
                    var wilds8sf_False = wilds8sf as GHC.Types.False;
                    var wilds8sg = wprimes8rX_Entry(wws8se).Eval();
                    var wilds8sg_IHash = wilds8sg as GHC.Types.IHash;
                    var xs8sh = wilds8sg_IHash.x0;
                    var sats8si = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats8si_Entry), ws8s8, lvls8sb, ws8sd);
                    var wild1s8sj = wws8sc_Entry(wws8s7,ws8s8,lvls8sb, sats8si, wws8se);
                    var wild1s8sj_IHash = wild1s8sj as GHC.Types.IHash;
                    var ys8sk = wild1s8sj_IHash.x0;
                    var sats8sl = xs8sh + ys8sk;
                    return new GHC.Types.IHash(sats8sl);
                }
            case 2:
                {
                    var wilds8sf_True = wilds8sf as GHC.Types.True;
                    return wprimes8rX_Entry(wws8se);
                }
        }
    }
    public static Closure sats8si_Entry(Closure ws8s8, Closure lvls8sb, Closure ws8sd)
    {
        return GHC.Num.dash_Entry(ws8s8).Apply<Closure, Closure, Closure>(ws8sd, lvls8sb);
    }
    public static Closure lvls8sb_Entry(Closure ws8s8)
    {
        return GHC.Num.fromInteger_Entry(ws8s8).Apply<Closure, Closure>(lvls8mg);
    }
    public static Closure prime_Entry(Closure ws8s3)
    {
        var wws8s4 = ws8s3.Eval();
        var wws8s4_IHash = wws8s4 as GHC.Types.IHash;
        var wws8s5 = wws8s4_IHash.x0; return wprimes8rX_Entry(wws8s5);
    }
    public static Closure wprimes8rX_Entry(long wws8rY)
    {
        var sats8s0 = new Updatable<long>(CLR.LoadFunctionPointer<long, Closure>(sats8s0_Entry), wws8rY);
        var sats8s1 = go2s8rS_Entry(sats8s0).Eval();
        return GHC.List.wBangBangs8DW_Entry(sats8s1, wws8rY);
    }
    public static Closure sats8s0_Entry(long wws8rY)
    {
        var sats8rZ = wws8rY * wws8rY;
        return global::Code.makelist_Go(2, sats8rZ);
    }
    public static Closure go2s8rS_Entry(Closure xs8rT)
    {
        var sats8rW = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats8rW_Entry), xs8rT);
        var sats8rU = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats8rU_Entry), xs8rT);
        return new GHC.Types.Cons(sats8rU, sats8rW);
    }
    public static Closure sats8rU_Entry(Closure xs8rT)
    {
        return GHC.List.head_Entry(xs8rT);
    }
    public static Closure sats8rW_Entry(Closure xs8rT)
    {
        var sats8rV = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats8rV_Entry), xs8rT);
        return go2s8rS_Entry(sats8rV);
    }
    public static Closure sats8rV_Entry(Closure xs8rT)
    {
        return the_filter_Entry(xs8rT);
    }
    public static Closure the_filter_Entry(Closure dss8rN)
    {
        var wilds8rO = dss8rN.Eval();
        switch (wilds8rO)
        {
            default: { throw new ImpossibleException($"{wilds8rO.GetType()}"); }
            case GHC.Types.Nil wilds8rO_Nil: { return lvls8rL.Eval(); }
            case GHC.Types.Cons wilds8rO_Cons:
                {
                    var ns8rP = wilds8rO_Cons.x0;
                    var nss8rQ = wilds8rO_Cons.x1;
                    var sats8rR = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats8rR_Entry), ns8rP);
                    return GHC.List.filter_Entry(sats8rR, nss8rQ);
                }
        }
    }
    public static Closure sats8rR_Entry(Closure ns8rP, Closure etaB1)
    {
        return isdivs_Entry(ns8rP, etaB1);
    }
    public static Closure lvls8rL_Entry()
    {
        throw new System.Exception(lvls8rK);
    }
    public static Closure isdivs_Entry(Closure ws8rG, Closure ws8rH)
    {
        var wws8rI = ws8rG.Eval();
        var wws8rI_IHash = wws8rI as GHC.Types.IHash;
        var wws8rJ = wws8rI_IHash.x0;
        return wisdivss8rx_Entry(wws8rJ, ws8rH);
    }
    public static Closure wisdivss8rx_Entry(long wws8ry, Closure ws8rz)
    {
        var wilds8rA = wws8ry;
        switch (wilds8rA)
        {
            default:
                {
                    var wild1s8rB = ws8rz.Eval();
                    var wild1s8rB_IHash = wild1s8rB as GHC.Types.IHash;
                    var xs8rC = wild1s8rB_IHash.x0;
                    var ww2s8rD = GHC.Classes.modIntHash_Entry(xs8rC, wilds8rA);
                    switch (ww2s8rD)
                    {
                        default: { return GHC.Types.true_DataCon.Eval(); }
                        case 0: { return GHC.Types.false_DataCon.Eval(); }
                    }
                }
            case -1: { return GHC.Types.false_DataCon.Eval(); }
            case 0: { throw new System.Exception("Division by zero"); }
        }
    }
    public static Closure sevens8mi_Entry(Closure ns8mj)
    {
        var sats8mk = GHC.Integer.Type.remInteger_Entry(ns8mj, lvls8mf).Eval();
        var wilds8ml = GHC.Integer.Type.eqIntegerHash_Entry(sats8mk, lvls8mh);
        return GHC.Types.tagToEnumHash(wilds8ml);
    }
    public static Closure lvls8md_Entry()
    {
        throw new System.Exception(lvls8mc);
    }

}
