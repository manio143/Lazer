using Lazer.Runtime;

namespace GHC
{
    public unsafe static class Base
    {
        public static Fun cColMonoid_DataCon;

        public static Fun cColFunctor_DataCon;

        public static Fun cColApplicative_DataCon;

        public static Fun cColAlternative_DataCon;

        public static Fun cColMonad_DataCon;

        public static Fun cColMonadPlus_DataCon;

        public static Fun cColSemigroup_DataCon;

        public static Fun eqString;

        internal static Fun cmanys9BH;

        internal static Fun csomes9Bx;

        public static Fun liftM;

        internal static Fun sliftMs9Bp;

        public static Fun liftM2;

        internal static Fun sliftM2s9Be;

        public static Fun liftM3;

        internal static Fun sliftM3s9AP;

        public static Fun liftM4;

        internal static Fun sliftM4s9Ak;

        public static Fun liftM5;

        internal static Fun sliftM5s9zJ;

        public static Fun ap;

        internal static Fun saps9zs;

        public static Fun when;

        internal static Fun swhens9zi;

        public static Fun liftA;

        internal static Fun sliftAs9zb;

        public static Fun liftA3;

        internal static Fun sliftA3s9yS;

        internal static Fun cLtAstrs9yK;

        public static Fun modInt;

        public static Fun divInt;

        public static Fun quotRemInt;

        public static Fun remInt;

        public static Fun quotInt;

        public static Fun getTag;

        public static Fun flip;

        internal static Fun lvls9x0;

        internal static Fun cGtGts9wZ;

        internal static Fun cLtAstrs9wU;

        internal static Fun cAstrGts9wQ;

        internal static Fun cLtDolls9wL;

        public static Fun fMonadPrOComPrC;

        internal static Fun lvls9wB;

        internal static Fun cGtGts9wA;

        public static Fun fApplicativePrOComPrC;

        internal static Fun cLtAstrs9wg;

        internal static Fun cAstrGts9w5;

        internal static Fun cLtDolls9vY;

        internal static Fun cLtAstrGts9vT;

        internal static Fun cLtDolls9vN;

        internal static Fun cmanys9vu;

        internal static Fun csomes9vd;

        internal static Fun poly_gos9v7;

        public static Fun eqLtLt;

        internal static Fun sEqLtLts9uZ;

        internal static Fun cLtAstrs9uW;

        internal static Fun cLtDolls9uQ;

        public static Fun dmLtDolls9uL;

        public static Fun fMonoidDashGt;

        internal static Fun cmconcats9uq;

        public static Fun fMonoidPrOComPrC;

        internal static Fun cmconcats9tZ;

        public static Fun fMonoidPrOComComPrC;

        internal static Fun cmconcats9ts;

        public static Fun fMonoidPrOComComComPrC;

        internal static Fun cmconcats9t2;

        public static Fun fMonoidPrOComComComComPrC;

        internal static Fun cmconcats9sz;

        internal static Fun gos9ss;

        public static Fun fMonoidMaybe;

        internal static Fun cmconcats9sa;

        public static Fun dmmconcats9s0;

        public static Fun sequence;

        public static Fun mapM;

        public static Fun fSemigroupBrOBrC;

        public static Fun plusPlus;

        public static Fun map;

        public static Fun foldr;

        public static Fun mapFB;

        public static Fun dot;

        public static Fun dmLtAstrs9qX;

        public static Fun asTypeOf;

        public static Fun @const;

        public static Fun breakpointCond;

        public static Fun breakpoint;

        public static Fun assert;

        public static Fun dmAstrGts9qI;

        public static Fun dmLtAstrGts9qG;

        public static Fun join;

        public static Fun id;

        public static Fun ord;

        public static Fun unsafeChr;

        public static Fun iShiftRLHash;

        public static Fun iShiftRAHash;

        public static Fun iShiftLHash;

        public static Fun shiftRLHash;

        public static Fun shiftLHash;

        public static Fun divModInt;

        public static Fun divModIntHash;

        public static Fun until;

        public static Fun augment;

        public static Fun build;

        public static Fun ltAstrAstrGt;

        internal static Fun lvls9on;

        public static Fun ifThenElse;

        public static Fun dmmappends9og;

        public static Fun dmliftA2s9oa;

        public static Fun dmsomes9nX;

        public static Fun dmmanys9nQ;

        public static Fun dmGtGts9nK;

        public static Fun dmreturns9nH;

        public static Fun dmfails9nE;

        public static Fun dmmzeros9nB;

        public static Fun dmmpluss9ny;

        internal static Fun cGtGtEqs9no;

        internal static Fun cfails9nm;

        internal static Fun cGtGtEqs9nh;

        internal static Fun cfails9nf;

        internal static Fun cGtGtEqs9na;

        internal static Fun cGtGtEqs9mZ;

        internal static Fun cLtPipeGts9mU;

        internal static Fun cpures9mS;

        internal static Fun cLtAstrGts9mC;

        internal static Fun cliftA2s9ml;

        internal static Fun cAstrGts9mc;

        internal static Fun cliftA2s9m3;

        internal static Fun cAstrGts9lY;

        internal static Fun cLtAstrGts9lT;

        internal static Fun cliftA2s9lM;

        internal static Fun cLtAstrGts9lA;

        internal static Fun cliftA2s9ln;

        internal static Fun cfmaps9lh;

        internal static Fun cfmaps9la;

        internal static Fun cp1Monoids9kL;

        internal static Fun cmemptys9kA;

        internal static Fun cp1Monoids9kf;

        internal static Fun cmemptys9k6;

        internal static Fun cp1Monoids9jP;

        internal static Fun cmemptys9jI;

        internal static Fun cp1Monoids9jv;

        internal static Fun cmemptys9jq;

        internal static Fun cmconcats9jo;

        internal static Fun cp1Monoids9jh;

        internal static Fun cmconcats9jf;

        internal static Fun poly_gos9j9;

        public static Fun fSemigroupMaybe;

        internal static Fun cLtGts9iZ;

        public static Fun fSemigroupOrdering;

        internal static Fun cLtGts9iU;

        public static Fun fSemigroupPrOComComComComPrC;

        internal static Fun cLtGts9iu;

        public static Fun fSemigroupPrOComComComPrC;

        internal static Fun cLtGts9i8;

        public static Fun fSemigroupPrOComComPrC;

        internal static Fun cLtGts9hQ;

        public static Fun fSemigroupPrOComPrC;

        internal static Fun cLtGts9hC;

        public static Fun fSemigroupPrOPrC;

        internal static Fun cLtGts9hy;

        public static Fun fSemigroupDashGt;

        internal static Fun cLtGts9hq;

        public static GHC.Base.CColMonoid fMonoidPrOPrC;
        public static GHC.Types.True otherwise;
        public static GHC.Types.IHash minInt;
        public static GHC.Types.IHash maxInt;
        public static GHC.Base.CColMonoid fMonoidBrOBrC;
        public static GHC.Base.CColMonoid fMonoidOrdering;
        public static GHC.Base.CColFunctor fFunctorBrOBrC;
        public static GHC.Base.CColApplicative fApplicativeBrOBrC;
        public static GHC.Base.CColMonad fMonadBrOBrC;
        internal static GHC.Types.Cons lvls9v6;
        public static GHC.Base.CColAlternative fAlternativeBrOBrC;
        public static GHC.Base.CColMonadPlus fMonadPlusBrOBrC;
        public static GHC.Base.CColFunctor fFunctorMaybe;
        public static GHC.Base.CColFunctor fFunctorPrOComPrC;
        public static GHC.Base.CColFunctor fFunctorDashGt;
        public static GHC.Base.CColApplicative fApplicativeDashGt;
        public static GHC.Base.CColMonad fMonadDashGt;
        public static GHC.Base.CColApplicative fApplicativeMaybe;
        internal static GHC.Maybe.Just lvls9zh;
        public static GHC.Base.CColMonad fMonadMaybe;
        internal static GHC.Maybe.Just lvls9BG;
        public static GHC.Base.CColAlternative fAlternativeMaybe;
        public static GHC.Base.CColMonadPlus fMonadPlusMaybe;

        public static Function ltGt;

        public static Function p1Monoid;

        public static Function mempty;

        public static Function mappend;

        public static Function mconcat;

        public static Function fmap;

        public static Function ltDoll;

        public static Function p1Applicative;

        public static Function pure;

        public static Function ltAstrGt;

        public static Function liftA2;

        public static Function astrGt;

        public static Function ltAstr;

        public static Function p1Alternative;

        public static Function empty;

        public static Function ltPipeGt;

        public static Function some;

        public static Function many;

        public static Function p1Monad;

        public static Function gtGtEq;

        public static Function gtGt;

        public static Function @return;

        public static Function fail;

        public static Function p1MonadPlus;

        public static Function p2MonadPlus;

        public static Function mzero;

        public static Function mplus;

        static Base()
        {
            cColMonoid_DataCon = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cColMonoid_DataCon_Entry));

            cColFunctor_DataCon = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cColFunctor_DataCon_Entry));

            cColApplicative_DataCon = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cColApplicative_DataCon_Entry));

            cColAlternative_DataCon = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cColAlternative_DataCon_Entry));

            cColMonad_DataCon = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cColMonad_DataCon_Entry));

            cColMonadPlus_DataCon = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cColMonadPlus_DataCon_Entry));

            cColSemigroup_DataCon = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cColSemigroup_DataCon_Entry));

            eqString = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(eqString_Entry));

            cmanys9BH = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cmanys9BH_Entry));

            csomes9Bx = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(csomes9Bx_Entry));

            liftM = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(liftM_Entry));

            sliftMs9Bp = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sliftMs9Bp_Entry));

            liftM2 = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(liftM2_Entry));

            sliftM2s9Be = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sliftM2s9Be_Entry));

            liftM3 = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(liftM3_Entry));

            sliftM3s9AP = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sliftM3s9AP_Entry));

            liftM4 = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(liftM4_Entry));

            sliftM4s9Ak = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sliftM4s9Ak_Entry));

            liftM5 = new Fun(7, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(liftM5_Entry));

            sliftM5s9zJ = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sliftM5s9zJ_Entry));

            ap = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(ap_Entry));

            saps9zs = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(saps9zs_Entry));

            when = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(when_Entry));

            swhens9zi = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(swhens9zi_Entry));

            liftA = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(liftA_Entry));

            sliftAs9zb = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sliftAs9zb_Entry));

            liftA3 = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(liftA3_Entry));

            sliftA3s9yS = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sliftA3s9yS_Entry));

            cLtAstrs9yK = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtAstrs9yK_Entry));

            modInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(modInt_Entry));

            divInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(divInt_Entry));

            quotRemInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(quotRemInt_Entry));

            remInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(remInt_Entry));

            quotInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(quotInt_Entry));

            getTag = new Fun(1, CLR.LoadFunctionPointer<Closure, long>(getTag_Entry));

            flip = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(flip_Entry));

            lvls9x0 = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(lvls9x0_Entry));

            cGtGts9wZ = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cGtGts9wZ_Entry));

            cLtAstrs9wU = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtAstrs9wU_Entry));

            cAstrGts9wQ = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cAstrGts9wQ_Entry));

            cLtDolls9wL = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtDolls9wL_Entry));

            fMonadPrOComPrC = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(fMonadPrOComPrC_Entry));

            lvls9wB = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(lvls9wB_Entry));

            cGtGts9wA = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cGtGts9wA_Entry));

            fApplicativePrOComPrC = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(fApplicativePrOComPrC_Entry));

            cLtAstrs9wg = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtAstrs9wg_Entry));

            cAstrGts9w5 = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cAstrGts9w5_Entry));

            cLtDolls9vY = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtDolls9vY_Entry));

            cLtAstrGts9vT = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtAstrGts9vT_Entry));

            cLtDolls9vN = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtDolls9vN_Entry));

            cmanys9vu = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cmanys9vu_Entry));

            csomes9vd = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(csomes9vd_Entry));

            poly_gos9v7 = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(poly_gos9v7_Entry));

            eqLtLt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(eqLtLt_Entry));

            sEqLtLts9uZ = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sEqLtLts9uZ_Entry));

            cLtAstrs9uW = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtAstrs9uW_Entry));

            cLtDolls9uQ = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtDolls9uQ_Entry));

            dmLtDolls9uL = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(dmLtDolls9uL_Entry));

            fMonoidDashGt = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(fMonoidDashGt_Entry));

            cmconcats9uq = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cmconcats9uq_Entry));

            fMonoidPrOComPrC = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(fMonoidPrOComPrC_Entry));

            cmconcats9tZ = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cmconcats9tZ_Entry));

            fMonoidPrOComComPrC = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(fMonoidPrOComComPrC_Entry));

            cmconcats9ts = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cmconcats9ts_Entry));

            fMonoidPrOComComComPrC = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(fMonoidPrOComComComPrC_Entry));

            cmconcats9t2 = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cmconcats9t2_Entry));

            fMonoidPrOComComComComPrC = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(fMonoidPrOComComComComPrC_Entry));

            cmconcats9sz = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cmconcats9sz_Entry));

            gos9ss = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(gos9ss_Entry));

            fMonoidMaybe = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(fMonoidMaybe_Entry));

            cmconcats9sa = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cmconcats9sa_Entry));

            dmmconcats9s0 = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(dmmconcats9s0_Entry));

            sequence = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sequence_Entry));

            mapM = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(mapM_Entry));

            fSemigroupBrOBrC = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(fSemigroupBrOBrC_Entry));

            plusPlus = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(plusPlus_Entry));

            map = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(map_Entry));

            foldr = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(foldr_Entry));

            mapFB = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(mapFB_Entry));

            dot = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(dot_Entry));

            dmLtAstrs9qX = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmLtAstrs9qX_Entry));

            asTypeOf = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(asTypeOf_Entry));

            @const = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(@const_Entry));

            breakpointCond = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(breakpointCond_Entry));

            breakpoint = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(breakpoint_Entry));

            assert = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(assert_Entry));

            dmAstrGts9qI = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(dmAstrGts9qI_Entry));

            dmLtAstrGts9qG = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmLtAstrGts9qG_Entry));

            join = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(join_Entry));

            id = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(id_Entry));

            ord = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(ord_Entry));

            unsafeChr = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(unsafeChr_Entry));

            iShiftRLHash = new Fun(2, CLR.LoadFunctionPointer<long, long, long>(iShiftRLHash_Entry));

            iShiftRAHash = new Fun(2, CLR.LoadFunctionPointer<long, long, long>(iShiftRAHash_Entry));

            iShiftLHash = new Fun(2, CLR.LoadFunctionPointer<long, long, long>(iShiftLHash_Entry));

            shiftRLHash = new Fun(2, CLR.LoadFunctionPointer<ulong, long, ulong>(shiftRLHash_Entry));

            shiftLHash = new Fun(2, CLR.LoadFunctionPointer<ulong, long, ulong>(shiftLHash_Entry));

            divModInt = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(divModInt_Entry));

            divModIntHash = new Fun(2, CLR.LoadFunctionPointer<long, long, (long x0, long x1)>(divModIntHash_Entry));

            until = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(until_Entry));

            augment = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(augment_Entry));

            build = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(build_Entry));

            ltAstrAstrGt = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(ltAstrAstrGt_Entry));

            lvls9on = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(lvls9on_Entry));

            ifThenElse = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(ifThenElse_Entry));

            dmmappends9og = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmmappends9og_Entry));

            dmliftA2s9oa = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(dmliftA2s9oa_Entry));

            dmsomes9nX = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(dmsomes9nX_Entry));

            dmmanys9nQ = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(dmmanys9nQ_Entry));

            dmGtGts9nK = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(dmGtGts9nK_Entry));

            dmreturns9nH = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmreturns9nH_Entry));

            dmfails9nE = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(dmfails9nE_Entry));

            dmmzeros9nB = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmmzeros9nB_Entry));

            dmmpluss9ny = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(dmmpluss9ny_Entry));

            cGtGtEqs9no = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cGtGtEqs9no_Entry));

            cfails9nm = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cfails9nm_Entry));

            cGtGtEqs9nh = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cGtGtEqs9nh_Entry));

            cfails9nf = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cfails9nf_Entry));

            cGtGtEqs9na = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cGtGtEqs9na_Entry));

            cGtGtEqs9mZ = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cGtGtEqs9mZ_Entry));

            cLtPipeGts9mU = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtPipeGts9mU_Entry));

            cpures9mS = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cpures9mS_Entry));

            cLtAstrGts9mC = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtAstrGts9mC_Entry));

            cliftA2s9ml = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cliftA2s9ml_Entry));

            cAstrGts9mc = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cAstrGts9mc_Entry));

            cliftA2s9m3 = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cliftA2s9m3_Entry));

            cAstrGts9lY = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cAstrGts9lY_Entry));

            cLtAstrGts9lT = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtAstrGts9lT_Entry));

            cliftA2s9lM = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cliftA2s9lM_Entry));

            cLtAstrGts9lA = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtAstrGts9lA_Entry));

            cliftA2s9ln = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cliftA2s9ln_Entry));

            cfmaps9lh = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cfmaps9lh_Entry));

            cfmaps9la = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cfmaps9la_Entry));

            cp1Monoids9kL = new Fun(7, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cp1Monoids9kL_Entry));

            cmemptys9kA = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cmemptys9kA_Entry));

            cp1Monoids9kf = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cp1Monoids9kf_Entry));

            cmemptys9k6 = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cmemptys9k6_Entry));

            cp1Monoids9jP = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cp1Monoids9jP_Entry));

            cmemptys9jI = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cmemptys9jI_Entry));

            cp1Monoids9jv = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cp1Monoids9jv_Entry));

            cmemptys9jq = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cmemptys9jq_Entry));

            cmconcats9jo = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cmconcats9jo_Entry));

            cp1Monoids9jh = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cp1Monoids9jh_Entry));

            cmconcats9jf = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(cmconcats9jf_Entry));

            poly_gos9j9 = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(poly_gos9j9_Entry));

            fSemigroupMaybe = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(fSemigroupMaybe_Entry));

            cLtGts9iZ = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(cLtGts9iZ_Entry));

            fSemigroupOrdering = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(fSemigroupOrdering_Entry));

            cLtGts9iU = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtGts9iU_Entry));

            fSemigroupPrOComComComComPrC = new Fun(7, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(fSemigroupPrOComComComComPrC_Entry));

            cLtGts9iu = new Fun(7, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cLtGts9iu_Entry));

            fSemigroupPrOComComComPrC = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(fSemigroupPrOComComComPrC_Entry));

            cLtGts9i8 = new Fun(6, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(cLtGts9i8_Entry));

            fSemigroupPrOComComPrC = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(fSemigroupPrOComComPrC_Entry));

            cLtGts9hQ = new Fun(5, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(cLtGts9hQ_Entry));

            fSemigroupPrOComPrC = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(fSemigroupPrOComPrC_Entry));

            cLtGts9hC = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cLtGts9hC_Entry));

            fSemigroupPrOPrC = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(fSemigroupPrOPrC_Entry));

            cLtGts9hy = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure, Closure>(cLtGts9hy_Entry));

            fSemigroupDashGt = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(fSemigroupDashGt_Entry));

            cLtGts9hq = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(cLtGts9hq_Entry));

            fMonadPlusMaybe = new GHC.Base.CColMonadPlus(null, null, GHC.Maybe.nothing_DataCon, cLtPipeGts9mU);
            fAlternativeMaybe = new GHC.Base.CColAlternative(null, GHC.Maybe.nothing_DataCon, cLtPipeGts9mU, csomes9Bx, cmanys9BH);
            lvls9BG = new GHC.Maybe.Just(GHC.Types.nil_DataCon);
            fMonadMaybe = new GHC.Base.CColMonad(null, cGtGtEqs9nh, cAstrGts9lY, GHC.Maybe.just_DataCon, cfails9nf);
            lvls9zh = new GHC.Maybe.Just(GHC.Tuple.unit_DataCon);
            fApplicativeMaybe = new GHC.Base.CColApplicative(null, GHC.Maybe.just_DataCon, cLtAstrGts9vT, cliftA2s9m3, cAstrGts9lY, cLtAstrs9yK);
            fMonadDashGt = new GHC.Base.CColMonad(null, cGtGtEqs9na, cGtGts9wZ, GHC.Base.@const, lvls9x0);
            fApplicativeDashGt = new GHC.Base.CColApplicative(null, GHC.Base.@const, cLtAstrGts9lT, cliftA2s9lM, cAstrGts9wQ, cLtAstrs9wU);
            fFunctorDashGt = new GHC.Base.CColFunctor(GHC.Base.dot, cLtDolls9wL);
            fFunctorPrOComPrC = new GHC.Base.CColFunctor(cfmaps9la, cLtDolls9vY);
            fFunctorMaybe = new GHC.Base.CColFunctor(cfmaps9lh, cLtDolls9vN);
            fMonadPlusBrOBrC = new GHC.Base.CColMonadPlus(null, null, GHC.Types.nil_DataCon, GHC.Base.plusPlus);
            fAlternativeBrOBrC = new GHC.Base.CColAlternative(null, GHC.Types.nil_DataCon, GHC.Base.plusPlus, csomes9vd, cmanys9vu);
            lvls9v6 = new GHC.Types.Cons(GHC.Types.nil_DataCon, GHC.Types.nil_DataCon);
            fMonadBrOBrC = new GHC.Base.CColMonad(null, cGtGtEqs9no, cAstrGts9mc, cpures9mS, cfails9nm);
            fApplicativeBrOBrC = new GHC.Base.CColApplicative(null, cpures9mS, cLtAstrGts9mC, cliftA2s9ml, cAstrGts9mc, cLtAstrs9uW);
            fFunctorBrOBrC = new GHC.Base.CColFunctor(GHC.Base.map, cLtDolls9uQ);
            fMonoidOrdering = new GHC.Base.CColMonoid(cLtGts9iU, GHC.Types.eQ_DataCon, cLtGts9iU, gos9ss);
            fMonoidBrOBrC = new GHC.Base.CColMonoid(GHC.Base.plusPlus, GHC.Types.nil_DataCon, GHC.Base.plusPlus, cmconcats9jf);
            maxInt = new GHC.Types.IHash(9223372036854775807);
            minInt = new GHC.Types.IHash(-9223372036854775808);
            otherwise = new GHC.Types.True();
            fMonoidPrOPrC = new GHC.Base.CColMonoid(cLtGts9hy, GHC.Tuple.unit_DataCon, cLtGts9hy, cmconcats9jo);
            fApplicativeBrOBrC.x0 = GHC.Base.fFunctorBrOBrC;
            fMonadBrOBrC.x0 = GHC.Base.fApplicativeBrOBrC;
            fAlternativeBrOBrC.x0 = GHC.Base.fApplicativeBrOBrC;
            fMonadPlusBrOBrC.x0 = GHC.Base.fAlternativeBrOBrC;
            fMonadPlusBrOBrC.x1 = GHC.Base.fMonadBrOBrC;
            fApplicativeDashGt.x0 = GHC.Base.fFunctorDashGt;
            fMonadDashGt.x0 = GHC.Base.fApplicativeDashGt;
            fApplicativeMaybe.x0 = GHC.Base.fFunctorMaybe;
            fMonadMaybe.x0 = GHC.Base.fApplicativeMaybe;
            fAlternativeMaybe.x0 = GHC.Base.fApplicativeMaybe;
            fMonadPlusMaybe.x0 = GHC.Base.fAlternativeMaybe;
            fMonadPlusMaybe.x1 = GHC.Base.fMonadMaybe;
            ltGt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(ltGt_Entry));

            p1Monoid = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p1Monoid_Entry));

            mempty = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(mempty_Entry));

            mappend = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(mappend_Entry));

            mconcat = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(mconcat_Entry));

            fmap = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(fmap_Entry));

            ltDoll = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(ltDoll_Entry));

            p1Applicative = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p1Applicative_Entry));

            pure = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(pure_Entry));

            ltAstrGt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(ltAstrGt_Entry));

            liftA2 = new Fun(4, CLR.LoadFunctionPointer<Closure, Closure>(liftA2_Entry));

            astrGt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(astrGt_Entry));

            ltAstr = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(ltAstr_Entry));

            p1Alternative = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p1Alternative_Entry));

            empty = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(empty_Entry));

            ltPipeGt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(ltPipeGt_Entry));

            some = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(some_Entry));

            many = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(many_Entry));

            p1Monad = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p1Monad_Entry));

            gtGtEq = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(gtGtEq_Entry));

            gtGt = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(gtGt_Entry));

            @return = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(@return_Entry));

            fail = new Fun(2, CLR.LoadFunctionPointer<Closure, Closure>(fail_Entry));

            p1MonadPlus = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p1MonadPlus_Entry));

            p2MonadPlus = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(p2MonadPlus_Entry));

            mzero = new Fun(1, CLR.LoadFunctionPointer<Closure, Closure>(mzero_Entry));

            mplus = new Fun(3, CLR.LoadFunctionPointer<Closure, Closure>(mplus_Entry));

        }
        public static Closure cColMonoid_DataCon_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonoid(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColFunctor_DataCon_Entry(Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColFunctor(etaB2, etaB1);
        }
        public static Closure cColApplicative_DataCon_Entry(Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColApplicative(etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColAlternative_DataCon_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColAlternative(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColMonad_DataCon_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonad(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColMonadPlus_DataCon_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonadPlus(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColSemigroup_DataCon_Entry(Closure etaB1)
        {
            return new GHC.Base.CColSemigroup(etaB1);
        }
        public static Closure eqString_Entry(Closure dss9BS, Closure dss9BT)
        {
            var wilds9BU = dss9BS.Eval();
            switch (wilds9BU)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9BU_Nil:
                    {
                        var wilds9BV = dss9BT.Eval();
                        switch (wilds9BV)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Types.Nil wilds9BV_Nil:
                                {
                                    return GHC.Types.true_DataCon.Eval();
                                }
                            case GHC.Types.Cons wilds9BV_Cons:
                                {
                                    var ipvs9BW = wilds9BV_Cons.x0;
                                    var ipvs9BX = wilds9BV_Cons.x1;
                                    return GHC.Types.false_DataCon.Eval();
                                }
                        }
                    }
                case GHC.Types.Cons wilds9BU_Cons:
                    {
                        var c1s9BY = wilds9BU_Cons.x0;
                        var cs1s9BZ = wilds9BU_Cons.x1;
                        var wilds9C0 = dss9BT.Eval();
                        switch (wilds9C0)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Types.Nil wilds9C0_Nil:
                                {
                                    return GHC.Types.false_DataCon.Eval();
                                }
                            case GHC.Types.Cons wilds9C0_Cons:
                                {
                                    var c2s9C1 = wilds9C0_Cons.x0;
                                    var cs2s9C2 = wilds9C0_Cons.x1;
                                    var wilds9C3 = c1s9BY.Eval();
                                    var wilds9C3_CHash = wilds9C3 as GHC.Types.CHash;
                                    var xs9C4 = wilds9C3_CHash.x0;
                                    var wild1s9C5 = c2s9C1.Eval();
                                    var wild1s9C5_CHash = wild1s9C5 as GHC.Types.CHash;
                                    var ys9C6 = wild1s9C5_CHash.x0;
                                    var lwilds9C7 = (xs9C4 == ys9C6) ? 1 : 0;
                                    switch (lwilds9C7)
                                    {
                                        default: { return GHC.Types.false_DataCon.Eval(); }
                                        case 1: { return eqString_Entry(cs1s9BZ, cs2s9C2); }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure cmanys9BH_Entry(Closure vs9BI)
        {
            var many_vs9BJ = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(many_vs9BJ_Entry), vs9BI, null);
            many_vs9BJ.x1 = many_vs9BJ; return many_vs9BJ.Eval();
        }
        public static Closure many_vs9BJ_Entry(Closure vs9BI, Closure many_vs9BJ)
        {
            var wilds9BK = vs9BI.Eval();
            switch (wilds9BK)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9BK_Nothing: { return lvls9BG.Eval(); }
                case GHC.Maybe.Just wilds9BK_Just:
                    {
                        var xs9BL = wilds9BK_Just.x0;
                        var wilds9BM = many_vs9BJ.Eval();
                        switch (wilds9BM)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9BM_Nothing: { return lvls9BG.Eval(); }
                            case GHC.Maybe.Just wilds9BM_Just:
                                {
                                    var ys9BN = wilds9BM_Just.x0;
                                    var sats9BO = new GHC.Types.Cons(xs9BL, ys9BN);
                                    return new GHC.Maybe.Just(sats9BO);
                                }
                        }
                    }
            }
        }
        public static Closure csomes9Bx_Entry(Closure vs9By)
        {
            var some_vs9Bz = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(some_vs9Bz_Entry), vs9By, null);
            some_vs9Bz.x1 = some_vs9Bz; return some_vs9Bz.Eval();
        }
        public static Closure some_vs9Bz_Entry(Closure vs9By, Closure some_vs9Bz)
        {
            var wilds9BA = vs9By.Eval();
            switch (wilds9BA)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9BA_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9BA_Just:
                    {
                        var xs9BB = wilds9BA_Just.x0;
                        var wilds9BC = some_vs9Bz.Eval();
                        switch (wilds9BC)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9BC_Nothing:
                                {
                                    var sats9BD = new GHC.Types.Cons(xs9BB, GHC.Types.nil_DataCon);
                                    return new GHC.Maybe.Just(sats9BD);
                                }
                            case GHC.Maybe.Just wilds9BC_Just:
                                {
                                    var ipvs9BE = wilds9BC_Just.x0;
                                    var sats9BF = new GHC.Types.Cons(xs9BB, ipvs9BE);
                                    return new GHC.Maybe.Just(sats9BF);
                                }
                        }
                    }
            }
        }
        public static Closure liftM_Entry(Closure dMonads9Br, Closure fs9Bs, Closure m1s9Bt)
        {
            var sats9Bw = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9Bw_Entry), dMonads9Br, fs9Bs);
            return GHC.Base.gtGtEq_Entry(dMonads9Br).Apply<Closure, Closure, Closure>(m1s9Bt, sats9Bw);
        }
        public static Closure sats9Bw_Entry(Closure dMonads9Br, Closure fs9Bs, Closure x1s9Bu)
        {
            var sats9Bv = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9Bv_Entry), fs9Bs, x1s9Bu);
            return GHC.Base.@return_Entry(dMonads9Br).Apply<Closure, Closure>(sats9Bv);
        }
        public static Closure sats9Bv_Entry(Closure fs9Bs, Closure x1s9Bu)
        {
            return fs9Bs.Apply<Closure, Closure>(x1s9Bu);
        }
        public static Closure sliftMs9Bp_Entry(Closure etaB2, Closure etaB1)
        {
            return cfmaps9lh_Entry(etaB2, etaB1);
        }
        public static Closure liftM2_Entry(Closure dMonads9Bg, Closure fs9Bh, Closure m1s9Bi, Closure m2s9Bj)
        {
            var sats9Bo = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9Bo_Entry), dMonads9Bg, fs9Bh, m2s9Bj);
            return GHC.Base.gtGtEq_Entry(dMonads9Bg).Apply<Closure, Closure, Closure>(m1s9Bi, sats9Bo);
        }
        public static Closure sats9Bo_Entry(Closure dMonads9Bg, Closure fs9Bh, Closure m2s9Bj, Closure x1s9Bk)
        {
            var sats9Bn = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9Bn_Entry), dMonads9Bg, fs9Bh, x1s9Bk);
            return GHC.Base.gtGtEq_Entry(dMonads9Bg).Apply<Closure, Closure, Closure>(m2s9Bj, sats9Bn);
        }
        public static Closure sats9Bn_Entry(Closure dMonads9Bg, Closure fs9Bh, Closure x1s9Bk, Closure x2s9Bl)
        {
            var sats9Bm = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9Bm_Entry), fs9Bh, x1s9Bk, x2s9Bl);
            return GHC.Base.@return_Entry(dMonads9Bg).Apply<Closure, Closure>(sats9Bm);
        }
        public static Closure sats9Bm_Entry(Closure fs9Bh, Closure x1s9Bk, Closure x2s9Bl)
        {
            return fs9Bh.Apply<Closure, Closure, Closure>(x1s9Bk, x2s9Bl);
        }
        public static Closure sliftM2s9Be_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cliftA2s9m3_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure liftM3_Entry(Closure dMonads9B2, Closure fs9B3, Closure m1s9B4, Closure m2s9B5, Closure m3s9B6)
        {
            var sats9Bd = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9Bd_Entry), dMonads9B2, fs9B3, m2s9B5, m3s9B6);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m1s9B4, sats9Bd);
        }
        public static Closure sats9Bd_Entry(Closure dMonads9B2, Closure fs9B3, Closure m2s9B5, Closure m3s9B6, Closure x1s9B7)
        {
            var sats9Bc = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9Bc_Entry), dMonads9B2, fs9B3, m3s9B6, x1s9B7);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m2s9B5, sats9Bc);
        }
        public static Closure sats9Bc_Entry(Closure dMonads9B2, Closure fs9B3, Closure m3s9B6, Closure x1s9B7, Closure x2s9B8)
        {
            var sats9Bb = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9Bb_Entry), dMonads9B2, fs9B3, x1s9B7, x2s9B8);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m3s9B6, sats9Bb);
        }
        public static Closure sats9Bb_Entry(Closure dMonads9B2, Closure fs9B3, Closure x1s9B7, Closure x2s9B8, Closure x3s9B9)
        {
            var sats9Ba = new Updatable<Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9Ba_Entry), fs9B3, x1s9B7, x2s9B8, x3s9B9);
            return GHC.Base.@return_Entry(dMonads9B2).Apply<Closure, Closure>(sats9Ba);
        }
        public static Closure sats9Ba_Entry(Closure fs9B3, Closure x1s9B7, Closure x2s9B8, Closure x3s9B9)
        {
            return fs9B3.Apply<Closure, Closure, Closure, Closure>(x1s9B7, x2s9B8, x3s9B9);
        }
        public static Closure sliftM3s9AP_Entry(Closure fs9AQ, Closure m1s9AR, Closure m2s9AS, Closure m3s9AT)
        {
            var wilds9AU = m1s9AR.Eval();
            switch (wilds9AU)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9AU_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9AU_Just:
                    {
                        var xs9AV = wilds9AU_Just.x0;
                        var wilds9AW = m2s9AS.Eval();
                        switch (wilds9AW)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9AW_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9AW_Just:
                                {
                                    var xs9AX = wilds9AW_Just.x0;
                                    var wilds9AY = m3s9AT.Eval();
                                    switch (wilds9AY)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9AY_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9AY_Just:
                                            {
                                                var xs9AZ = wilds9AY_Just.x0;
                                                var sats9B0 = new Updatable<Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9B0_Entry), fs9AQ, xs9AV, xs9AX, xs9AZ);
                                                return new GHC.Maybe.Just(sats9B0);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9B0_Entry(Closure fs9AQ, Closure xs9AV, Closure xs9AX, Closure xs9AZ)
        {
            return fs9AQ.Apply<Closure, Closure, Closure, Closure>(xs9AV, xs9AX, xs9AZ);
        }
        public static Closure liftM4_Entry(Closure dMonads9AA, Closure fs9AB, Closure m1s9AC, Closure m2s9AD, Closure m3s9AE, Closure m4s9AF)
        {
            var sats9AO = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9AO_Entry), dMonads9AA, fs9AB, m2s9AD, m3s9AE, m4s9AF);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m1s9AC, sats9AO);
        }
        public static Closure sats9AO_Entry(Closure dMonads9AA, Closure fs9AB, Closure m2s9AD, Closure m3s9AE, Closure m4s9AF, Closure x1s9AG)
        {
            var sats9AN = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9AN_Entry), dMonads9AA, fs9AB, m3s9AE, m4s9AF, x1s9AG);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m2s9AD, sats9AN);
        }
        public static Closure sats9AN_Entry(Closure dMonads9AA, Closure fs9AB, Closure m3s9AE, Closure m4s9AF, Closure x1s9AG, Closure x2s9AH)
        {
            var sats9AM = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9AM_Entry), dMonads9AA, fs9AB, m4s9AF, x1s9AG, x2s9AH);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m3s9AE, sats9AM);
        }
        public static Closure sats9AM_Entry(Closure dMonads9AA, Closure fs9AB, Closure m4s9AF, Closure x1s9AG, Closure x2s9AH, Closure x3s9AI)
        {
            var sats9AL = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9AL_Entry), dMonads9AA, fs9AB, x1s9AG, x2s9AH, x3s9AI);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m4s9AF, sats9AL);
        }
        public static Closure sats9AL_Entry(Closure dMonads9AA, Closure fs9AB, Closure x1s9AG, Closure x2s9AH, Closure x3s9AI, Closure x4s9AJ)
        {
            var sats9AK = new Updatable<Closure, Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9AK_Entry), fs9AB, x1s9AG, x2s9AH, x3s9AI, x4s9AJ);
            return GHC.Base.@return_Entry(dMonads9AA).Apply<Closure, Closure>(sats9AK);
        }
        public static Closure sats9AK_Entry(Closure fs9AB, Closure x1s9AG, Closure x2s9AH, Closure x3s9AI, Closure x4s9AJ)
        {
            return fs9AB.Apply<Closure, Closure, Closure, Closure, Closure>(x1s9AG, x2s9AH, x3s9AI, x4s9AJ);
        }
        public static Closure sliftM4s9Ak_Entry(Closure fs9Al, Closure m1s9Am, Closure m2s9An, Closure m3s9Ao, Closure m4s9Ap)
        {
            var wilds9Aq = m1s9Am.Eval();
            switch (wilds9Aq)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9Aq_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9Aq_Just:
                    {
                        var xs9Ar = wilds9Aq_Just.x0;
                        var wilds9As = m2s9An.Eval();
                        switch (wilds9As)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9As_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9As_Just:
                                {
                                    var xs9At = wilds9As_Just.x0;
                                    var wilds9Au = m3s9Ao.Eval();
                                    switch (wilds9Au)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9Au_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9Au_Just:
                                            {
                                                var xs9Av = wilds9Au_Just.x0;
                                                var wilds9Aw = m4s9Ap.Eval();
                                                switch (wilds9Aw)
                                                {
                                                    default: { throw new ImpossibleException(); }
                                                    case GHC.Maybe.Nothing wilds9Aw_Nothing:
                                                        {
                                                            return GHC.Maybe.nothing_DataCon.Eval();
                                                        }
                                                    case GHC.Maybe.Just wilds9Aw_Just:
                                                        {
                                                            var xs9Ax = wilds9Aw_Just.x0;
                                                            var sats9Ay = new Updatable<Closure, Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9Ay_Entry), fs9Al, xs9Ar, xs9At, xs9Av, xs9Ax);
                                                            return new GHC.Maybe.Just(sats9Ay);
                                                        }
                                                }
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9Ay_Entry(Closure fs9Al, Closure xs9Ar, Closure xs9At, Closure xs9Av, Closure xs9Ax)
        {
            return fs9Al.Apply<Closure, Closure, Closure, Closure, Closure>(xs9Ar, xs9At, xs9Av, xs9Ax);
        }
        public static Closure liftM5_Entry(Closure dMonads9A2, Closure fs9A3, Closure m1s9A4, Closure m2s9A5, Closure m3s9A6, Closure m4s9A7, Closure m5s9A8)
        {
            var sats9Aj = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Aj_Entry), dMonads9A2, fs9A3, m2s9A5, m3s9A6, m4s9A7, m5s9A8);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m1s9A4, sats9Aj);
        }
        public static Closure sats9Aj_Entry(Closure dMonads9A2, Closure fs9A3, Closure m2s9A5, Closure m3s9A6, Closure m4s9A7, Closure m5s9A8, Closure x1s9A9)
        {
            var sats9Ai = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Ai_Entry), dMonads9A2, fs9A3, m3s9A6, m4s9A7, m5s9A8, x1s9A9);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m2s9A5, sats9Ai);
        }
        public static Closure sats9Ai_Entry(Closure dMonads9A2, Closure fs9A3, Closure m3s9A6, Closure m4s9A7, Closure m5s9A8, Closure x1s9A9, Closure x2s9Aa)
        {
            var sats9Ah = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Ah_Entry), dMonads9A2, fs9A3, m4s9A7, m5s9A8, x1s9A9, x2s9Aa);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m3s9A6, sats9Ah);
        }
        public static Closure sats9Ah_Entry(Closure dMonads9A2, Closure fs9A3, Closure m4s9A7, Closure m5s9A8, Closure x1s9A9, Closure x2s9Aa, Closure x3s9Ab)
        {
            var sats9Ag = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Ag_Entry), dMonads9A2, fs9A3, m5s9A8, x1s9A9, x2s9Aa, x3s9Ab);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m4s9A7, sats9Ag);
        }
        public static Closure sats9Ag_Entry(Closure dMonads9A2, Closure fs9A3, Closure m5s9A8, Closure x1s9A9, Closure x2s9Aa, Closure x3s9Ab, Closure x4s9Ac)
        {
            var sats9Af = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Af_Entry), dMonads9A2, fs9A3, x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m5s9A8, sats9Af);
        }
        public static Closure sats9Af_Entry(Closure dMonads9A2, Closure fs9A3, Closure x1s9A9, Closure x2s9Aa, Closure x3s9Ab, Closure x4s9Ac, Closure x5s9Ad)
        {
            var sats9Ae = new Updatable<Closure, Closure, Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9Ae_Entry), fs9A3, x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac, x5s9Ad);
            return GHC.Base.@return_Entry(dMonads9A2).Apply<Closure, Closure>(sats9Ae);
        }
        public static Closure sats9Ae_Entry(Closure fs9A3, Closure x1s9A9, Closure x2s9Aa, Closure x3s9Ab, Closure x4s9Ac, Closure x5s9Ad)
        {
            return fs9A3.Apply<Closure, Closure, Closure, Closure, Closure, Closure>(x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac, x5s9Ad);
        }
        public static Closure sliftM5s9zJ_Entry(Closure fs9zK, Closure m1s9zL, Closure m2s9zM, Closure m3s9zN, Closure m4s9zO, Closure m5s9zP)
        {
            var wilds9zQ = m1s9zL.Eval();
            switch (wilds9zQ)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9zQ_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9zQ_Just:
                    {
                        var xs9zR = wilds9zQ_Just.x0;
                        var wilds9zS = m2s9zM.Eval();
                        switch (wilds9zS)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9zS_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9zS_Just:
                                {
                                    var xs9zT = wilds9zS_Just.x0;
                                    var wilds9zU = m3s9zN.Eval();
                                    switch (wilds9zU)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9zU_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9zU_Just:
                                            {
                                                var xs9zV = wilds9zU_Just.x0;
                                                var wilds9zW = m4s9zO.Eval();
                                                switch (wilds9zW)
                                                {
                                                    default: { throw new ImpossibleException(); }
                                                    case GHC.Maybe.Nothing wilds9zW_Nothing:
                                                        {
                                                            return GHC.Maybe.nothing_DataCon.Eval();
                                                        }
                                                    case GHC.Maybe.Just wilds9zW_Just:
                                                        {
                                                            var xs9zX = wilds9zW_Just.x0;
                                                            var wilds9zY = m5s9zP.Eval();
                                                            switch (wilds9zY)
                                                            {
                                                                default: { throw new ImpossibleException(); }
                                                                case GHC.Maybe.Nothing wilds9zY_Nothing:
                                                                    {
                                                                        return GHC.Maybe.nothing_DataCon.Eval();
                                                                    }
                                                                case GHC.Maybe.Just wilds9zY_Just:
                                                                    {
                                                                        var xs9zZ = wilds9zY_Just.x0;
                                                                        var sats9A0 = new Updatable<Closure, Closure, Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9A0_Entry), fs9zK, xs9zR, xs9zT, xs9zV, xs9zX, xs9zZ);
                                                                        return new GHC.Maybe.Just(sats9A0);
                                                                    }
                                                            }
                                                        }
                                                }
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9A0_Entry(Closure fs9zK, Closure xs9zR, Closure xs9zT, Closure xs9zV, Closure xs9zX, Closure xs9zZ)
        {
            return fs9zK.Apply<Closure, Closure, Closure, Closure, Closure, Closure>(xs9zR, xs9zT, xs9zV, xs9zX, xs9zZ);
        }
        public static Closure ap_Entry(Closure dMonads9zB, Closure m1s9zC, Closure m2s9zD)
        {
            var sats9zI = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9zI_Entry), dMonads9zB, m2s9zD);
            return GHC.Base.gtGtEq_Entry(dMonads9zB).Apply<Closure, Closure, Closure>(m1s9zC, sats9zI);
        }
        public static Closure sats9zI_Entry(Closure dMonads9zB, Closure m2s9zD, Closure x1s9zE)
        {
            var sats9zH = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9zH_Entry), dMonads9zB, x1s9zE);
            return GHC.Base.gtGtEq_Entry(dMonads9zB).Apply<Closure, Closure, Closure>(m2s9zD, sats9zH);
        }
        public static Closure sats9zH_Entry(Closure dMonads9zB, Closure x1s9zE, Closure x2s9zF)
        {
            var sats9zG = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9zG_Entry), x1s9zE, x2s9zF);
            return GHC.Base.@return_Entry(dMonads9zB).Apply<Closure, Closure>(sats9zG);
        }
        public static Closure sats9zG_Entry(Closure x1s9zE, Closure x2s9zF)
        {
            return x1s9zE.Apply<Closure, Closure>(x2s9zF);
        }
        public static Closure saps9zs_Entry(Closure m1s9zt, Closure m2s9zu)
        {
            var wilds9zv = m1s9zt.Eval();
            switch (wilds9zv)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9zv_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9zv_Just:
                    {
                        var xs9zw = wilds9zv_Just.x0;
                        var wilds9zx = m2s9zu.Eval();
                        switch (wilds9zx)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9zx_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9zx_Just:
                                {
                                    var xs9zy = wilds9zx_Just.x0;
                                    var sats9zz = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9zz_Entry), xs9zw, xs9zy);
                                    return new GHC.Maybe.Just(sats9zz);
                                }
                        }
                    }
            }
        }
        public static Closure sats9zz_Entry(Closure xs9zw, Closure xs9zy)
        {
            return xs9zw.Apply<Closure, Closure>(xs9zy);
        }
        public static Closure when_Entry(Closure dApplicatives9zn, Closure ps9zo, Closure ss9zp)
        {
            var wilds9zq = ps9zo.Eval();
            var wilds9zqTags9zq = wilds9zq.Tag;
            switch (wilds9zqTags9zq)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9zq_False = wilds9zq as GHC.Types.False;
                        return GHC.Base.pure_Entry(dApplicatives9zn).Apply<Closure, Closure>(GHC.Tuple.unit_DataCon);
                    }
                case 2:
                    {
                        var wilds9zq_True = wilds9zq as GHC.Types.True;
                        return ss9zp.Eval();
                    }
            }
        }
        public static Closure swhens9zi_Entry(Closure ps9zj, Closure ss9zk)
        {
            var wilds9zl = ps9zj.Eval();
            var wilds9zlTags9zl = wilds9zl.Tag;
            switch (wilds9zlTags9zl)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9zl_False = wilds9zl as GHC.Types.False;
                        return lvls9zh.Eval();
                    }
                case 2:
                    {
                        var wilds9zl_True = wilds9zl as GHC.Types.True;
                        return ss9zk.Eval();
                    }
            }
        }
        public static Closure liftA_Entry(Closure dApplicatives9zd, Closure fs9ze, Closure as9zf)
        {
            var sats9zg = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9zg_Entry), dApplicatives9zd, fs9ze);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9zd).Apply<Closure, Closure, Closure>(sats9zg, as9zf);
        }
        public static Closure sats9zg_Entry(Closure dApplicatives9zd, Closure fs9ze)
        {
            return GHC.Base.pure_Entry(dApplicatives9zd).Apply<Closure, Closure>(fs9ze);
        }
        public static Closure sliftAs9zb_Entry(Closure etaB2, Closure etaB1)
        {
            return cfmaps9lh_Entry(etaB2, etaB1);
        }
        public static Closure liftA3_Entry(Closure dApplicatives9z5, Closure fs9z6, Closure as9z7, Closure bs9z8, Closure cs9z9)
        {
            var sats9za = new Updatable<Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9za_Entry), dApplicatives9z5, fs9z6, as9z7, bs9z8);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9z5).Apply<Closure, Closure, Closure>(sats9za, cs9z9);
        }
        public static Closure sats9za_Entry(Closure dApplicatives9z5, Closure fs9z6, Closure as9z7, Closure bs9z8)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9z5).Apply<Closure, Closure, Closure, Closure>(fs9z6, as9z7, bs9z8);
        }
        public static Closure sliftA3s9yS_Entry(Closure fs9yT, Closure as9yU, Closure bs9yV, Closure cs9yW)
        {
            var wilds9yX = as9yU.Eval();
            switch (wilds9yX)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9yX_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9yX_Just:
                    {
                        var xs9yY = wilds9yX_Just.x0;
                        var wilds9yZ = bs9yV.Eval();
                        switch (wilds9yZ)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9yZ_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9yZ_Just:
                                {
                                    var ys9z0 = wilds9yZ_Just.x0;
                                    var wilds9z1 = cs9yW.Eval();
                                    switch (wilds9z1)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9z1_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9z1_Just:
                                            {
                                                var as9z2 = wilds9z1_Just.x0;
                                                var sats9z3 = new Updatable<Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9z3_Entry), fs9yT, xs9yY, ys9z0, as9z2);
                                                return new GHC.Maybe.Just(sats9z3);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9z3_Entry(Closure fs9yT, Closure xs9yY, Closure ys9z0, Closure as9z2)
        {
            return fs9yT.Apply<Closure, Closure, Closure, Closure>(xs9yY, ys9z0, as9z2);
        }
        public static Closure cLtAstrs9yK_Entry(Closure dss9yL, Closure dss9yM)
        {
            var wilds9yN = dss9yL.Eval();
            switch (wilds9yN)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9yN_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9yN_Just:
                    {
                        var xs9yO = wilds9yN_Just.x0;
                        var wilds9yP = dss9yM.Eval();
                        switch (wilds9yP)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9yP_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9yP_Just:
                                {
                                    var ys9yQ = wilds9yP_Just.x0; return wilds9yN.Eval();
                                }
                        }
                    }
            }
        }
        public static Closure modInt_Entry(Closure dss9xJ, Closure dss9xK)
        {
            var wilds9xL = dss9xJ.Eval();
            var wilds9xL_IHash = wilds9xL as GHC.Types.IHash;
            var xs9xM = wilds9xL_IHash.x0;
            var wilds9xN = dss9xK.Eval();
            var wilds9xN_IHash = wilds9xN as GHC.Types.IHash;
            var ys9xO = wilds9xN_IHash.x0;
            var wilds9xP = GHC.Classes.modIntHash_Entry(xs9xM, ys9xO);
            return new GHC.Types.IHash(wilds9xP);
        }
        public static Closure divInt_Entry(Closure dss9xB, Closure dss9xC)
        {
            var wilds9xD = dss9xB.Eval();
            var wilds9xD_IHash = wilds9xD as GHC.Types.IHash;
            var xs9xE = wilds9xD_IHash.x0;
            var wilds9xF = dss9xC.Eval();
            var wilds9xF_IHash = wilds9xF as GHC.Types.IHash;
            var ys9xG = wilds9xF_IHash.x0;
            var wilds9xH = GHC.Classes.divIntHash_Entry(xs9xE, ys9xG);
            return new GHC.Types.IHash(wilds9xH);
        }
        public static Closure quotRemInt_Entry(Closure xs9xw, Closure ys9xx)
        {
            var sats9xz = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9xz_Entry), xs9xw, ys9xx);
            var sats9xy = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9xy_Entry), xs9xw, ys9xx);
            return new GHC.Tuple.Tuple2(sats9xy, sats9xz);
        }
        public static Closure sats9xy_Entry(Closure xs9xw, Closure ys9xx)
        {
            return quotInt_Entry(xs9xw, ys9xx);
        }
        public static Closure sats9xz_Entry(Closure xs9xw, Closure ys9xx)
        {
            return remInt_Entry(xs9xw, ys9xx);
        }
        public static Closure remInt_Entry(Closure dss9xo, Closure dss9xp)
        {
            var wilds9xq = dss9xo.Eval();
            var wilds9xq_IHash = wilds9xq as GHC.Types.IHash;
            var xs9xr = wilds9xq_IHash.x0;
            var wilds9xs = dss9xp.Eval();
            var wilds9xs_IHash = wilds9xs as GHC.Types.IHash;
            var ys9xt = wilds9xs_IHash.x0;
            var wilds9xu = xs9xr % ys9xt;
            return new GHC.Types.IHash(wilds9xu);
        }
        public static Closure quotInt_Entry(Closure dss9xg, Closure dss9xh)
        {
            var wilds9xi = dss9xg.Eval();
            var wilds9xi_IHash = wilds9xi as GHC.Types.IHash;
            var xs9xj = wilds9xi_IHash.x0;
            var wilds9xk = dss9xh.Eval();
            var wilds9xk_IHash = wilds9xk as GHC.Types.IHash;
            var ys9xl = wilds9xk_IHash.x0;
            var wilds9xm = xs9xj / ys9xl;
            return new GHC.Types.IHash(wilds9xm);
        }
        public static long getTag_Entry(Closure etaB1)
        {
            return etaB1.Tag;
        }
        public static GenericR dollBang_Entry<GenericR>(Closure fs9xb, Closure xs9xc)
        {
            var vxs9xd = xs9xc.Eval();
            return fs9xb.Apply<Closure, GenericR>(vxs9xd);
        }
        public static GenericR doll_Entry<GenericR>(Closure fs9x8, Closure xs9x9)
        {
            return fs9x8.Apply<Closure, GenericR>(xs9x9);
        }
        public static Closure flip_Entry(Closure fs9x4, Closure xs9x5, Closure ys9x6)
        {
            return fs9x4.Apply<Closure, Closure, Closure>(ys9x6, xs9x5);
        }
        public static Closure lvls9x0_Entry(Closure etas9x1)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(etas9x1);
        }
        public static Closure cGtGts9wZ_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9wQ_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure cLtAstrs9wU_Entry(Closure fs9wV, Closure gs9wW, Closure xs9wX)
        {
            return fs9wV.Apply<Closure, Closure>(xs9wX);
        }
        public static Closure cAstrGts9wQ_Entry(Closure a1s9wR, Closure a2s9wS, Closure xs9wT)
        {
            return a2s9wS.Apply<Closure, Closure>(xs9wT);
        }
        public static Closure cLtDolls9wL_Entry(Closure xs9wM, Closure etas9wN, Closure etas9wO)
        {
            return xs9wM.Eval();
        }
        public static Closure fMonadPrOComPrC_Entry(Closure dMonoids9wE)
        {
            var lvls9wF = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(lvls9wF_Entry), dMonoids9wE);
            var sats9wK = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9wK_Entry), lvls9wF);
            var sats9wI = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wI_Entry), dMonoids9wE);
            var sats9wH = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wH_Entry), dMonoids9wE);
            var sats9wG = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9wG_Entry), dMonoids9wE);
            return new GHC.Base.CColMonad(sats9wG, sats9wH, sats9wI, sats9wK, lvls9wB);
        }
        public static Closure sats9wG_Entry(Closure dMonoids9wE)
        {
            return fApplicativePrOComPrC_Entry(dMonoids9wE);
        }
        public static Closure sats9wH_Entry(Closure dMonoids9wE, Closure etaB2, Closure etaB1)
        {
            return cGtGtEqs9mZ_Entry(dMonoids9wE, etaB2, etaB1);
        }
        public static Closure sats9wI_Entry(Closure dMonoids9wE, Closure etaB2, Closure etaB1)
        {
            return cGtGts9wA_Entry(dMonoids9wE, etaB2, etaB1);
        }
        public static Closure sats9wK_Entry(Closure lvls9wF, Closure xs9wJ)
        {
            return new GHC.Tuple.Tuple2(lvls9wF, xs9wJ);
        }
        public static Closure lvls9wF_Entry(Closure dMonoids9wE)
        {
            return GHC.Base.mempty_Entry(dMonoids9wE);
        }
        public static Closure lvls9wB_Entry(Closure etas9wC)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(etas9wC);
        }
        public static Closure cGtGts9wA_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9w5_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure fApplicativePrOComPrC_Entry(Closure dMonoids9ws)
        {
            var lvls9wt = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(lvls9wt_Entry), dMonoids9ws);
            var sats9wz = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wz_Entry), dMonoids9ws);
            var sats9wy = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wy_Entry), dMonoids9ws);
            var sats9wx = new Fun<Closure>(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9wx_Entry), dMonoids9ws);
            var sats9ww = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ww_Entry), dMonoids9ws);
            var sats9wv = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9wv_Entry), lvls9wt);
            return new GHC.Base.CColApplicative(GHC.Base.fFunctorPrOComPrC, sats9wv, sats9ww, sats9wx, sats9wy, sats9wz);
        }
        public static Closure sats9wv_Entry(Closure lvls9wt, Closure xs9wu)
        {
            return new GHC.Tuple.Tuple2(lvls9wt, xs9wu);
        }
        public static Closure sats9ww_Entry(Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cLtAstrGts9lA_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure sats9wx_Entry(Closure dMonoids9ws, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cliftA2s9ln_Entry(dMonoids9ws, etaB3, etaB2, etaB1);
        }
        public static Closure sats9wy_Entry(Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9w5_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure sats9wz_Entry(Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cLtAstrs9wg_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure lvls9wt_Entry(Closure dMonoids9ws)
        {
            return GHC.Base.mempty_Entry(dMonoids9ws);
        }
        public static Closure cLtAstrs9wg_Entry(Closure dMonoids9wh, Closure etas9wi, Closure etas9wj)
        {
            var wilds9wk = etas9wi.Eval();
            var wilds9wk_Tuple2 = wilds9wk as GHC.Tuple.Tuple2;
            var us9wl = wilds9wk_Tuple2.x0;
            var xs9wm = wilds9wk_Tuple2.x1;
            var wilds9wn = etas9wj.Eval();
            var wilds9wn_Tuple2 = wilds9wn as GHC.Tuple.Tuple2;
            var vs9wo = wilds9wn_Tuple2.x0;
            var ys9wp = wilds9wn_Tuple2.x1;
            var sats9wq = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wq_Entry), dMonoids9wh, us9wl, vs9wo);
            return new GHC.Tuple.Tuple2(sats9wq, xs9wm);
        }
        public static Closure sats9wq_Entry(Closure dMonoids9wh, Closure us9wl, Closure vs9wo)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9wh).Apply<Closure, Closure, Closure>(us9wl, vs9wo);
        }
        public static Closure cAstrGts9w5_Entry(Closure dMonoids9w6, Closure a1s9w7, Closure a2s9w8)
        {
            var wilds9w9 = a1s9w7.Eval();
            var wilds9w9_Tuple2 = wilds9w9 as GHC.Tuple.Tuple2;
            var xs9wa = wilds9w9_Tuple2.x0;
            var ys9wb = wilds9w9_Tuple2.x1;
            var wilds9wc = a2s9w8.Eval();
            var wilds9wc_Tuple2 = wilds9wc as GHC.Tuple.Tuple2;
            var vs9wd = wilds9wc_Tuple2.x0;
            var xs9we = wilds9wc_Tuple2.x1;
            var sats9wf = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9wf_Entry), dMonoids9w6, xs9wa, vs9wd);
            return new GHC.Tuple.Tuple2(sats9wf, xs9we);
        }
        public static Closure sats9wf_Entry(Closure dMonoids9w6, Closure xs9wa, Closure vs9wd)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9w6).Apply<Closure, Closure, Closure>(xs9wa, vs9wd);
        }
        public static Closure cLtDolls9vY_Entry(Closure xs9vZ, Closure dss9w0)
        {
            var wilds9w1 = dss9w0.Eval();
            var wilds9w1_Tuple2 = wilds9w1 as GHC.Tuple.Tuple2;
            var xs9w2 = wilds9w1_Tuple2.x0;
            var ys9w3 = wilds9w1_Tuple2.x1;
            return new GHC.Tuple.Tuple2(xs9w2, xs9vZ);
        }
        public static Closure cLtAstrGts9vT_Entry(Closure dss9vU, Closure ms9vV)
        {
            var wilds9vW = dss9vU.Eval();
            switch (wilds9vW)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9vW_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9vW_Just:
                    {
                        var fs9vX = wilds9vW_Just.x0;
                        return cfmaps9lh_Entry(fs9vX, ms9vV);
                    }
            }
        }
        public static Closure cLtDolls9vN_Entry(Closure xs9vO, Closure dss9vP)
        {
            var wilds9vQ = dss9vP.Eval();
            switch (wilds9vQ)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9vQ_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9vQ_Just:
                    {
                        var as9vR = wilds9vQ_Just.x0; return new GHC.Maybe.Just(xs9vO);
                    }
            }
        }
        public static Closure cmanys9vu_Entry(Closure vs9vv)
        {
            var many_vs9vw = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(many_vs9vw_Entry), vs9vv, null);
            many_vs9vw.x1 = many_vs9vw; return many_vs9vw.Eval();
        }
        public static Closure many_vs9vw_Entry(Closure vs9vv, Closure many_vs9vw)
        {
            var gos9vx = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9vx_Entry), many_vs9vw, null);
            gos9vx.x1 = gos9vx;
            var sats9vK = gos9vx.Apply<Closure, Closure>(vs9vv).Eval();
            return poly_gos9v7_Entry(sats9vK);
        }
        public static Closure gos9vx_Entry(Closure many_vs9vw, Closure gos9vx, Closure dss9vy)
        {
            var wilds9vz = dss9vy.Eval();
            switch (wilds9vz)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vz_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9vz_Cons:
                    {
                        var ys9vA = wilds9vz_Cons.x0;
                        var yss9vB = wilds9vz_Cons.x1;
                        var zs9vC = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(zs9vC_Entry), gos9vx, yss9vB);
                        var gos9vD = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9vD_Entry), ys9vA, zs9vC, null);
                        gos9vD.x2 = gos9vD;
                        return gos9vD.Apply<Closure, Closure>(many_vs9vw);
                    }
            }
        }
        public static Closure gos9vD_Entry(Closure ys9vA, Closure zs9vC, Closure gos9vD, Closure dss9vE)
        {
            var wilds9vF = dss9vE.Eval();
            switch (wilds9vF)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vF_Nil: { return zs9vC.Eval(); }
                case GHC.Types.Cons wilds9vF_Cons:
                    {
                        var ys9vG = wilds9vF_Cons.x0;
                        var yss9vH = wilds9vF_Cons.x1;
                        var sats9vJ = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9vJ_Entry), gos9vD, yss9vH);
                        var sats9vI = new GHC.Types.Cons(ys9vA, ys9vG);
                        return new GHC.Types.Cons(sats9vI, sats9vJ);
                    }
            }
        }
        public static Closure sats9vJ_Entry(Closure gos9vD, Closure yss9vH)
        {
            return gos9vD.Apply<Closure, Closure>(yss9vH);
        }
        public static Closure zs9vC_Entry(Closure gos9vx, Closure yss9vB)
        {
            return gos9vx.Apply<Closure, Closure>(yss9vB);
        }
        public static Closure csomes9vd_Entry(Closure vs9ve)
        {
            var some_vs9vf = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(some_vs9vf_Entry), vs9ve, null);
            some_vs9vf.x1 = some_vs9vf; return some_vs9vf.Eval();
        }
        public static Closure some_vs9vf_Entry(Closure vs9ve, Closure some_vs9vf)
        {
            var yss9vg = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(yss9vg_Entry), some_vs9vf);
            var gos9vh = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9vh_Entry), yss9vg, null);
            gos9vh.x1 = gos9vh;
            return gos9vh.Apply<Closure, Closure>(vs9ve);
        }
        public static Closure gos9vh_Entry(Closure yss9vg, Closure gos9vh, Closure dss9vi)
        {
            var wilds9vj = dss9vi.Eval();
            switch (wilds9vj)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vj_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9vj_Cons:
                    {
                        var ys9vk = wilds9vj_Cons.x0;
                        var yss9vl = wilds9vj_Cons.x1;
                        var zs9vm = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(zs9vm_Entry), gos9vh, yss9vl);
                        var gos9vn = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9vn_Entry), ys9vk, zs9vm, null);
                        gos9vn.x2 = gos9vn;
                        return gos9vn.Apply<Closure, Closure>(yss9vg);
                    }
            }
        }
        public static Closure gos9vn_Entry(Closure ys9vk, Closure zs9vm, Closure gos9vn, Closure dss9vo)
        {
            var wilds9vp = dss9vo.Eval();
            switch (wilds9vp)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vp_Nil: { return zs9vm.Eval(); }
                case GHC.Types.Cons wilds9vp_Cons:
                    {
                        var ys9vq = wilds9vp_Cons.x0;
                        var yss9vr = wilds9vp_Cons.x1;
                        var sats9vt = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9vt_Entry), gos9vn, yss9vr);
                        var sats9vs = new GHC.Types.Cons(ys9vk, ys9vq);
                        return new GHC.Types.Cons(sats9vs, sats9vt);
                    }
            }
        }
        public static Closure sats9vt_Entry(Closure gos9vn, Closure yss9vr)
        {
            return gos9vn.Apply<Closure, Closure>(yss9vr);
        }
        public static Closure zs9vm_Entry(Closure gos9vh, Closure yss9vl)
        {
            return gos9vh.Apply<Closure, Closure>(yss9vl);
        }
        public static Closure yss9vg_Entry(Closure some_vs9vf)
        {
            return poly_gos9v7_Entry(some_vs9vf);
        }
        public static Closure poly_gos9v7_Entry(Closure dss9v8)
        {
            var wilds9v9 = dss9v8.Eval();
            switch (wilds9v9)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9v9_Nil: { return lvls9v6.Eval(); }
                case GHC.Types.Cons wilds9v9_Cons:
                    {
                        var ys9va = wilds9v9_Cons.x0;
                        var yss9vb = wilds9v9_Cons.x1;
                        var sats9vc = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9vc_Entry), yss9vb);
                        return new GHC.Types.Cons(ys9va, sats9vc);
                    }
            }
        }
        public static Closure sats9vc_Entry(Closure yss9vb)
        {
            return poly_gos9v7_Entry(yss9vb);
        }
        public static Closure eqLtLt_Entry(Closure dMonads9v3, Closure fs9v4, Closure xs9v5)
        {
            return GHC.Base.gtGtEq_Entry(dMonads9v3).Apply<Closure, Closure, Closure>(xs9v5, fs9v4);
        }
        public static Closure sEqLtLts9uZ_Entry(Closure fs9v0, Closure xs9v1)
        {
            return cGtGtEqs9no_Entry(xs9v1, fs9v0);
        }
        public static Closure cLtAstrs9uW_Entry(Closure etaB2, Closure etaB1)
        {
            return cliftA2s9ml_Entry(GHC.Base.@const, etaB2, etaB1);
        }
        public static Closure cLtDolls9uQ_Entry(Closure xs9uR, Closure etas9uS)
        {
            var sats9uU = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9uU_Entry), xs9uR);
            return map_Entry(sats9uU, etas9uS);
        }
        public static Closure sats9uU_Entry(Closure xs9uR, Closure dss9uT)
        {
            return xs9uR.Eval();
        }
        public static Closure dmLtDolls9uL_Entry(Closure dFunctors9uM, Closure etas9uN)
        {
            var sats9uP = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9uP_Entry), etas9uN);
            return GHC.Base.fmap_Entry(dFunctors9uM).Apply<Closure, Closure>(sats9uP);
        }
        public static Closure sats9uP_Entry(Closure etas9uN, Closure dss9uO)
        {
            return etas9uN.Eval();
        }
        public static Closure fMonoidDashGt_Entry(Closure dMonoids9uE)
        {
            var lvls9uF = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(lvls9uF_Entry), dMonoids9uE);
            var sats9uK = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9uK_Entry), dMonoids9uE);
            var sats9uJ = new Fun<Closure>(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9uJ_Entry), dMonoids9uE);
            var sats9uI = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9uI_Entry), lvls9uF);
            var sats9uG = new Fun<Closure>(3, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9uG_Entry), dMonoids9uE);
            return new GHC.Base.CColMonoid(sats9uG, sats9uI, sats9uJ, sats9uK);
        }
        public static Closure sats9uG_Entry(Closure dMonoids9uE, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jh_Entry(dMonoids9uE, etaB3, etaB2, etaB1);
        }
        public static Closure sats9uI_Entry(Closure lvls9uF, Closure dss9uH)
        {
            return lvls9uF.Eval();
        }
        public static Closure sats9uJ_Entry(Closure dMonoids9uE, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jh_Entry(dMonoids9uE, etaB3, etaB2, etaB1);
        }
        public static Closure sats9uK_Entry(Closure dMonoids9uE, Closure etaB2, Closure etaB1)
        {
            return cmconcats9uq_Entry(dMonoids9uE, etaB2, etaB1);
        }
        public static Closure lvls9uF_Entry(Closure dMonoids9uE)
        {
            return GHC.Base.mempty_Entry(dMonoids9uE);
        }
        public static Closure cmconcats9uq_Entry(Closure dMonoids9ur, Closure etas9us, Closure etas9ut)
        {
            var lvls9uu = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(lvls9uu_Entry), dMonoids9ur);
            var gos9uv = new Fun<Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(gos9uv_Entry), dMonoids9ur, lvls9uu, null);
            gos9uv.x2 = gos9uv;
            return gos9uv.Apply<Closure, Closure, Closure>(etas9us, etas9ut);
        }
        public static Closure gos9uv_Entry(Closure dMonoids9ur, Closure lvls9uu, Closure gos9uv, Closure dss9uw, Closure etas9ux)
        {
            var wilds9uy = dss9uw.Eval();
            switch (wilds9uy)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9uy_Nil: { return lvls9uu.Eval(); }
                case GHC.Types.Cons wilds9uy_Cons:
                    {
                        var ys9uz = wilds9uy_Cons.x0;
                        var yss9uA = wilds9uy_Cons.x1;
                        var sats9uC = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9uC_Entry), gos9uv, etas9ux, yss9uA);
                        var sats9uB = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9uB_Entry), etas9ux, ys9uz);
                        return GHC.Base.p1Monoid_Entry(dMonoids9ur).Apply<Closure, Closure, Closure>(sats9uB, sats9uC);
                    }
            }
        }
        public static Closure sats9uB_Entry(Closure etas9ux, Closure ys9uz)
        {
            return ys9uz.Apply<Closure, Closure>(etas9ux);
        }
        public static Closure sats9uC_Entry(Closure gos9uv, Closure etas9ux, Closure yss9uA)
        {
            return gos9uv.Apply<Closure, Closure, Closure>(yss9uA, etas9ux);
        }
        public static Closure lvls9uu_Entry(Closure dMonoids9ur)
        {
            return GHC.Base.mempty_Entry(dMonoids9ur);
        }
        public static Closure fMonoidPrOComPrC_Entry(Closure dMonoids9uk, Closure dMonoids9ul)
        {
            var sats9up = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9up_Entry), dMonoids9uk, dMonoids9ul);
            var sats9uo = new Fun<Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9uo_Entry), dMonoids9uk, dMonoids9ul);
            var sats9un = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9un_Entry), dMonoids9uk, dMonoids9ul);
            var sats9um = new Fun<Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9um_Entry), dMonoids9uk, dMonoids9ul);
            return new GHC.Base.CColMonoid(sats9um, sats9un, sats9uo, sats9up);
        }
        public static Closure sats9um_Entry(Closure dMonoids9uk, Closure dMonoids9ul, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jv_Entry(dMonoids9uk, dMonoids9ul, etaB2, etaB1);
        }
        public static Closure sats9un_Entry(Closure dMonoids9uk, Closure dMonoids9ul)
        {
            return cmemptys9jq_Entry(dMonoids9uk, dMonoids9ul);
        }
        public static Closure sats9uo_Entry(Closure dMonoids9uk, Closure dMonoids9ul, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jv_Entry(dMonoids9uk, dMonoids9ul, etaB2, etaB1);
        }
        public static Closure sats9up_Entry(Closure dMonoids9uk, Closure dMonoids9ul, Closure etaB1)
        {
            return cmconcats9tZ_Entry(dMonoids9uk, dMonoids9ul, etaB1);
        }
        public static Closure cmconcats9tZ_Entry(Closure dMonoids9u0, Closure dMonoids9u1, Closure etas9u2)
        {
            var zs9u3 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9u3_Entry), dMonoids9u0);
            var zs9u4 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9u4_Entry), dMonoids9u1);
            var zs9u5 = new GHC.Tuple.Tuple2(zs9u3, zs9u4);
            var gos9u6 = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(gos9u6_Entry), dMonoids9u0, dMonoids9u1, zs9u5, null);
            gos9u6.x3 = gos9u6;
            return gos9u6.Apply<Closure, Closure>(etas9u2);
        }
        public static Closure gos9u6_Entry(Closure dMonoids9u0, Closure dMonoids9u1, Closure zs9u5, Closure gos9u6, Closure dss9u7)
        {
            var wilds9u8 = dss9u7.Eval();
            switch (wilds9u8)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9u8_Nil: { return zs9u5.Eval(); }
                case GHC.Types.Cons wilds9u8_Cons:
                    {
                        var ys9u9 = wilds9u8_Cons.x0;
                        var yss9ua = wilds9u8_Cons.x1;
                        var wilds9ub = ys9u9.Eval();
                        var wilds9ub_Tuple2 = wilds9ub as GHC.Tuple.Tuple2;
                        var as9uc = wilds9ub_Tuple2.x0;
                        var bs9ud = wilds9ub_Tuple2.x1;
                        var wilds9ue = gos9u6.Apply<Closure, Closure>(yss9ua).Eval();
                        var wilds9ue_Tuple2 = wilds9ue as GHC.Tuple.Tuple2;
                        var a_s9uf = wilds9ue_Tuple2.x0;
                        var b_s9ug = wilds9ue_Tuple2.x1;
                        var sats9ui = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ui_Entry), dMonoids9u1, bs9ud, b_s9ug);
                        var sats9uh = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9uh_Entry), dMonoids9u0, as9uc, a_s9uf);
                        return new GHC.Tuple.Tuple2(sats9uh, sats9ui);
                    }
            }
        }
        public static Closure sats9uh_Entry(Closure dMonoids9u0, Closure as9uc, Closure a_s9uf)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9u0).Apply<Closure, Closure, Closure>(as9uc, a_s9uf);
        }
        public static Closure sats9ui_Entry(Closure dMonoids9u1, Closure bs9ud, Closure b_s9ug)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9u1).Apply<Closure, Closure, Closure>(bs9ud, b_s9ug);
        }
        public static Closure zs9u4_Entry(Closure dMonoids9u1)
        {
            return GHC.Base.mempty_Entry(dMonoids9u1);
        }
        public static Closure zs9u3_Entry(Closure dMonoids9u0)
        {
            return GHC.Base.mempty_Entry(dMonoids9u0);
        }
        public static Closure fMonoidPrOComComPrC_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU)
        {
            var sats9tY = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9tY_Entry), dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tX = new Fun<Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9tX_Entry), dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tW = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9tW_Entry), dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tV = new Fun<Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9tV_Entry), dMonoids9tS, dMonoids9tT, dMonoids9tU);
            return new GHC.Base.CColMonoid(sats9tV, sats9tW, sats9tX, sats9tY);
        }
        public static Closure sats9tV_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jP_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB2, etaB1);
        }
        public static Closure sats9tW_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU)
        {
            return cmemptys9jI_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU);
        }
        public static Closure sats9tX_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jP_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB2, etaB1);
        }
        public static Closure sats9tY_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU, Closure etaB1)
        {
            return cmconcats9ts_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB1);
        }
        public static Closure cmconcats9ts_Entry(Closure dMonoids9tt, Closure dMonoids9tu, Closure dMonoids9tv, Closure etas9tw)
        {
            var zs9tx = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9tx_Entry), dMonoids9tt);
            var zs9ty = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9ty_Entry), dMonoids9tu);
            var zs9tz = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9tz_Entry), dMonoids9tv);
            var zs9tA = new GHC.Tuple.Tuple3(zs9tx, zs9ty, zs9tz);
            var gos9tB = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(gos9tB_Entry), dMonoids9tt, dMonoids9tu, dMonoids9tv, zs9tA, null);
            gos9tB.x4 = gos9tB;
            return gos9tB.Apply<Closure, Closure>(etas9tw);
        }
        public static Closure gos9tB_Entry(Closure dMonoids9tt, Closure dMonoids9tu, Closure dMonoids9tv, Closure zs9tA, Closure gos9tB, Closure dss9tC)
        {
            var wilds9tD = dss9tC.Eval();
            switch (wilds9tD)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9tD_Nil: { return zs9tA.Eval(); }
                case GHC.Types.Cons wilds9tD_Cons:
                    {
                        var ys9tE = wilds9tD_Cons.x0;
                        var yss9tF = wilds9tD_Cons.x1;
                        var wws9tG = ys9tE.Eval();
                        var wws9tG_Tuple3 = wws9tG as GHC.Tuple.Tuple3;
                        var wws9tH = wws9tG_Tuple3.x0;
                        var wws9tI = wws9tG_Tuple3.x1;
                        var wws9tJ = wws9tG_Tuple3.x2;
                        var wws9tK = gos9tB.Apply<Closure, Closure>(yss9tF).Eval();
                        var wws9tK_Tuple3 = wws9tK as GHC.Tuple.Tuple3;
                        var wws9tL = wws9tK_Tuple3.x0;
                        var wws9tM = wws9tK_Tuple3.x1;
                        var wws9tN = wws9tK_Tuple3.x2;
                        var sats9tQ = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9tQ_Entry), dMonoids9tv, wws9tJ, wws9tN);
                        var sats9tP = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9tP_Entry), dMonoids9tu, wws9tI, wws9tM);
                        var sats9tO = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9tO_Entry), dMonoids9tt, wws9tH, wws9tL);
                        return new GHC.Tuple.Tuple3(sats9tO, sats9tP, sats9tQ);
                    }
            }
        }
        public static Closure sats9tO_Entry(Closure dMonoids9tt, Closure wws9tH, Closure wws9tL)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9tt).Apply<Closure, Closure, Closure>(wws9tH, wws9tL);
        }
        public static Closure sats9tP_Entry(Closure dMonoids9tu, Closure wws9tI, Closure wws9tM)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9tu).Apply<Closure, Closure, Closure>(wws9tI, wws9tM);
        }
        public static Closure sats9tQ_Entry(Closure dMonoids9tv, Closure wws9tJ, Closure wws9tN)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9tv).Apply<Closure, Closure, Closure>(wws9tJ, wws9tN);
        }
        public static Closure zs9tz_Entry(Closure dMonoids9tv)
        {
            return GHC.Base.mempty_Entry(dMonoids9tv);
        }
        public static Closure zs9ty_Entry(Closure dMonoids9tu)
        {
            return GHC.Base.mempty_Entry(dMonoids9tu);
        }
        public static Closure zs9tx_Entry(Closure dMonoids9tt)
        {
            return GHC.Base.mempty_Entry(dMonoids9tt);
        }
        public static Closure fMonoidPrOComComComPrC_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn)
        {
            var sats9tr = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9tr_Entry), dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9tq = new Fun<Closure, Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9tq_Entry), dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9tp = new Updatable<Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(sats9tp_Entry), dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9to = new Fun<Closure, Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9to_Entry), dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            return new GHC.Base.CColMonoid(sats9to, sats9tp, sats9tq, sats9tr);
        }
        public static Closure sats9to_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9kf_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB2, etaB1);
        }
        public static Closure sats9tp_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn)
        {
            return cmemptys9k6_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
        }
        public static Closure sats9tq_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9kf_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB2, etaB1);
        }
        public static Closure sats9tr_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn, Closure etaB1)
        {
            return cmconcats9t2_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB1);
        }
        public static Closure cmconcats9t2_Entry(Closure dMonoids9t3, Closure dMonoids9t4, Closure dMonoids9t5, Closure dMonoids9t6, Closure etas9t7)
        {
            var zs9t8 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9t8_Entry), dMonoids9t3);
            var zs9t9 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9t9_Entry), dMonoids9t4);
            var zs9ta = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9ta_Entry), dMonoids9t5);
            var zs9tb = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9tb_Entry), dMonoids9t6);
            var zs9tc = new GHC.Tuple.Tuple4(zs9t8, zs9t9, zs9ta, zs9tb);
            var gos9td = new Fun<Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(gos9td_Entry), dMonoids9t3, dMonoids9t4, dMonoids9t5, dMonoids9t6, zs9tc, null);
            gos9td.x5 = gos9td;
            return gos9td.Apply<Closure, Closure>(etas9t7);
        }
        public static Closure gos9td_Entry(Closure dMonoids9t3, Closure dMonoids9t4, Closure dMonoids9t5, Closure dMonoids9t6, Closure zs9tc, Closure gos9td, Closure dss9te)
        {
            var wilds9tf = dss9te.Eval();
            switch (wilds9tf)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9tf_Nil: { return zs9tc.Eval(); }
                case GHC.Types.Cons wilds9tf_Cons:
                    {
                        var ys9tg = wilds9tf_Cons.x0;
                        var yss9th = wilds9tf_Cons.x1;
                        var sats9ti = gos9td.Apply<Closure, Closure>(yss9th).Eval();
                        return cp1Monoids9kf_Entry(dMonoids9t3, dMonoids9t4, dMonoids9t5, dMonoids9t6, ys9tg, sats9ti);
                    }
            }
        }
        public static Closure zs9tb_Entry(Closure dMonoids9t6)
        {
            return GHC.Base.mempty_Entry(dMonoids9t6);
        }
        public static Closure zs9ta_Entry(Closure dMonoids9t5)
        {
            return GHC.Base.mempty_Entry(dMonoids9t5);
        }
        public static Closure zs9t9_Entry(Closure dMonoids9t4)
        {
            return GHC.Base.mempty_Entry(dMonoids9t4);
        }
        public static Closure zs9t8_Entry(Closure dMonoids9t3)
        {
            return GHC.Base.mempty_Entry(dMonoids9t3);
        }
        public static Closure fMonoidPrOComComComComPrC_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX)
        {
            var sats9t1 = new Fun<Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9t1_Entry), dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9t0 = new Fun<Closure, Closure, Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9t0_Entry), dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9sZ = new Updatable<Closure, Closure, Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(sats9sZ_Entry), dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9sY = new Fun<Closure, Closure, Closure, Closure, Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(sats9sY_Entry), dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            return new GHC.Base.CColMonoid(sats9sY, sats9sZ, sats9t0, sats9t1);
        }
        public static Closure sats9sY_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9kL_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB2, etaB1);
        }
        public static Closure sats9sZ_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX)
        {
            return cmemptys9kA_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
        }
        public static Closure sats9t0_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9kL_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB2, etaB1);
        }
        public static Closure sats9t1_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX, Closure etaB1)
        {
            return cmconcats9sz_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB1);
        }
        public static Closure cmconcats9sz_Entry(Closure dMonoids9sA, Closure dMonoids9sB, Closure dMonoids9sC, Closure dMonoids9sD, Closure dMonoids9sE, Closure etas9sF)
        {
            var zs9sG = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9sG_Entry), dMonoids9sA);
            var zs9sH = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9sH_Entry), dMonoids9sB);
            var zs9sI = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9sI_Entry), dMonoids9sC);
            var zs9sJ = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9sJ_Entry), dMonoids9sD);
            var zs9sK = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9sK_Entry), dMonoids9sE);
            var zs9sL = new GHC.Tuple.Tuple5(zs9sG, zs9sH, zs9sI, zs9sJ, zs9sK);
            var gos9sM = new Fun<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(gos9sM_Entry), dMonoids9sA, dMonoids9sB, dMonoids9sC, dMonoids9sD, dMonoids9sE, zs9sL, null);
            gos9sM.x6 = gos9sM;
            return gos9sM.Apply<Closure, Closure>(etas9sF);
        }
        public static Closure gos9sM_Entry(Closure dMonoids9sA, Closure dMonoids9sB, Closure dMonoids9sC, Closure dMonoids9sD, Closure dMonoids9sE, Closure zs9sL, Closure gos9sM, Closure dss9sN)
        {
            var wilds9sO = dss9sN.Eval();
            switch (wilds9sO)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9sO_Nil: { return zs9sL.Eval(); }
                case GHC.Types.Cons wilds9sO_Cons:
                    {
                        var ys9sP = wilds9sO_Cons.x0;
                        var yss9sQ = wilds9sO_Cons.x1;
                        var sats9sR = gos9sM.Apply<Closure, Closure>(yss9sQ).Eval();
                        return cp1Monoids9kL_Entry(dMonoids9sA, dMonoids9sB, dMonoids9sC, dMonoids9sD, dMonoids9sE, ys9sP, sats9sR);
                    }
            }
        }
        public static Closure zs9sK_Entry(Closure dMonoids9sE)
        {
            return GHC.Base.mempty_Entry(dMonoids9sE);
        }
        public static Closure zs9sJ_Entry(Closure dMonoids9sD)
        {
            return GHC.Base.mempty_Entry(dMonoids9sD);
        }
        public static Closure zs9sI_Entry(Closure dMonoids9sC)
        {
            return GHC.Base.mempty_Entry(dMonoids9sC);
        }
        public static Closure zs9sH_Entry(Closure dMonoids9sB)
        {
            return GHC.Base.mempty_Entry(dMonoids9sB);
        }
        public static Closure zs9sG_Entry(Closure dMonoids9sA)
        {
            return GHC.Base.mempty_Entry(dMonoids9sA);
        }
        public static Closure gos9ss_Entry(Closure dss9st)
        {
            var wilds9su = dss9st.Eval();
            switch (wilds9su)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9su_Nil:
                    {
                        return GHC.Types.eQ_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9su_Cons:
                    {
                        var ys9sv = wilds9su_Cons.x0;
                        var yss9sw = wilds9su_Cons.x1;
                        var wilds9sx = ys9sv.Eval();
                        var wilds9sxTags9sx = wilds9sx.Tag;
                        switch (wilds9sxTags9sx)
                        {
                            default: { throw new ImpossibleException(); }
                            case 1:
                                {
                                    var wilds9sx_LT = wilds9sx as GHC.Types.LT;
                                    return GHC.Types.lT_DataCon.Eval();
                                }
                            case 2:
                                {
                                    var wilds9sx_EQ = wilds9sx as GHC.Types.EQ;
                                    return gos9ss_Entry(yss9sw);
                                }
                            case 3:
                                {
                                    var wilds9sx_GT = wilds9sx as GHC.Types.GT;
                                    return GHC.Types.gT_DataCon.Eval();
                                }
                        }
                    }
            }
        }
        public static Closure fMonoidMaybe_Entry(Closure dSemigroups9so)
        {
            var sats9sr = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9sr_Entry), dSemigroups9so);
            var sats9sq = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9sq_Entry), dSemigroups9so);
            var sats9sp = new Fun<Closure>(2, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9sp_Entry), dSemigroups9so);
            return new GHC.Base.CColMonoid(sats9sp, GHC.Maybe.nothing_DataCon, sats9sq, sats9sr);
        }
        public static Closure sats9sp_Entry(Closure dSemigroups9so, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(dSemigroups9so, etaB2, etaB1);
        }
        public static Closure sats9sq_Entry(Closure dSemigroups9so, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(dSemigroups9so, etaB2, etaB1);
        }
        public static Closure sats9sr_Entry(Closure dSemigroups9so, Closure etaB1)
        {
            return cmconcats9sa_Entry(dSemigroups9so, etaB1);
        }
        public static Closure cmconcats9sa_Entry(Closure dSemigroups9sb, Closure etas9sc)
        {
            var gos9sd = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9sd_Entry), dSemigroups9sb, null);
            gos9sd.x1 = gos9sd;
            return gos9sd.Apply<Closure, Closure>(etas9sc);
        }
        public static Closure gos9sd_Entry(Closure dSemigroups9sb, Closure gos9sd, Closure dss9se)
        {
            var wilds9sf = dss9se.Eval();
            switch (wilds9sf)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9sf_Nil:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9sf_Cons:
                    {
                        var ys9sg = wilds9sf_Cons.x0;
                        var yss9sh = wilds9sf_Cons.x1;
                        var wilds9si = ys9sg.Eval();
                        switch (wilds9si)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9si_Nothing:
                                {
                                    return gos9sd.Apply<Closure, Closure>(yss9sh);
                                }
                            case GHC.Maybe.Just wilds9si_Just:
                                {
                                    var ipvs9sj = wilds9si_Just.x0;
                                    var wilds9sk = gos9sd.Apply<Closure, Closure>(yss9sh).Eval();
                                    switch (wilds9sk)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9sk_Nothing:
                                            {
                                                return wilds9si.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9sk_Just:
                                            {
                                                var ipvs9sl = wilds9sk_Just.x0;
                                                var sats9sm = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9sm_Entry), dSemigroups9sb, ipvs9sj, ipvs9sl);
                                                return new GHC.Maybe.Just(sats9sm);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9sm_Entry(Closure dSemigroups9sb, Closure ipvs9sj, Closure ipvs9sl)
        {
            return dSemigroups9sb.Apply<Closure, Closure, Closure>(ipvs9sj, ipvs9sl);
        }
        public static Closure dmmconcats9s0_Entry(Closure dMonoids9s1, Closure etas9s2)
        {
            var zs9s3 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9s3_Entry), dMonoids9s1);
            var gos9s4 = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9s4_Entry), dMonoids9s1, zs9s3, null);
            gos9s4.x2 = gos9s4;
            return gos9s4.Apply<Closure, Closure>(etas9s2);
        }
        public static Closure gos9s4_Entry(Closure dMonoids9s1, Closure zs9s3, Closure gos9s4, Closure dss9s5)
        {
            var wilds9s6 = dss9s5.Eval();
            switch (wilds9s6)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9s6_Nil: { return zs9s3.Eval(); }
                case GHC.Types.Cons wilds9s6_Cons:
                    {
                        var ys9s7 = wilds9s6_Cons.x0;
                        var yss9s8 = wilds9s6_Cons.x1;
                        var sats9s9 = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9s9_Entry), gos9s4, yss9s8);
                        return GHC.Base.mappend_Entry(dMonoids9s1).Apply<Closure, Closure, Closure>(ys9s7, sats9s9);
                    }
            }
        }
        public static Closure sats9s9_Entry(Closure gos9s4, Closure yss9s8)
        {
            return gos9s4.Apply<Closure, Closure>(yss9s8);
        }
        public static Closure zs9s3_Entry(Closure dMonoids9s1)
        {
            return GHC.Base.mempty_Entry(dMonoids9s1);
        }
        public static Closure sequence_Entry(Closure dMonads9rZ, Closure etaB1)
        {
            return mapM_Entry(dMonads9rZ, GHC.Base.id, etaB1);
        }
        public static Closure mapM_Entry(Closure dMonads9rI, Closure etas9rJ, Closure etas9rK)
        {
            var zs9rL = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(zs9rL_Entry), dMonads9rI);
            var gos9rM = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(gos9rM_Entry), dMonads9rI, etas9rJ, zs9rL, null);
            gos9rM.x3 = gos9rM;
            return gos9rM.Apply<Closure, Closure>(etas9rK);
        }
        public static Closure gos9rM_Entry(Closure dMonads9rI, Closure etas9rJ, Closure zs9rL, Closure gos9rM, Closure dss9rN)
        {
            var wilds9rO = dss9rN.Eval();
            switch (wilds9rO)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rO_Nil: { return zs9rL.Eval(); }
                case GHC.Types.Cons wilds9rO_Cons:
                    {
                        var ys9rP = wilds9rO_Cons.x0;
                        var yss9rQ = wilds9rO_Cons.x1;
                        var rs9rR = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(rs9rR_Entry), gos9rM, yss9rQ);
                        var sats9rX = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9rX_Entry), dMonads9rI, rs9rR);
                        var sats9rS = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rS_Entry), etas9rJ, ys9rP);
                        return GHC.Base.gtGtEq_Entry(dMonads9rI).Apply<Closure, Closure, Closure>(sats9rS, sats9rX);
                    }
            }
        }
        public static Closure sats9rS_Entry(Closure etas9rJ, Closure ys9rP)
        {
            return etas9rJ.Apply<Closure, Closure>(ys9rP);
        }
        public static Closure sats9rX_Entry(Closure dMonads9rI, Closure rs9rR, Closure xs9rT)
        {
            var sats9rW = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9rW_Entry), dMonads9rI, xs9rT);
            return GHC.Base.gtGtEq_Entry(dMonads9rI).Apply<Closure, Closure, Closure>(rs9rR, sats9rW);
        }
        public static Closure sats9rW_Entry(Closure dMonads9rI, Closure xs9rT, Closure xss9rU)
        {
            var sats9rV = new GHC.Types.Cons(xs9rT, xss9rU);
            return GHC.Base.@return_Entry(dMonads9rI).Apply<Closure, Closure>(sats9rV);
        }
        public static Closure rs9rR_Entry(Closure gos9rM, Closure yss9rQ)
        {
            return gos9rM.Apply<Closure, Closure>(yss9rQ);
        }
        public static Closure zs9rL_Entry(Closure dMonads9rI)
        {
            return GHC.Base.@return_Entry(dMonads9rI).Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure fSemigroupBrOBrC_Entry(Closure etaB2, Closure etaB1)
        {
            return plusPlus_Entry(etaB2, etaB1);
        }
        public static Closure plusPlus_Entry(Closure dss9rt, Closure yss9ru)
        {
            var wilds9rv = dss9rt.Eval();
            switch (wilds9rv)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rv_Nil: { return yss9ru.Eval(); }
                case GHC.Types.Cons wilds9rv_Cons:
                    {
                        var xs9rw = wilds9rv_Cons.x0;
                        var xss9rx = wilds9rv_Cons.x1;
                        var sats9rE = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rE_Entry), yss9ru, xss9rx);
                        return new GHC.Types.Cons(xs9rw, sats9rE);
                    }
            }
        }
        public static Closure plusPlus_DollsPlusPlus_Entry(Closure h, Closure t, Closure xs)
        {
            return plusPlus_Entry(new GHC.Types.Cons(h, t), xs); //TODO check if this works
        }
        public static Closure sats9rE_Entry(Closure yss9ru, Closure xss9rx)
        {
            var gos9ry = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9ry_Entry), yss9ru, null);
            gos9ry.x1 = gos9ry;
            return gos9ry.Apply<Closure, Closure>(xss9rx);
        }
        public static Closure gos9ry_Entry(Closure yss9ru, Closure gos9ry, Closure dss9rz)
        {
            var wilds9rA = dss9rz.Eval();
            switch (wilds9rA)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rA_Nil: { return yss9ru.Eval(); }
                case GHC.Types.Cons wilds9rA_Cons:
                    {
                        var ys9rB = wilds9rA_Cons.x0;
                        var yss9rC = wilds9rA_Cons.x1;
                        var sats9rD = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rD_Entry), gos9ry, yss9rC);
                        return new GHC.Types.Cons(ys9rB, sats9rD);
                    }
            }
        }
        public static Closure sats9rD_Entry(Closure gos9ry, Closure yss9rC)
        {
            return gos9ry.Apply<Closure, Closure>(yss9rC);
        }
        public static Closure map_Entry(Closure dss9rl, Closure dss9rm)
        {
            var wilds9rn = dss9rm.Eval();
            switch (wilds9rn)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rn_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9rn_Cons:
                    {
                        var xs9ro = wilds9rn_Cons.x0;
                        var xss9rp = wilds9rn_Cons.x1;
                        var sats9rr = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rr_Entry), dss9rl, xss9rp);
                        var sats9rq = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rq_Entry), dss9rl, xs9ro);
                        return new GHC.Types.Cons(sats9rq, sats9rr);
                    }
            }
        }
        public static Closure sats9rq_Entry(Closure dss9rl, Closure xs9ro)
        {
            return dss9rl.Apply<Closure, Closure>(xs9ro);
        }
        public static Closure sats9rr_Entry(Closure dss9rl, Closure xss9rp)
        {
            return map_Entry(dss9rl, xss9rp);
        }
        public static Closure foldr_Entry(Closure ks9rc, Closure zs9rd, Closure etas9re)
        {
            var gos9rf = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9rf_Entry), ks9rc, zs9rd, null);
            gos9rf.x2 = gos9rf;
            return gos9rf.Apply<Closure, Closure>(etas9re);
        }
        public static Closure gos9rf_Entry(Closure ks9rc, Closure zs9rd, Closure gos9rf, Closure dss9rg)
        {
            var wilds9rh = dss9rg.Eval();
            switch (wilds9rh)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rh_Nil: { return zs9rd.Eval(); }
                case GHC.Types.Cons wilds9rh_Cons:
                    {
                        var ys9ri = wilds9rh_Cons.x0;
                        var yss9rj = wilds9rh_Cons.x1;
                        var sats9rk = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9rk_Entry), gos9rf, yss9rj);
                        return ks9rc.Apply<Closure, Closure, Closure>(ys9ri, sats9rk);
                    }
            }
        }
        public static Closure sats9rk_Entry(Closure gos9rf, Closure yss9rj)
        {
            return gos9rf.Apply<Closure, Closure>(yss9rj);
        }
        public static Closure mapFB_Entry(Closure cs9r5, Closure fs9r6, Closure xs9r7, Closure yss9r8)
        {
            var sats9r9 = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9r9_Entry), fs9r6, xs9r7);
            return cs9r5.Apply<Closure, Closure, Closure>(sats9r9, yss9r8);
        }
        public static Closure sats9r9_Entry(Closure fs9r6, Closure xs9r7)
        {
            return fs9r6.Apply<Closure, Closure>(xs9r7);
        }
        public static Closure dot_Entry(Closure fs9r0, Closure gs9r1, Closure xs9r2)
        {
            var sats9r3 = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9r3_Entry), gs9r1, xs9r2);
            return fs9r0.Apply<Closure, Closure>(sats9r3);
        }
        public static Closure sats9r3_Entry(Closure gs9r1, Closure xs9r2)
        {
            return gs9r1.Apply<Closure, Closure>(xs9r2);
        }
        public static Closure dmLtAstrs9qX_Entry(Closure dApplicatives9qY)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9qY).Apply<Closure, Closure>(GHC.Base.@const);
        }
        public static Closure asTypeOf_Entry(Closure etaB2, Closure etaB1)
        {
            return @const_Entry(etaB2, etaB1);
        }
        public static Closure @const_Entry(Closure xs9qU, Closure dss9qV)
        {
            return xs9qU.Eval();
        }
        public static Closure breakpointCond_Entry(Closure etaB2, Closure etaB1)
        {
            return assert_Entry(etaB2, etaB1);
        }
        public static Closure breakpoint_Entry(Closure etaB1)
        {
            return id_Entry(etaB1);
        }
        public static Closure assert_Entry(Closure _preds9qP, Closure rs9qQ)
        {
            return rs9qQ.Eval();
        }
        public static Closure dmAstrGts9qI_Entry(Closure dApplicatives9qJ, Closure etas9qK, Closure etas9qL)
        {
            var sats9qN = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9qN_Entry), dApplicatives9qJ, etas9qK);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9qJ).Apply<Closure, Closure, Closure>(sats9qN, etas9qL);
        }
        public static Closure sats9qN_Entry(Closure dApplicatives9qJ, Closure etas9qK)
        {
            var sats9qM = GHC.Base.p1Applicative_Entry(dApplicatives9qJ).Eval();
            return GHC.Base.ltDoll_Entry(sats9qM).Apply<Closure, Closure, Closure>(GHC.Base.id, etas9qK);
        }
        public static Closure dmLtAstrGts9qG_Entry(Closure dApplicatives9qH)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9qH).Apply<Closure, Closure>(GHC.Base.id);
        }
        public static Closure join_Entry(Closure dMonads9qE, Closure xs9qF)
        {
            return GHC.Base.gtGtEq_Entry(dMonads9qE).Apply<Closure, Closure, Closure>(xs9qF, GHC.Base.id);
        }
        public static Closure id_Entry(Closure xs9qC)
        {
            return xs9qC.Eval();
        }
        public static Closure ord_Entry(Closure dss9qv)
        {
            var wilds9qw = dss9qv.Eval();
            var wilds9qw_CHash = wilds9qw as GHC.Types.CHash;
            var cHashs9qx = wilds9qw_CHash.x0;
            var sats9qy = (int)cHashs9qx;
            return new GHC.Types.IHash(sats9qy);
        }
        public static Closure unsafeChr_Entry(Closure dss9qq)
        {
            var wilds9qr = dss9qq.Eval();
            var wilds9qr_IHash = wilds9qr as GHC.Types.IHash;
            var iHashs9qs = wilds9qr_IHash.x0;
            var sats9qt = (char)iHashs9qs;
            return new GHC.Types.CHash(sats9qt);
        }
        public static long iShiftRLHash_Entry(long as9qm, long bs9qn)
        {
            var lwilds9qo = (bs9qn >= 64) ? 1 : 0;
            switch (lwilds9qo)
            {
                default: { return (long)(((ulong)as9qm) >> (int)bs9qn); }
                case 1: { return 0; }
            }
        }
        public static long iShiftRAHash_Entry(long etaB2, long etaB1)
        {
            return etaB2 >> (int)etaB1;
        }
        public static long iShiftLHash_Entry(long as9qh, long bs9qi)
        {
            var lwilds9qj = (bs9qi >= 64) ? 1 : 0;
            switch (lwilds9qj)
            {
                default: { return as9qh << (int)bs9qi; }
                case 1: { return 0; }
            }
        }
        public static ulong shiftRLHash_Entry(ulong as9qd, long bs9qe)
        {
            var lwilds9qf = (bs9qe >= 64) ? 1 : 0;
            switch (lwilds9qf)
            {
                default: { return as9qd >> (int)bs9qe; }
                case 1: { return 0UL; }
            }
        }
        public static ulong shiftLHash_Entry(ulong as9q9, long bs9qa)
        {
            var lwilds9qb = (bs9qa >= 64) ? 1 : 0;
            switch (lwilds9qb)
            {
                default: { return as9q9 << (int)bs9qa; }
                case 1: { return 0UL; }
            }
        }
        public static Closure divModInt_Entry(Closure ws9pb, Closure ws9pc)
        {
            var wws9pd = ws9pb.Eval();
            var wws9pd_IHash = wws9pd as GHC.Types.IHash;
            var wws9pe = wws9pd_IHash.x0;
            var wws9pf = ws9pc.Eval();
            var wws9pf_IHash = wws9pf as GHC.Types.IHash;
            var wws9pg = wws9pf_IHash.x0;
            var lwilds9ph = (wws9pe > 0) ? 1 : 0;
            switch (lwilds9ph)
            {
                default:
                    {
                        var lwilds9pi = (wws9pe < 0) ? 1 : 0;
                        switch (lwilds9pi)
                        {
                            default:
                                {
                                    var dss9pj = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                    var dss9pj_RawTuple = dss9pj;
                                    var ipvs9pk = dss9pj_RawTuple.x0;
                                    var ipvs9pl = dss9pj_RawTuple.x1;
                                    var sats9pn = new GHC.Types.IHash(ipvs9pl);
                                    var sats9pm = new GHC.Types.IHash(ipvs9pk);
                                    return new GHC.Tuple.Tuple2(sats9pm, sats9pn);
                                }
                            case 1:
                                {
                                    var lwilds9po = (wws9pg > 0) ? 1 : 0;
                                    switch (lwilds9po)
                                    {
                                        default:
                                            {
                                                var dss9pp = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                var dss9pp_RawTuple = dss9pp;
                                                var ipvs9pq = dss9pp_RawTuple.x0;
                                                var ipvs9pr = dss9pp_RawTuple.x1;
                                                var sats9pt = new GHC.Types.IHash(ipvs9pr);
                                                var sats9ps = new GHC.Types.IHash(ipvs9pq);
                                                return new GHC.Tuple.Tuple2(sats9ps, sats9pt);
                                            }
                                        case 1:
                                            {
                                                var sats9pu = wws9pe + 1;
                                                var dss9pv = (x0: sats9pu / wws9pg, x1: sats9pu % wws9pg);
                                                var dss9pv_RawTuple = dss9pv;
                                                var ipvs9pw = dss9pv_RawTuple.x0;
                                                var ipvs9px = dss9pv_RawTuple.x1;
                                                var sats9pA = ipvs9px + wws9pg;
                                                var sats9pB = sats9pA - 1;
                                                var sats9pC = new GHC.Types.IHash(sats9pB);
                                                var sats9py = ipvs9pw - 1;
                                                var sats9pz = new GHC.Types.IHash(sats9py);
                                                return new GHC.Tuple.Tuple2(sats9pz, sats9pC);
                                            }
                                    }
                                }
                        }
                    }
                case 1:
                    {
                        var lwilds9pD = (wws9pg < 0) ? 1 : 0;
                        switch (lwilds9pD)
                        {
                            default:
                                {
                                    var lwilds9pE = (wws9pe < 0) ? 1 : 0;
                                    switch (lwilds9pE)
                                    {
                                        default:
                                            {
                                                var dss9pF = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                var dss9pF_RawTuple = dss9pF;
                                                var ipvs9pG = dss9pF_RawTuple.x0;
                                                var ipvs9pH = dss9pF_RawTuple.x1;
                                                var sats9pJ = new GHC.Types.IHash(ipvs9pH);
                                                var sats9pI = new GHC.Types.IHash(ipvs9pG);
                                                return new GHC.Tuple.Tuple2(sats9pI, sats9pJ);
                                            }
                                        case 1:
                                            {
                                                var lwilds9pK = (wws9pg > 0) ? 1 : 0;
                                                switch (lwilds9pK)
                                                {
                                                    default:
                                                        {
                                                            var dss9pL = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                            var dss9pL_RawTuple = dss9pL;
                                                            var ipvs9pM = dss9pL_RawTuple.x0;
                                                            var ipvs9pN = dss9pL_RawTuple.x1;
                                                            var sats9pP = new GHC.Types.IHash(ipvs9pN);
                                                            var sats9pO = new GHC.Types.IHash(ipvs9pM);
                                                            return new GHC.Tuple.Tuple2(sats9pO, sats9pP);
                                                        }
                                                    case 1:
                                                        {
                                                            var sats9pQ = wws9pe + 1;
                                                            var dss9pR = (x0: sats9pQ / wws9pg, x1: sats9pQ % wws9pg);
                                                            var dss9pR_RawTuple = dss9pR;
                                                            var ipvs9pS = dss9pR_RawTuple.x0;
                                                            var ipvs9pT = dss9pR_RawTuple.x1;
                                                            var sats9pW = ipvs9pT + wws9pg;
                                                            var sats9pX = sats9pW - 1;
                                                            var sats9pY = new GHC.Types.IHash(sats9pX);
                                                            var sats9pU = ipvs9pS - 1;
                                                            var sats9pV = new GHC.Types.IHash(sats9pU);
                                                            return new GHC.Tuple.Tuple2(sats9pV, sats9pY);
                                                        }
                                                }
                                            }
                                    }
                                }
                            case 1:
                                {
                                    var sats9pZ = wws9pe - 1;
                                    var dss9q0 = (x0: sats9pZ / wws9pg, x1: sats9pZ % wws9pg);
                                    var dss9q0_RawTuple = dss9q0;
                                    var ipvs9q1 = dss9q0_RawTuple.x0;
                                    var ipvs9q2 = dss9q0_RawTuple.x1;
                                    var sats9q5 = ipvs9q2 + wws9pg;
                                    var sats9q6 = sats9q5 + 1;
                                    var sats9q7 = new GHC.Types.IHash(sats9q6);
                                    var sats9q3 = ipvs9q1 - 1;
                                    var sats9q4 = new GHC.Types.IHash(sats9q3);
                                    return new GHC.Tuple.Tuple2(sats9q4, sats9q7);
                                }
                        }
                    }
            }
        }
        public static (long x0, long x1) divModIntHash_Entry(long xHashs9oH, long yHashs9oI)
        {
            var lwilds9oJ = (xHashs9oH > 0) ? 1 : 0;
            switch (lwilds9oJ)
            {
                default:
                    {
                        var lwilds9oK = (xHashs9oH < 0) ? 1 : 0;
                        switch (lwilds9oK)
                        {
                            default:
                                {
                                    return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                }
                            case 1:
                                {
                                    var lwilds9oL = (yHashs9oI > 0) ? 1 : 0;
                                    switch (lwilds9oL)
                                    {
                                        default:
                                            {
                                                return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                            }
                                        case 1:
                                            {
                                                var sats9oM = xHashs9oH + 1;
                                                var dss9oN = (x0: sats9oM / yHashs9oI, x1: sats9oM % yHashs9oI);
                                                var dss9oN_RawTuple = dss9oN;
                                                var ipvs9oO = dss9oN_RawTuple.x0;
                                                var ipvs9oP = dss9oN_RawTuple.x1;
                                                var sats9oR = ipvs9oP + yHashs9oI;
                                                var sats9oS = sats9oR - 1;
                                                var sats9oQ = ipvs9oO - 1; return (sats9oQ, sats9oS);
                                            }
                                    }
                                }
                        }
                    }
                case 1:
                    {
                        var lwilds9oT = (yHashs9oI < 0) ? 1 : 0;
                        switch (lwilds9oT)
                        {
                            default:
                                {
                                    var lwilds9oU = (xHashs9oH < 0) ? 1 : 0;
                                    switch (lwilds9oU)
                                    {
                                        default:
                                            {
                                                return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                            }
                                        case 1:
                                            {
                                                var lwilds9oV = (yHashs9oI > 0) ? 1 : 0;
                                                switch (lwilds9oV)
                                                {
                                                    default:
                                                        {
                                                            return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                                        }
                                                    case 1:
                                                        {
                                                            var sats9oW = xHashs9oH + 1;
                                                            var dss9oX = (x0: sats9oW / yHashs9oI, x1: sats9oW % yHashs9oI);
                                                            var dss9oX_RawTuple = dss9oX;
                                                            var ipvs9oY = dss9oX_RawTuple.x0;
                                                            var ipvs9oZ = dss9oX_RawTuple.x1;
                                                            var sats9p1 = ipvs9oZ + yHashs9oI;
                                                            var sats9p2 = sats9p1 - 1;
                                                            var sats9p0 = ipvs9oY - 1;
                                                            return (sats9p0, sats9p2);
                                                        }
                                                }
                                            }
                                    }
                                }
                            case 1:
                                {
                                    var sats9p3 = xHashs9oH - 1;
                                    var dss9p4 = (x0: sats9p3 / yHashs9oI, x1: sats9p3 % yHashs9oI);
                                    var dss9p4_RawTuple = dss9p4;
                                    var ipvs9p5 = dss9p4_RawTuple.x0;
                                    var ipvs9p6 = dss9p4_RawTuple.x1;
                                    var sats9p8 = ipvs9p6 + yHashs9oI;
                                    var sats9p9 = sats9p8 + 1;
                                    var sats9p7 = ipvs9p5 - 1; return (sats9p7, sats9p9);
                                }
                        }
                    }
            }
        }
        public static Closure until_Entry(Closure ps9oz, Closure fs9oA, Closure etas9oB)
        {
            var gos9oC = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9oC_Entry), ps9oz, fs9oA, null);
            gos9oC.x2 = gos9oC;
            return gos9oC.Apply<Closure, Closure>(etas9oB);
        }
        public static Closure gos9oC_Entry(Closure ps9oz, Closure fs9oA, Closure gos9oC, Closure xs9oD)
        {
            var wilds9oE = ps9oz.Apply<Closure, Closure>(xs9oD).Eval();
            var wilds9oETags9oE = wilds9oE.Tag;
            switch (wilds9oETags9oE)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9oE_False = wilds9oE as GHC.Types.False;
                        var sats9oF = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9oF_Entry), fs9oA, xs9oD);
                        return gos9oC.Apply<Closure, Closure>(sats9oF);
                    }
                case 2:
                    {
                        var wilds9oE_True = wilds9oE as GHC.Types.True;
                        return xs9oD.Eval();
                    }
            }
        }
        public static Closure sats9oF_Entry(Closure fs9oA, Closure xs9oD)
        {
            return fs9oA.Apply<Closure, Closure>(xs9oD);
        }
        public static Closure augment_Entry(Closure gs9ov, Closure xss9ow)
        {
            return gs9ov.Apply<Closure, Closure, Closure>(GHC.Types.cons_DataCon, xss9ow);
        }
        public static Closure build_Entry(Closure gs9ot)
        {
            return gs9ot.Apply<Closure, Closure, Closure>(GHC.Types.cons_DataCon, GHC.Types.nil_DataCon);
        }
        public static Closure ltAstrAstrGt_Entry(Closure dApplicatives9or)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9or).Apply<Closure, Closure>(lvls9on);
        }
        public static Closure lvls9on_Entry(Closure as9oo, Closure fs9op)
        {
            return fs9op.Apply<Closure, Closure>(as9oo);
        }
        public static Closure ifThenElse_Entry(Closure dss9oj, Closure xs9ok, Closure ys9ol)
        {
            var wilds9om = dss9oj.Eval();
            var wilds9omTags9om = wilds9om.Tag;
            switch (wilds9omTags9om)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9om_False = wilds9om as GHC.Types.False;
                        return ys9ol.Eval();
                    }
                case 2:
                    {
                        var wilds9om_True = wilds9om as GHC.Types.True;
                        return xs9ok.Eval();
                    }
            }
        }
        public static Closure dmmappends9og_Entry(Closure etaB1)
        {
            return GHC.Base.p1Monoid_Entry(etaB1);
        }
        public static Closure dmliftA2s9oa_Entry(Closure dApplicatives9ob, Closure etas9oc, Closure etas9od)
        {
            var sats9of = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9of_Entry), dApplicatives9ob, etas9oc, etas9od);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9ob).Apply<Closure, Closure>(sats9of);
        }
        public static Closure sats9of_Entry(Closure dApplicatives9ob, Closure etas9oc, Closure etas9od)
        {
            var sats9oe = GHC.Base.p1Applicative_Entry(dApplicatives9ob).Eval();
            return GHC.Base.fmap_Entry(sats9oe).Apply<Closure, Closure, Closure>(etas9oc, etas9od);
        }
        public static Closure dmsomes9nX_Entry(Closure dAlternatives9nY, Closure etas9nZ)
        {
            var some_vs9o0 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(some_vs9o0_Entry), dAlternatives9nY, etas9nZ, null);
            some_vs9o0.x2 = some_vs9o0; return some_vs9o0.Eval();
        }
        public static Closure some_vs9o0_Entry(Closure dAlternatives9nY, Closure etas9nZ, Closure some_vs9o0)
        {
            var wws9o1 = GHC.Base.p1Alternative_Entry(dAlternatives9nY).Eval();
            var wws9o1_CColApplicative = wws9o1 as GHC.Base.CColApplicative;
            var wws9o2 = wws9o1_CColApplicative.x0;
            var wws9o3 = wws9o1_CColApplicative.x1;
            var wws9o4 = wws9o1_CColApplicative.x2;
            var wws9o5 = wws9o1_CColApplicative.x3;
            var wws9o6 = wws9o1_CColApplicative.x4;
            var wws9o7 = wws9o1_CColApplicative.x5;
            var sats9o9 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9o9_Entry), dAlternatives9nY, some_vs9o0, wws9o3);
            return wws9o5.Apply<Closure, Closure, Closure, Closure>(GHC.Types.cons_DataCon, etas9nZ, sats9o9);
        }
        public static Closure sats9o9_Entry(Closure dAlternatives9nY, Closure some_vs9o0, Closure wws9o3)
        {
            var sats9o8 = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9o8_Entry), wws9o3);
            return GHC.Base.ltPipeGt_Entry(dAlternatives9nY).Apply<Closure, Closure, Closure>(some_vs9o0, sats9o8);
        }
        public static Closure sats9o8_Entry(Closure wws9o3)
        {
            return wws9o3.Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure dmmanys9nQ_Entry(Closure dAlternatives9nR, Closure etas9nS)
        {
            var many_vs9nT = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(many_vs9nT_Entry), dAlternatives9nR, etas9nS, null);
            many_vs9nT.x2 = many_vs9nT; return many_vs9nT.Eval();
        }
        public static Closure many_vs9nT_Entry(Closure dAlternatives9nR, Closure etas9nS, Closure many_vs9nT)
        {
            var dApplicatives9nU = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(dApplicatives9nU_Entry), dAlternatives9nR);
            var sats9nW = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9nW_Entry), dApplicatives9nU);
            var sats9nV = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9nV_Entry), etas9nS, many_vs9nT, dApplicatives9nU);
            return GHC.Base.ltPipeGt_Entry(dAlternatives9nR).Apply<Closure, Closure, Closure>(sats9nV, sats9nW);
        }
        public static Closure sats9nV_Entry(Closure etas9nS, Closure many_vs9nT, Closure dApplicatives9nU)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9nU).Apply<Closure, Closure, Closure, Closure>(GHC.Types.cons_DataCon, etas9nS, many_vs9nT);
        }
        public static Closure sats9nW_Entry(Closure dApplicatives9nU)
        {
            return GHC.Base.pure_Entry(dApplicatives9nU).Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure dApplicatives9nU_Entry(Closure dAlternatives9nR)
        {
            return GHC.Base.p1Alternative_Entry(dAlternatives9nR);
        }
        public static Closure dmGtGts9nK_Entry(Closure dMonads9nL, Closure ms9nM, Closure ks9nN)
        {
            var sats9nP = new Fun<Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9nP_Entry), ks9nN);
            return GHC.Base.gtGtEq_Entry(dMonads9nL).Apply<Closure, Closure, Closure>(ms9nM, sats9nP);
        }
        public static Closure sats9nP_Entry(Closure ks9nN, Closure dss9nO)
        {
            return ks9nN.Eval();
        }
        public static Closure dmreturns9nH_Entry(Closure dMonads9nI)
        {
            var sats9nJ = GHC.Base.p1Monad_Entry(dMonads9nI).Eval();
            return GHC.Base.pure_Entry(sats9nJ);
        }
        public static Closure dmfails9nE_Entry(Closure dMonads9nF, Closure ss9nG)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(ss9nG);
        }
        public static Closure dmmzeros9nB_Entry(Closure dMonadPluss9nC)
        {
            var sats9nD = GHC.Base.p1MonadPlus_Entry(dMonadPluss9nC).Eval();
            return GHC.Base.empty_Entry(sats9nD);
        }
        public static Closure dmmpluss9ny_Entry(Closure dMonadPluss9nz)
        {
            var sats9nA = GHC.Base.p1MonadPlus_Entry(dMonadPluss9nz).Eval();
            return GHC.Base.ltPipeGt_Entry(sats9nA);
        }
        public static Closure cGtGtEqs9no_Entry(Closure xss9np, Closure fs9nq)
        {
            var gos9nr = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9nr_Entry), fs9nq, null);
            gos9nr.x1 = gos9nr;
            return gos9nr.Apply<Closure, Closure>(xss9np);
        }
        public static Closure gos9nr_Entry(Closure fs9nq, Closure gos9nr, Closure dss9ns)
        {
            var wilds9nt = dss9ns.Eval();
            switch (wilds9nt)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9nt_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9nt_Cons:
                    {
                        var ys9nu = wilds9nt_Cons.x0;
                        var yss9nv = wilds9nt_Cons.x1;
                        var sats9nx = new SingleEntry<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9nx_Entry), gos9nr, yss9nv);
                        var sats9nw = fs9nq.Apply<Closure, Closure>(ys9nu).Eval();
                        return plusPlus_Entry(sats9nw, sats9nx);
                    }
            }
        }
        public static Closure sats9nx_Entry(Closure gos9nr, Closure yss9nv)
        {
            return gos9nr.Apply<Closure, Closure>(yss9nv);
        }
        public static Closure cfails9nm_Entry(Closure dss9nn)
        {
            return GHC.Types.nil_DataCon.Eval();
        }
        public static Closure cGtGtEqs9nh_Entry(Closure dss9ni, Closure ks9nj)
        {
            var wilds9nk = dss9ni.Eval();
            switch (wilds9nk)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9nk_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9nk_Just:
                    {
                        var xs9nl = wilds9nk_Just.x0;
                        return ks9nj.Apply<Closure, Closure>(xs9nl);
                    }
            }
        }
        public static Closure cfails9nf_Entry(Closure dss9ng)
        {
            return GHC.Maybe.nothing_DataCon.Eval();
        }
        public static Closure cGtGtEqs9na_Entry(Closure fs9nb, Closure ks9nc, Closure rs9nd)
        {
            var sats9ne = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9ne_Entry), fs9nb, rs9nd);
            return ks9nc.Apply<Closure, Closure, Closure>(sats9ne, rs9nd);
        }
        public static Closure sats9ne_Entry(Closure fs9nb, Closure rs9nd)
        {
            return fs9nb.Apply<Closure, Closure>(rs9nd);
        }
        public static Closure cGtGtEqs9mZ_Entry(Closure dMonoids9n0, Closure etas9n1, Closure etas9n2)
        {
            var wilds9n3 = etas9n1.Eval();
            var wilds9n3_Tuple2 = wilds9n3 as GHC.Tuple.Tuple2;
            var us9n4 = wilds9n3_Tuple2.x0;
            var as9n5 = wilds9n3_Tuple2.x1;
            var wilds9n6 = etas9n2.Apply<Closure, Closure>(as9n5).Eval();
            var wilds9n6_Tuple2 = wilds9n6 as GHC.Tuple.Tuple2;
            var vs9n7 = wilds9n6_Tuple2.x0;
            var bs9n8 = wilds9n6_Tuple2.x1;
            var sats9n9 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9n9_Entry), dMonoids9n0, us9n4, vs9n7);
            return new GHC.Tuple.Tuple2(sats9n9, bs9n8);
        }
        public static Closure sats9n9_Entry(Closure dMonoids9n0, Closure us9n4, Closure vs9n7)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9n0).Apply<Closure, Closure, Closure>(us9n4, vs9n7);
        }
        public static Closure cLtPipeGts9mU_Entry(Closure dss9mV, Closure rs9mW)
        {
            var wilds9mX = dss9mV.Eval();
            switch (wilds9mX)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9mX_Nothing: { return rs9mW.Eval(); }
                case GHC.Maybe.Just wilds9mX_Just:
                    {
                        var ipvs9mY = wilds9mX_Just.x0; return wilds9mX.Eval();
                    }
            }
        }
        public static Closure cpures9mS_Entry(Closure xs9mT)
        {
            return new GHC.Types.Cons(xs9mT, GHC.Types.nil_DataCon);
        }
        public static Closure cLtAstrGts9mC_Entry(Closure fss9mD, Closure xss9mE)
        {
            var gos9mF = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9mF_Entry), xss9mE, null);
            gos9mF.x1 = gos9mF;
            return gos9mF.Apply<Closure, Closure>(fss9mD);
        }
        public static Closure gos9mF_Entry(Closure xss9mE, Closure gos9mF, Closure dss9mG)
        {
            var wilds9mH = dss9mG.Eval();
            switch (wilds9mH)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mH_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mH_Cons:
                    {
                        var ys9mI = wilds9mH_Cons.x0;
                        var yss9mJ = wilds9mH_Cons.x1;
                        var zs9mK = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(zs9mK_Entry), gos9mF, yss9mJ);
                        var gos9mL = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9mL_Entry), ys9mI, zs9mK, null);
                        gos9mL.x2 = gos9mL;
                        return gos9mL.Apply<Closure, Closure>(xss9mE);
                    }
            }
        }
        public static Closure gos9mL_Entry(Closure ys9mI, Closure zs9mK, Closure gos9mL, Closure dss9mM)
        {
            var wilds9mN = dss9mM.Eval();
            switch (wilds9mN)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mN_Nil: { return zs9mK.Eval(); }
                case GHC.Types.Cons wilds9mN_Cons:
                    {
                        var ys9mO = wilds9mN_Cons.x0;
                        var yss9mP = wilds9mN_Cons.x1;
                        var sats9mR = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9mR_Entry), gos9mL, yss9mP);
                        var sats9mQ = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9mQ_Entry), ys9mI, ys9mO);
                        return new GHC.Types.Cons(sats9mQ, sats9mR);
                    }
            }
        }
        public static Closure sats9mQ_Entry(Closure ys9mI, Closure ys9mO)
        {
            return ys9mI.Apply<Closure, Closure>(ys9mO);
        }
        public static Closure sats9mR_Entry(Closure gos9mL, Closure yss9mP)
        {
            return gos9mL.Apply<Closure, Closure>(yss9mP);
        }
        public static Closure zs9mK_Entry(Closure gos9mF, Closure yss9mJ)
        {
            return gos9mF.Apply<Closure, Closure>(yss9mJ);
        }
        public static Closure cliftA2s9ml_Entry(Closure fs9mm, Closure xss9mn, Closure yss9mo)
        {
            var gos9mp = new Fun<Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure>(gos9mp_Entry), fs9mm, yss9mo, null);
            gos9mp.x2 = gos9mp;
            return gos9mp.Apply<Closure, Closure>(xss9mn);
        }
        public static Closure gos9mp_Entry(Closure fs9mm, Closure yss9mo, Closure gos9mp, Closure dss9mq)
        {
            var wilds9mr = dss9mq.Eval();
            switch (wilds9mr)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mr_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mr_Cons:
                    {
                        var ys9ms = wilds9mr_Cons.x0;
                        var yss9mt = wilds9mr_Cons.x1;
                        var zs9mu = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(zs9mu_Entry), gos9mp, yss9mt);
                        var gos9mv = new Fun<Closure, Closure, Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure, Closure, Closure>(gos9mv_Entry), fs9mm, ys9ms, zs9mu, null);
                        gos9mv.x3 = gos9mv;
                        return gos9mv.Apply<Closure, Closure>(yss9mo);
                    }
            }
        }
        public static Closure gos9mv_Entry(Closure fs9mm, Closure ys9ms, Closure zs9mu, Closure gos9mv, Closure dss9mw)
        {
            var wilds9mx = dss9mw.Eval();
            switch (wilds9mx)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mx_Nil: { return zs9mu.Eval(); }
                case GHC.Types.Cons wilds9mx_Cons:
                    {
                        var ys9my = wilds9mx_Cons.x0;
                        var yss9mz = wilds9mx_Cons.x1;
                        var sats9mB = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9mB_Entry), gos9mv, yss9mz);
                        var sats9mA = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9mA_Entry), fs9mm, ys9ms, ys9my);
                        return new GHC.Types.Cons(sats9mA, sats9mB);
                    }
            }
        }
        public static Closure sats9mA_Entry(Closure fs9mm, Closure ys9ms, Closure ys9my)
        {
            return fs9mm.Apply<Closure, Closure, Closure>(ys9ms, ys9my);
        }
        public static Closure sats9mB_Entry(Closure gos9mv, Closure yss9mz)
        {
            return gos9mv.Apply<Closure, Closure>(yss9mz);
        }
        public static Closure zs9mu_Entry(Closure gos9mp, Closure yss9mt)
        {
            return gos9mp.Apply<Closure, Closure>(yss9mt);
        }
        public static Closure cAstrGts9mc_Entry(Closure xss9md, Closure yss9me)
        {
            var gos9mf = new Fun<Closure, Closure>(1, CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(gos9mf_Entry), yss9me, null);
            gos9mf.x1 = gos9mf;
            return gos9mf.Apply<Closure, Closure>(xss9md);
        }
        public static Closure gos9mf_Entry(Closure yss9me, Closure gos9mf, Closure dss9mg)
        {
            var wilds9mh = dss9mg.Eval();
            switch (wilds9mh)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mh_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mh_Cons:
                    {
                        var ys9mi = wilds9mh_Cons.x0;
                        var yss9mj = wilds9mh_Cons.x1;
                        var sats9mk = new SingleEntry<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9mk_Entry), gos9mf, yss9mj);
                        return plusPlus_Entry(yss9me, sats9mk);
                    }
            }
        }
        public static Closure sats9mk_Entry(Closure gos9mf, Closure yss9mj)
        {
            return gos9mf.Apply<Closure, Closure>(yss9mj);
        }
        public static Closure cliftA2s9m3_Entry(Closure fs9m4, Closure dss9m5, Closure dss9m6)
        {
            var wilds9m7 = dss9m5.Eval();
            switch (wilds9m7)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9m7_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9m7_Just:
                    {
                        var xs9m8 = wilds9m7_Just.x0;
                        var wilds9m9 = dss9m6.Eval();
                        switch (wilds9m9)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9m9_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9m9_Just:
                                {
                                    var ys9ma = wilds9m9_Just.x0;
                                    var sats9mb = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9mb_Entry), fs9m4, xs9m8, ys9ma);
                                    return new GHC.Maybe.Just(sats9mb);
                                }
                        }
                    }
            }
        }
        public static Closure sats9mb_Entry(Closure fs9m4, Closure xs9m8, Closure ys9ma)
        {
            return fs9m4.Apply<Closure, Closure, Closure>(xs9m8, ys9ma);
        }
        public static Closure cAstrGts9lY_Entry(Closure dss9lZ, Closure m2s9m0)
        {
            var wilds9m1 = dss9lZ.Eval();
            switch (wilds9m1)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9m1_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9m1_Just:
                    {
                        var _m1s9m2 = wilds9m1_Just.x0; return m2s9m0.Eval();
                    }
            }
        }
        public static Closure cLtAstrGts9lT_Entry(Closure fs9lU, Closure gs9lV, Closure xs9lW)
        {
            var sats9lX = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lX_Entry), gs9lV, xs9lW);
            return fs9lU.Apply<Closure, Closure, Closure>(xs9lW, sats9lX);
        }
        public static Closure sats9lX_Entry(Closure gs9lV, Closure xs9lW)
        {
            return gs9lV.Apply<Closure, Closure>(xs9lW);
        }
        public static Closure cliftA2s9lM_Entry(Closure qs9lN, Closure fs9lO, Closure gs9lP, Closure xs9lQ)
        {
            var sats9lS = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lS_Entry), gs9lP, xs9lQ);
            var sats9lR = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lR_Entry), fs9lO, xs9lQ);
            return qs9lN.Apply<Closure, Closure, Closure>(sats9lR, sats9lS);
        }
        public static Closure sats9lR_Entry(Closure fs9lO, Closure xs9lQ)
        {
            return fs9lO.Apply<Closure, Closure>(xs9lQ);
        }
        public static Closure sats9lS_Entry(Closure gs9lP, Closure xs9lQ)
        {
            return gs9lP.Apply<Closure, Closure>(xs9lQ);
        }
        public static Closure cLtAstrGts9lA_Entry(Closure dMonoids9lB, Closure etas9lC, Closure etas9lD)
        {
            var wilds9lE = etas9lC.Eval();
            var wilds9lE_Tuple2 = wilds9lE as GHC.Tuple.Tuple2;
            var us9lF = wilds9lE_Tuple2.x0;
            var fs9lG = wilds9lE_Tuple2.x1;
            var wilds9lH = etas9lD.Eval();
            var wilds9lH_Tuple2 = wilds9lH as GHC.Tuple.Tuple2;
            var vs9lI = wilds9lH_Tuple2.x0;
            var xs9lJ = wilds9lH_Tuple2.x1;
            var sats9lL = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lL_Entry), fs9lG, xs9lJ);
            var sats9lK = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9lK_Entry), dMonoids9lB, us9lF, vs9lI);
            return new GHC.Tuple.Tuple2(sats9lK, sats9lL);
        }
        public static Closure sats9lK_Entry(Closure dMonoids9lB, Closure us9lF, Closure vs9lI)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9lB).Apply<Closure, Closure, Closure>(us9lF, vs9lI);
        }
        public static Closure sats9lL_Entry(Closure fs9lG, Closure xs9lJ)
        {
            return fs9lG.Apply<Closure, Closure>(xs9lJ);
        }
        public static Closure cliftA2s9ln_Entry(Closure dMonoids9lo, Closure etas9lp, Closure etas9lq, Closure etas9lr)
        {
            var wilds9ls = etas9lq.Eval();
            var wilds9ls_Tuple2 = wilds9ls as GHC.Tuple.Tuple2;
            var us9lt = wilds9ls_Tuple2.x0;
            var xs9lu = wilds9ls_Tuple2.x1;
            var wilds9lv = etas9lr.Eval();
            var wilds9lv_Tuple2 = wilds9lv as GHC.Tuple.Tuple2;
            var vs9lw = wilds9lv_Tuple2.x0;
            var ys9lx = wilds9lv_Tuple2.x1;
            var sats9lz = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9lz_Entry), etas9lp, xs9lu, ys9lx);
            var sats9ly = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ly_Entry), dMonoids9lo, us9lt, vs9lw);
            return new GHC.Tuple.Tuple2(sats9ly, sats9lz);
        }
        public static Closure sats9ly_Entry(Closure dMonoids9lo, Closure us9lt, Closure vs9lw)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9lo).Apply<Closure, Closure, Closure>(us9lt, vs9lw);
        }
        public static Closure sats9lz_Entry(Closure etas9lp, Closure xs9lu, Closure ys9lx)
        {
            return etas9lp.Apply<Closure, Closure, Closure>(xs9lu, ys9lx);
        }
        public static Closure cfmaps9lh_Entry(Closure dss9li, Closure dss9lj)
        {
            var wilds9lk = dss9lj.Eval();
            switch (wilds9lk)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9lk_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9lk_Just:
                    {
                        var as9ll = wilds9lk_Just.x0;
                        var sats9lm = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lm_Entry), dss9li, as9ll);
                        return new GHC.Maybe.Just(sats9lm);
                    }
            }
        }
        public static Closure sats9lm_Entry(Closure dss9li, Closure as9ll)
        {
            return dss9li.Apply<Closure, Closure>(as9ll);
        }
        public static Closure cfmaps9la_Entry(Closure fs9lb, Closure dss9lc)
        {
            var wilds9ld = dss9lc.Eval();
            var wilds9ld_Tuple2 = wilds9ld as GHC.Tuple.Tuple2;
            var xs9le = wilds9ld_Tuple2.x0;
            var ys9lf = wilds9ld_Tuple2.x1;
            var sats9lg = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9lg_Entry), fs9lb, ys9lf);
            return new GHC.Tuple.Tuple2(xs9le, sats9lg);
        }
        public static Closure sats9lg_Entry(Closure fs9lb, Closure ys9lf)
        {
            return fs9lb.Apply<Closure, Closure>(ys9lf);
        }
        public static Closure cp1Monoids9kL_Entry(Closure dMonoids9kM, Closure dMonoids9kN, Closure dMonoids9kO, Closure dMonoids9kP, Closure dMonoids9kQ, Closure etas9kR, Closure etas9kS)
        {
            var wilds9kT = etas9kR.Eval();
            var wilds9kT_Tuple5 = wilds9kT as GHC.Tuple.Tuple5;
            var as9kU = wilds9kT_Tuple5.x0;
            var bs9kV = wilds9kT_Tuple5.x1;
            var cs9kW = wilds9kT_Tuple5.x2;
            var ds9kX = wilds9kT_Tuple5.x3;
            var es9kY = wilds9kT_Tuple5.x4;
            var wilds9kZ = etas9kS.Eval();
            var wilds9kZ_Tuple5 = wilds9kZ as GHC.Tuple.Tuple5;
            var a_s9l0 = wilds9kZ_Tuple5.x0;
            var b_s9l1 = wilds9kZ_Tuple5.x1;
            var c_s9l2 = wilds9kZ_Tuple5.x2;
            var d_s9l3 = wilds9kZ_Tuple5.x3;
            var e_s9l4 = wilds9kZ_Tuple5.x4;
            var sats9l9 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9l9_Entry), dMonoids9kQ, es9kY, e_s9l4);
            var sats9l8 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9l8_Entry), dMonoids9kP, ds9kX, d_s9l3);
            var sats9l7 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9l7_Entry), dMonoids9kO, cs9kW, c_s9l2);
            var sats9l6 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9l6_Entry), dMonoids9kN, bs9kV, b_s9l1);
            var sats9l5 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9l5_Entry), dMonoids9kM, as9kU, a_s9l0);
            return new GHC.Tuple.Tuple5(sats9l5, sats9l6, sats9l7, sats9l8, sats9l9);
        }
        public static Closure sats9l5_Entry(Closure dMonoids9kM, Closure as9kU, Closure a_s9l0)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kM).Apply<Closure, Closure, Closure>(as9kU, a_s9l0);
        }
        public static Closure sats9l6_Entry(Closure dMonoids9kN, Closure bs9kV, Closure b_s9l1)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kN).Apply<Closure, Closure, Closure>(bs9kV, b_s9l1);
        }
        public static Closure sats9l7_Entry(Closure dMonoids9kO, Closure cs9kW, Closure c_s9l2)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kO).Apply<Closure, Closure, Closure>(cs9kW, c_s9l2);
        }
        public static Closure sats9l8_Entry(Closure dMonoids9kP, Closure ds9kX, Closure d_s9l3)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kP).Apply<Closure, Closure, Closure>(ds9kX, d_s9l3);
        }
        public static Closure sats9l9_Entry(Closure dMonoids9kQ, Closure es9kY, Closure e_s9l4)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kQ).Apply<Closure, Closure, Closure>(es9kY, e_s9l4);
        }
        public static Closure cmemptys9kA_Entry(Closure dMonoids9kB, Closure dMonoids9kC, Closure dMonoids9kD, Closure dMonoids9kE, Closure dMonoids9kF)
        {
            var sats9kK = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kK_Entry), dMonoids9kF);
            var sats9kJ = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kJ_Entry), dMonoids9kE);
            var sats9kI = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kI_Entry), dMonoids9kD);
            var sats9kH = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kH_Entry), dMonoids9kC);
            var sats9kG = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kG_Entry), dMonoids9kB);
            return new GHC.Tuple.Tuple5(sats9kG, sats9kH, sats9kI, sats9kJ, sats9kK);
        }
        public static Closure sats9kG_Entry(Closure dMonoids9kB)
        {
            return GHC.Base.mempty_Entry(dMonoids9kB);
        }
        public static Closure sats9kH_Entry(Closure dMonoids9kC)
        {
            return GHC.Base.mempty_Entry(dMonoids9kC);
        }
        public static Closure sats9kI_Entry(Closure dMonoids9kD)
        {
            return GHC.Base.mempty_Entry(dMonoids9kD);
        }
        public static Closure sats9kJ_Entry(Closure dMonoids9kE)
        {
            return GHC.Base.mempty_Entry(dMonoids9kE);
        }
        public static Closure sats9kK_Entry(Closure dMonoids9kF)
        {
            return GHC.Base.mempty_Entry(dMonoids9kF);
        }
        public static Closure cp1Monoids9kf_Entry(Closure dMonoids9kg, Closure dMonoids9kh, Closure dMonoids9ki, Closure dMonoids9kj, Closure etas9kk, Closure etas9kl)
        {
            var wilds9km = etas9kk.Eval();
            var wilds9km_Tuple4 = wilds9km as GHC.Tuple.Tuple4;
            var as9kn = wilds9km_Tuple4.x0;
            var bs9ko = wilds9km_Tuple4.x1;
            var cs9kp = wilds9km_Tuple4.x2;
            var ds9kq = wilds9km_Tuple4.x3;
            var wilds9kr = etas9kl.Eval();
            var wilds9kr_Tuple4 = wilds9kr as GHC.Tuple.Tuple4;
            var a_s9ks = wilds9kr_Tuple4.x0;
            var b_s9kt = wilds9kr_Tuple4.x1;
            var c_s9ku = wilds9kr_Tuple4.x2;
            var d_s9kv = wilds9kr_Tuple4.x3;
            var sats9kz = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9kz_Entry), dMonoids9kj, ds9kq, d_s9kv);
            var sats9ky = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ky_Entry), dMonoids9ki, cs9kp, c_s9ku);
            var sats9kx = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9kx_Entry), dMonoids9kh, bs9ko, b_s9kt);
            var sats9kw = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9kw_Entry), dMonoids9kg, as9kn, a_s9ks);
            return new GHC.Tuple.Tuple4(sats9kw, sats9kx, sats9ky, sats9kz);
        }
        public static Closure sats9kw_Entry(Closure dMonoids9kg, Closure as9kn, Closure a_s9ks)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kg).Apply<Closure, Closure, Closure>(as9kn, a_s9ks);
        }
        public static Closure sats9kx_Entry(Closure dMonoids9kh, Closure bs9ko, Closure b_s9kt)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kh).Apply<Closure, Closure, Closure>(bs9ko, b_s9kt);
        }
        public static Closure sats9ky_Entry(Closure dMonoids9ki, Closure cs9kp, Closure c_s9ku)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9ki).Apply<Closure, Closure, Closure>(cs9kp, c_s9ku);
        }
        public static Closure sats9kz_Entry(Closure dMonoids9kj, Closure ds9kq, Closure d_s9kv)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9kj).Apply<Closure, Closure, Closure>(ds9kq, d_s9kv);
        }
        public static Closure cmemptys9k6_Entry(Closure dMonoids9k7, Closure dMonoids9k8, Closure dMonoids9k9, Closure dMonoids9ka)
        {
            var sats9ke = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9ke_Entry), dMonoids9ka);
            var sats9kd = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kd_Entry), dMonoids9k9);
            var sats9kc = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kc_Entry), dMonoids9k8);
            var sats9kb = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9kb_Entry), dMonoids9k7);
            return new GHC.Tuple.Tuple4(sats9kb, sats9kc, sats9kd, sats9ke);
        }
        public static Closure sats9kb_Entry(Closure dMonoids9k7)
        {
            return GHC.Base.mempty_Entry(dMonoids9k7);
        }
        public static Closure sats9kc_Entry(Closure dMonoids9k8)
        {
            return GHC.Base.mempty_Entry(dMonoids9k8);
        }
        public static Closure sats9kd_Entry(Closure dMonoids9k9)
        {
            return GHC.Base.mempty_Entry(dMonoids9k9);
        }
        public static Closure sats9ke_Entry(Closure dMonoids9ka)
        {
            return GHC.Base.mempty_Entry(dMonoids9ka);
        }
        public static Closure cp1Monoids9jP_Entry(Closure ws9jQ, Closure ws9jR, Closure ws9jS, Closure ws9jT, Closure ws9jU)
        {
            var wws9jV = ws9jT.Eval();
            var wws9jV_Tuple3 = wws9jV as GHC.Tuple.Tuple3;
            var wws9jW = wws9jV_Tuple3.x0;
            var wws9jX = wws9jV_Tuple3.x1;
            var wws9jY = wws9jV_Tuple3.x2;
            var wws9jZ = ws9jU.Eval();
            var wws9jZ_Tuple3 = wws9jZ as GHC.Tuple.Tuple3;
            var wws9k0 = wws9jZ_Tuple3.x0;
            var wws9k1 = wws9jZ_Tuple3.x1;
            var wws9k2 = wws9jZ_Tuple3.x2;
            var sats9k5 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9k5_Entry), ws9jS, wws9jY, wws9k2);
            var sats9k4 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9k4_Entry), ws9jR, wws9jX, wws9k1);
            var sats9k3 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9k3_Entry), ws9jQ, wws9jW, wws9k0);
            return new GHC.Tuple.Tuple3(sats9k3, sats9k4, sats9k5);
        }
        public static Closure sats9k3_Entry(Closure ws9jQ, Closure wws9jW, Closure wws9k0)
        {
            return GHC.Base.p1Monoid_Entry(ws9jQ).Apply<Closure, Closure, Closure>(wws9jW, wws9k0);
        }
        public static Closure sats9k4_Entry(Closure ws9jR, Closure wws9jX, Closure wws9k1)
        {
            return GHC.Base.p1Monoid_Entry(ws9jR).Apply<Closure, Closure, Closure>(wws9jX, wws9k1);
        }
        public static Closure sats9k5_Entry(Closure ws9jS, Closure wws9jY, Closure wws9k2)
        {
            return GHC.Base.p1Monoid_Entry(ws9jS).Apply<Closure, Closure, Closure>(wws9jY, wws9k2);
        }
        public static Closure cmemptys9jI_Entry(Closure dMonoids9jJ, Closure dMonoids9jK, Closure dMonoids9jL)
        {
            var sats9jO = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9jO_Entry), dMonoids9jL);
            var sats9jN = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9jN_Entry), dMonoids9jK);
            var sats9jM = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9jM_Entry), dMonoids9jJ);
            return new GHC.Tuple.Tuple3(sats9jM, sats9jN, sats9jO);
        }
        public static Closure sats9jM_Entry(Closure dMonoids9jJ)
        {
            return GHC.Base.mempty_Entry(dMonoids9jJ);
        }
        public static Closure sats9jN_Entry(Closure dMonoids9jK)
        {
            return GHC.Base.mempty_Entry(dMonoids9jK);
        }
        public static Closure sats9jO_Entry(Closure dMonoids9jL)
        {
            return GHC.Base.mempty_Entry(dMonoids9jL);
        }
        public static Closure cp1Monoids9jv_Entry(Closure dMonoids9jw, Closure dMonoids9jx, Closure etas9jy, Closure etas9jz)
        {
            var wilds9jA = etas9jy.Eval();
            var wilds9jA_Tuple2 = wilds9jA as GHC.Tuple.Tuple2;
            var as9jB = wilds9jA_Tuple2.x0;
            var bs9jC = wilds9jA_Tuple2.x1;
            var wilds9jD = etas9jz.Eval();
            var wilds9jD_Tuple2 = wilds9jD as GHC.Tuple.Tuple2;
            var a_s9jE = wilds9jD_Tuple2.x0;
            var b_s9jF = wilds9jD_Tuple2.x1;
            var sats9jH = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9jH_Entry), dMonoids9jx, bs9jC, b_s9jF);
            var sats9jG = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9jG_Entry), dMonoids9jw, as9jB, a_s9jE);
            return new GHC.Tuple.Tuple2(sats9jG, sats9jH);
        }
        public static Closure sats9jG_Entry(Closure dMonoids9jw, Closure as9jB, Closure a_s9jE)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9jw).Apply<Closure, Closure, Closure>(as9jB, a_s9jE);
        }
        public static Closure sats9jH_Entry(Closure dMonoids9jx, Closure bs9jC, Closure b_s9jF)
        {
            return GHC.Base.p1Monoid_Entry(dMonoids9jx).Apply<Closure, Closure, Closure>(bs9jC, b_s9jF);
        }
        public static Closure cmemptys9jq_Entry(Closure dMonoids9jr, Closure dMonoids9js)
        {
            var sats9ju = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9ju_Entry), dMonoids9js);
            var sats9jt = new Updatable<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9jt_Entry), dMonoids9jr);
            return new GHC.Tuple.Tuple2(sats9jt, sats9ju);
        }
        public static Closure sats9jt_Entry(Closure dMonoids9jr)
        {
            return GHC.Base.mempty_Entry(dMonoids9jr);
        }
        public static Closure sats9ju_Entry(Closure dMonoids9js)
        {
            return GHC.Base.mempty_Entry(dMonoids9js);
        }
        public static Closure cmconcats9jo_Entry(Closure dss9jp)
        {
            return GHC.Tuple.unit_DataCon.Eval();
        }
        public static Closure cp1Monoids9jh_Entry(Closure dMonoids9ji, Closure etas9jj, Closure etas9jk, Closure etas9jl)
        {
            var sats9jn = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9jn_Entry), etas9jk, etas9jl);
            var sats9jm = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9jm_Entry), etas9jj, etas9jl);
            return GHC.Base.p1Monoid_Entry(dMonoids9ji).Apply<Closure, Closure, Closure>(sats9jm, sats9jn);
        }
        public static Closure sats9jm_Entry(Closure etas9jj, Closure etas9jl)
        {
            return etas9jj.Apply<Closure, Closure>(etas9jl);
        }
        public static Closure sats9jn_Entry(Closure etas9jk, Closure etas9jl)
        {
            return etas9jk.Apply<Closure, Closure>(etas9jl);
        }
        public static Closure cmconcats9jf_Entry(Closure xsss9jg)
        {
            return poly_gos9j9_Entry(xsss9jg);
        }
        public static Closure poly_gos9j9_Entry(Closure dss9ja)
        {
            var wilds9jb = dss9ja.Eval();
            switch (wilds9jb)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9jb_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9jb_Cons:
                    {
                        var ys9jc = wilds9jb_Cons.x0;
                        var yss9jd = wilds9jb_Cons.x1;
                        var sats9je = new SingleEntry<Closure>(CLR.LoadFunctionPointer<Closure, Closure>(sats9je_Entry), yss9jd);
                        return plusPlus_Entry(ys9jc, sats9je);
                    }
            }
        }
        public static Closure sats9je_Entry(Closure yss9jd)
        {
            return poly_gos9j9_Entry(yss9jd);
        }
        public static Closure fSemigroupMaybe_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9iZ_Entry(Closure dSemigroups9j0, Closure dss9j1, Closure bs9j2)
        {
            var wilds9j3 = dss9j1.Eval();
            switch (wilds9j3)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9j3_Nothing: { return bs9j2.Eval(); }
                case GHC.Maybe.Just wilds9j3_Just:
                    {
                        var ipvs9j4 = wilds9j3_Just.x0;
                        var wilds9j5 = bs9j2.Eval();
                        switch (wilds9j5)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9j5_Nothing:
                                {
                                    return wilds9j3.Eval();
                                }
                            case GHC.Maybe.Just wilds9j5_Just:
                                {
                                    var ipvs9j6 = wilds9j5_Just.x0;
                                    var sats9j7 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9j7_Entry), dSemigroups9j0, ipvs9j4, ipvs9j6);
                                    return new GHC.Maybe.Just(sats9j7);
                                }
                        }
                    }
            }
        }
        public static Closure sats9j7_Entry(Closure dSemigroups9j0, Closure ipvs9j4, Closure ipvs9j6)
        {
            return dSemigroups9j0.Apply<Closure, Closure, Closure>(ipvs9j4, ipvs9j6);
        }
        public static Closure fSemigroupOrdering_Entry(Closure etaB2, Closure etaB1)
        {
            return cLtGts9iU_Entry(etaB2, etaB1);
        }
        public static Closure cLtGts9iU_Entry(Closure dss9iV, Closure dss9iW)
        {
            var wilds9iX = dss9iV.Eval();
            var wilds9iXTags9iX = wilds9iX.Tag;
            switch (wilds9iXTags9iX)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9iX_LT = wilds9iX as GHC.Types.LT;
                        return GHC.Types.lT_DataCon.Eval();
                    }
                case 2:
                    {
                        var wilds9iX_EQ = wilds9iX as GHC.Types.EQ; return dss9iW.Eval();
                    }
                case 3:
                    {
                        var wilds9iX_GT = wilds9iX as GHC.Types.GT;
                        return GHC.Types.gT_DataCon.Eval();
                    }
            }
        }
        public static Closure fSemigroupPrOComComComComPrC_Entry(Closure etaB7, Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iu_Entry(etaB7, etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9iu_Entry(Closure dSemigroups9iv, Closure dSemigroups9iw, Closure dSemigroups9ix, Closure dSemigroups9iy, Closure dSemigroups9iz, Closure dss9iA, Closure dss9iB)
        {
            var wilds9iC = dss9iA.Eval();
            var wilds9iC_Tuple5 = wilds9iC as GHC.Tuple.Tuple5;
            var as9iD = wilds9iC_Tuple5.x0;
            var bs9iE = wilds9iC_Tuple5.x1;
            var cs9iF = wilds9iC_Tuple5.x2;
            var ds9iG = wilds9iC_Tuple5.x3;
            var es9iH = wilds9iC_Tuple5.x4;
            var wilds9iI = dss9iB.Eval();
            var wilds9iI_Tuple5 = wilds9iI as GHC.Tuple.Tuple5;
            var a_s9iJ = wilds9iI_Tuple5.x0;
            var b_s9iK = wilds9iI_Tuple5.x1;
            var c_s9iL = wilds9iI_Tuple5.x2;
            var d_s9iM = wilds9iI_Tuple5.x3;
            var e_s9iN = wilds9iI_Tuple5.x4;
            var sats9iS = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iS_Entry), dSemigroups9iz, es9iH, e_s9iN);
            var sats9iR = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iR_Entry), dSemigroups9iy, ds9iG, d_s9iM);
            var sats9iQ = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iQ_Entry), dSemigroups9ix, cs9iF, c_s9iL);
            var sats9iP = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iP_Entry), dSemigroups9iw, bs9iE, b_s9iK);
            var sats9iO = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iO_Entry), dSemigroups9iv, as9iD, a_s9iJ);
            return new GHC.Tuple.Tuple5(sats9iO, sats9iP, sats9iQ, sats9iR, sats9iS);
        }
        public static Closure sats9iO_Entry(Closure dSemigroups9iv, Closure as9iD, Closure a_s9iJ)
        {
            return dSemigroups9iv.Apply<Closure, Closure, Closure>(as9iD, a_s9iJ);
        }
        public static Closure sats9iP_Entry(Closure dSemigroups9iw, Closure bs9iE, Closure b_s9iK)
        {
            return dSemigroups9iw.Apply<Closure, Closure, Closure>(bs9iE, b_s9iK);
        }
        public static Closure sats9iQ_Entry(Closure dSemigroups9ix, Closure cs9iF, Closure c_s9iL)
        {
            return dSemigroups9ix.Apply<Closure, Closure, Closure>(cs9iF, c_s9iL);
        }
        public static Closure sats9iR_Entry(Closure dSemigroups9iy, Closure ds9iG, Closure d_s9iM)
        {
            return dSemigroups9iy.Apply<Closure, Closure, Closure>(ds9iG, d_s9iM);
        }
        public static Closure sats9iS_Entry(Closure dSemigroups9iz, Closure es9iH, Closure e_s9iN)
        {
            return dSemigroups9iz.Apply<Closure, Closure, Closure>(es9iH, e_s9iN);
        }
        public static Closure fSemigroupPrOComComComPrC_Entry(Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9i8_Entry(etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9i8_Entry(Closure dSemigroups9i9, Closure dSemigroups9ia, Closure dSemigroups9ib, Closure dSemigroups9ic, Closure dss9id, Closure dss9ie)
        {
            var wilds9if = dss9id.Eval();
            var wilds9if_Tuple4 = wilds9if as GHC.Tuple.Tuple4;
            var as9ig = wilds9if_Tuple4.x0;
            var bs9ih = wilds9if_Tuple4.x1;
            var cs9ii = wilds9if_Tuple4.x2;
            var ds9ij = wilds9if_Tuple4.x3;
            var wilds9ik = dss9ie.Eval();
            var wilds9ik_Tuple4 = wilds9ik as GHC.Tuple.Tuple4;
            var a_s9il = wilds9ik_Tuple4.x0;
            var b_s9im = wilds9ik_Tuple4.x1;
            var c_s9in = wilds9ik_Tuple4.x2;
            var d_s9io = wilds9ik_Tuple4.x3;
            var sats9is = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9is_Entry), dSemigroups9ic, ds9ij, d_s9io);
            var sats9ir = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ir_Entry), dSemigroups9ib, cs9ii, c_s9in);
            var sats9iq = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9iq_Entry), dSemigroups9ia, bs9ih, b_s9im);
            var sats9ip = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9ip_Entry), dSemigroups9i9, as9ig, a_s9il);
            return new GHC.Tuple.Tuple4(sats9ip, sats9iq, sats9ir, sats9is);
        }
        public static Closure sats9ip_Entry(Closure dSemigroups9i9, Closure as9ig, Closure a_s9il)
        {
            return dSemigroups9i9.Apply<Closure, Closure, Closure>(as9ig, a_s9il);
        }
        public static Closure sats9iq_Entry(Closure dSemigroups9ia, Closure bs9ih, Closure b_s9im)
        {
            return dSemigroups9ia.Apply<Closure, Closure, Closure>(bs9ih, b_s9im);
        }
        public static Closure sats9ir_Entry(Closure dSemigroups9ib, Closure cs9ii, Closure c_s9in)
        {
            return dSemigroups9ib.Apply<Closure, Closure, Closure>(cs9ii, c_s9in);
        }
        public static Closure sats9is_Entry(Closure dSemigroups9ic, Closure ds9ij, Closure d_s9io)
        {
            return dSemigroups9ic.Apply<Closure, Closure, Closure>(ds9ij, d_s9io);
        }
        public static Closure fSemigroupPrOComComPrC_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hQ_Entry(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hQ_Entry(Closure dSemigroups9hR, Closure dSemigroups9hS, Closure dSemigroups9hT, Closure dss9hU, Closure dss9hV)
        {
            var wilds9hW = dss9hU.Eval();
            var wilds9hW_Tuple3 = wilds9hW as GHC.Tuple.Tuple3;
            var as9hX = wilds9hW_Tuple3.x0;
            var bs9hY = wilds9hW_Tuple3.x1;
            var cs9hZ = wilds9hW_Tuple3.x2;
            var wilds9i0 = dss9hV.Eval();
            var wilds9i0_Tuple3 = wilds9i0 as GHC.Tuple.Tuple3;
            var a_s9i1 = wilds9i0_Tuple3.x0;
            var b_s9i2 = wilds9i0_Tuple3.x1;
            var c_s9i3 = wilds9i0_Tuple3.x2;
            var sats9i6 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9i6_Entry), dSemigroups9hT, cs9hZ, c_s9i3);
            var sats9i5 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9i5_Entry), dSemigroups9hS, bs9hY, b_s9i2);
            var sats9i4 = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9i4_Entry), dSemigroups9hR, as9hX, a_s9i1);
            return new GHC.Tuple.Tuple3(sats9i4, sats9i5, sats9i6);
        }
        public static Closure sats9i4_Entry(Closure dSemigroups9hR, Closure as9hX, Closure a_s9i1)
        {
            return dSemigroups9hR.Apply<Closure, Closure, Closure>(as9hX, a_s9i1);
        }
        public static Closure sats9i5_Entry(Closure dSemigroups9hS, Closure bs9hY, Closure b_s9i2)
        {
            return dSemigroups9hS.Apply<Closure, Closure, Closure>(bs9hY, b_s9i2);
        }
        public static Closure sats9i6_Entry(Closure dSemigroups9hT, Closure cs9hZ, Closure c_s9i3)
        {
            return dSemigroups9hT.Apply<Closure, Closure, Closure>(cs9hZ, c_s9i3);
        }
        public static Closure fSemigroupPrOComPrC_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hC_Entry(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hC_Entry(Closure dSemigroups9hD, Closure dSemigroups9hE, Closure dss9hF, Closure dss9hG)
        {
            var wilds9hH = dss9hF.Eval();
            var wilds9hH_Tuple2 = wilds9hH as GHC.Tuple.Tuple2;
            var as9hI = wilds9hH_Tuple2.x0;
            var bs9hJ = wilds9hH_Tuple2.x1;
            var wilds9hK = dss9hG.Eval();
            var wilds9hK_Tuple2 = wilds9hK as GHC.Tuple.Tuple2;
            var a_s9hL = wilds9hK_Tuple2.x0;
            var b_s9hM = wilds9hK_Tuple2.x1;
            var sats9hO = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9hO_Entry), dSemigroups9hE, bs9hJ, b_s9hM);
            var sats9hN = new Updatable<Closure, Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure, Closure>(sats9hN_Entry), dSemigroups9hD, as9hI, a_s9hL);
            return new GHC.Tuple.Tuple2(sats9hN, sats9hO);
        }
        public static Closure sats9hN_Entry(Closure dSemigroups9hD, Closure as9hI, Closure a_s9hL)
        {
            return dSemigroups9hD.Apply<Closure, Closure, Closure>(as9hI, a_s9hL);
        }
        public static Closure sats9hO_Entry(Closure dSemigroups9hE, Closure bs9hJ, Closure b_s9hM)
        {
            return dSemigroups9hE.Apply<Closure, Closure, Closure>(bs9hJ, b_s9hM);
        }
        public static Closure fSemigroupPrOPrC_Entry(Closure etaB2, Closure etaB1)
        {
            return cLtGts9hy_Entry(etaB2, etaB1);
        }
        public static Closure cLtGts9hy_Entry(Closure dss9hz, Closure dss9hA)
        {
            return GHC.Tuple.unit_DataCon.Eval();
        }
        public static Closure fSemigroupDashGt_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hq_Entry(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hq_Entry(Closure dSemigroups9hr, Closure fs9hs, Closure gs9ht, Closure xs9hu)
        {
            var sats9hw = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9hw_Entry), gs9ht, xs9hu);
            var sats9hv = new Updatable<Closure, Closure>(CLR.LoadFunctionPointer<Closure, Closure, Closure>(sats9hv_Entry), fs9hs, xs9hu);
            return dSemigroups9hr.Apply<Closure, Closure, Closure>(sats9hv, sats9hw);
        }
        public static Closure sats9hv_Entry(Closure fs9hs, Closure xs9hu)
        {
            return fs9hs.Apply<Closure, Closure>(xs9hu);
        }
        public static Closure sats9hw_Entry(Closure gs9ht, Closure xs9hu)
        {
            return gs9ht.Apply<Closure, Closure>(xs9hu);
        }
        public static Closure ltGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColSemigroup;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure p1Monoid_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure mempty_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure mappend_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure mconcat_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure fmap_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColFunctor;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure ltDoll_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColFunctor;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure p1Applicative_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure pure_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure ltAstrGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure liftA2_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure astrGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure ltAstr_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x5; return dictItem.Eval();
        }
        public static Closure p1Alternative_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure empty_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure ltPipeGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure some_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure many_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure p1Monad_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure gtGtEq_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure gtGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure @return_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure fail_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure p1MonadPlus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure p2MonadPlus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure mzero_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure mplus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public sealed class CColMonoid : Data
        {
            public Closure x0;
            public Closure x1; public Closure x2; public Closure x3;
            public CColMonoid(Closure x0, Closure x1, Closure x2, Closure x3)
            {
                this.x0 = x0; this.x1 = x1; this.x2 = x2; this.x3 = x3;
            }
            public override int Tag => 1;
        }
        public sealed class CColFunctor : Data
        {
            public Closure x0; public Closure x1;
            public CColFunctor(Closure x0, Closure x1)
            {
                this.x0 = x0; this.x1 = x1;
            }
            public override int Tag => 1;
        }
        public sealed class CColApplicative : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2;
            public Closure x3; public Closure x4; public Closure x5;
            public CColApplicative(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5)
            {
                this.x0 = x0;
                this.x1 = x1;
                this.x2 = x2; this.x3 = x3; this.x4 = x4; this.x5 = x5;
            }
            public override int Tag => 1;
        }
        public sealed class CColAlternative : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2; public Closure x3; public Closure x4;
            public CColAlternative(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)
            {
                this.x0 = x0;
                this.x1 = x1; this.x2 = x2; this.x3 = x3; this.x4 = x4;
            }
            public override int Tag => 1;
        }
        public sealed class CColMonad : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2; public Closure x3; public Closure x4;
            public CColMonad(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)
            {
                this.x0 = x0;
                this.x1 = x1; this.x2 = x2; this.x3 = x3; this.x4 = x4;
            }
            public override int Tag => 1;
        }
        public sealed class CColMonadPlus : Data
        {
            public Closure x0;
            public Closure x1; public Closure x2; public Closure x3;
            public CColMonadPlus(Closure x0, Closure x1, Closure x2, Closure x3)
            {
                this.x0 = x0; this.x1 = x1; this.x2 = x2; this.x3 = x3;
            }
            public override int Tag => 1;
        }
        public sealed class CColSemigroup : Data
        {
            public Closure x0;
            public CColSemigroup(Closure x0) { this.x0 = x0; }
            public override int Tag => 1;
        }
    }
}
