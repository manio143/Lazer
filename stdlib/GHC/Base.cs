using Lazer.Runtime;

namespace GHC
{
    public unsafe static class Base
    {
        public static Function cColMonoid_DataCon;

        public static Function cColFunctor_DataCon;

        public static Function cColApplicative_DataCon;

        public static Function cColAlternative_DataCon;

        public static Function cColMonad_DataCon;

        public static Function cColMonadPlus_DataCon;

        public static Function cColSemigroup_DataCon;

        public static Function eqString;

        internal static Function cmanys9BH;

        internal static Function csomes9Bx;

        public static Function liftM;

        internal static Function sliftMs9Bp;

        public static Function liftM2;

        internal static Function sliftM2s9Be;

        public static Function liftM3;

        internal static Function sliftM3s9AP;

        public static Function liftM4;

        internal static Function sliftM4s9Ak;

        public static Function liftM5;

        internal static Function sliftM5s9zJ;

        public static Function ap;

        internal static Function saps9zs;

        public static Function when;

        internal static Function swhens9zi;

        public static Function liftA;

        internal static Function sliftAs9zb;

        public static Function liftA3;

        internal static Function sliftA3s9yS;

        internal static Function cLtAstrs9yK;

        public static Function modInt;

        public static Function divInt;

        public static Function quotRemInt;

        public static Function remInt;

        public static Function quotInt;

        public static Function getTag;

        public static Function flip;

        internal static Function lvls9x0;

        internal static Function cGtGts9wZ;

        internal static Function cLtAstrs9wU;

        internal static Function cAstrGts9wQ;

        internal static Function cLtDolls9wL;

        public static Function fMonadPrOComPrC;

        internal static Function lvls9wB;

        internal static Function cGtGts9wA;

        public static Function fApplicativePrOComPrC;

        internal static Function cLtAstrs9wg;

        internal static Function cAstrGts9w5;

        internal static Function cLtDolls9vY;

        internal static Function cLtAstrGts9vT;

        internal static Function cLtDolls9vN;

        internal static Function cmanys9vu;

        internal static Function csomes9vd;

        internal static Function poly_gos9v7;

        public static Function eqLtLt;

        internal static Function sEqLtLts9uZ;

        internal static Function cLtAstrs9uW;

        internal static Function cLtDolls9uQ;

        public static Function dmLtDoll;

        public static Function fMonoidDashGt;

        internal static Function cmconcats9uq;

        public static Function fMonoidPrOComPrC;

        internal static Function cmconcats9tZ;

        public static Function fMonoidPrOComComPrC;

        internal static Function cmconcats9ts;

        public static Function fMonoidPrOComComComPrC;

        internal static Function cmconcats9t2;

        public static Function fMonoidPrOComComComComPrC;

        internal static Function cmconcats9sz;

        internal static Function gos9ss;

        public static Function fMonoidMaybe;

        internal static Function cmconcats9sa;

        public static Function dmmconcat;

        public static Function sequence;

        public static Function mapM;

        public static Function fSemigroupBrOBrC;

        public static Function plusPlus;

        public static Function map;

        public static Function foldr;

        public static Function mapFB;

        public static Function dot;

        public static Function dmLtAstr;

        public static Function asTypeOf;

        public static Function @const;

        public static Function breakpointCond;

        public static Function breakpoint;

        public static Function assert;

        public static Function dmAstrGt;

        public static Function dmLtAstrGt;

        public static Function join;

        public static Function id;

        public static Function ord;

        public static Function unsafeChr;

        public static Function iShiftRLHash;

        public static Function iShiftRAHash;

        public static Function iShiftLHash;

        public static Function shiftRLHash;

        public static Function shiftLHash;

        public static Function divModInt;

        public static Function divModIntHash;

        public static Function until;

        public static Function augment;

        public static Function build;

        public static Function ltAstrAstrGt;

        internal static Function lvls9on;

        public static Function ifThenElse;

        public static Function dmmappend;

        public static Function dmliftA2;

        public static Function dmsome;

        public static Function dmmany;

        public static Function dmGtGt;

        public static Function dmreturn;

        public static Function dmfail;

        public static Function dmmzero;

        public static Function dmmplus;

        internal static Function cGtGtEqs9no;

        internal static Function cfails9nm;

        internal static Function cGtGtEqs9nh;

        internal static Function cfails9nf;

        internal static Function cGtGtEqs9na;

        internal static Function cGtGtEqs9mZ;

        internal static Function cLtPipeGts9mU;

        internal static Function cpures9mS;

        internal static Function cLtAstrGts9mC;

        internal static Function cliftA2s9ml;

        internal static Function cAstrGts9mc;

        internal static Function cliftA2s9m3;

        internal static Function cAstrGts9lY;

        internal static Function cLtAstrGts9lT;

        internal static Function cliftA2s9lM;

        internal static Function cLtAstrGts9lA;

        internal static Function cliftA2s9ln;

        internal static Function cfmaps9lh;

        internal static Function cfmaps9la;

        internal static Function cp1Monoids9kL;

        internal static Function cmemptys9kA;

        internal static Function cp1Monoids9kf;

        internal static Function cmemptys9k6;

        internal static Function cp1Monoids9jP;

        internal static Function cmemptys9jI;

        internal static Function cp1Monoids9jv;

        internal static Function cmemptys9jq;

        internal static Function cmconcats9jo;

        internal static Function cp1Monoids9jh;

        internal static Function cmconcats9jf;

        internal static Function poly_gos9j9;

        public static Function fSemigroupMaybe;

        internal static Function cLtGts9iZ;

        public static Function fSemigroupOrdering;

        internal static Function cLtGts9iU;

        public static Function fSemigroupPrOComComComComPrC;

        internal static Function cLtGts9iu;

        public static Function fSemigroupPrOComComComPrC;

        internal static Function cLtGts9i8;

        public static Function fSemigroupPrOComComPrC;

        internal static Function cLtGts9hQ;

        public static Function fSemigroupPrOComPrC;

        internal static Function cLtGts9hC;

        public static Function fSemigroupPrOPrC;

        internal static Function cLtGts9hy;

        public static Function fSemigroupDashGt;

        internal static Function cLtGts9hq;

        public static GHC.Base.CColMonoid fMonoidPrOPrC;
        public static GHC.Types.True otherwise;
        public static GHC.Types.IHash minInt;
        public static GHC.Types.IHash maxInt;
        public static GHC.Base.CColMonoid fMonoidBrOBrC;
        public static GHC.Base.CColMonoid fMonoidOrdering;
        public static GHC.Base.CColFunctor fFunctorBrOBrC;
        public static GHC.Base.CColApplicative fApplicativeBrOBrC;
        public static GHC.Base.CColMonad fMonadBrOBrC;
        internal static GHC.Types.Cons lvls9v6;
        public static GHC.Base.CColAlternative fAlternativeBrOBrC;
        public static GHC.Base.CColMonadPlus fMonadPlusBrOBrC;
        public static GHC.Base.CColFunctor fFunctorMaybe;
        public static GHC.Base.CColFunctor fFunctorPrOComPrC;
        public static GHC.Base.CColFunctor fFunctorDashGt;
        public static GHC.Base.CColApplicative fApplicativeDashGt;
        public static GHC.Base.CColMonad fMonadDashGt;
        public static GHC.Base.CColApplicative fApplicativeMaybe;
        internal static GHC.Maybe.Just lvls9zh;
        public static GHC.Base.CColMonad fMonadMaybe;
        internal static GHC.Maybe.Just lvls9BG;
        public static GHC.Base.CColAlternative fAlternativeMaybe;
        public static GHC.Base.CColMonadPlus fMonadPlusMaybe;

        public static Function ltGt;

        public static Function p1Monoid;

        public static Function mempty;

        public static Function mappend;

        public static Function mconcat;

        public static Function fmap;

        public static Function ltDoll;

        public static Function p1Applicative;

        public static Function pure;

        public static Function ltAstrGt;

        public static Function liftA2;

        public static Function astrGt;

        public static Function ltAstr;

        public static Function p1Alternative;

        public static Function empty;

        public static Function ltPipeGt;

        public static Function some;

        public static Function many;

        public static Function p1Monad;

        public static Function gtGtEq;

        public static Function gtGt;

        public static Function @return;

        public static Function fail;

        public static Function p1MonadPlus;

        public static Function p2MonadPlus;

        public static Function mzero;

        public static Function mplus;

        static Base()
        {
            cColMonoid_DataCon = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cColMonoid_DataCon_Entry);

            cColFunctor_DataCon = new Fun2<Closure, Closure, Closure>(&cColFunctor_DataCon_Entry);

            cColApplicative_DataCon = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cColApplicative_DataCon_Entry);

            cColAlternative_DataCon = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cColAlternative_DataCon_Entry);

            cColMonad_DataCon = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cColMonad_DataCon_Entry);

            cColMonadPlus_DataCon = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cColMonadPlus_DataCon_Entry);

            cColSemigroup_DataCon = new Fun1<Closure, Closure>(&cColSemigroup_DataCon_Entry);

            eqString = new Fun2<Closure, Closure, Closure>(&eqString_Entry);

            cmanys9BH = new Fun1<Closure, Closure>(&cmanys9BH_Entry);

            csomes9Bx = new Fun1<Closure, Closure>(&csomes9Bx_Entry);

            liftM = new Fun3<Closure, Closure, Closure, Closure>(&liftM_Entry);

            sliftMs9Bp = new Fun2<Closure, Closure, Closure>(&sliftMs9Bp_Entry);

            liftM2 = new Fun4<Closure, Closure, Closure, Closure, Closure>(&liftM2_Entry);

            sliftM2s9Be = new Fun3<Closure, Closure, Closure, Closure>(&sliftM2s9Be_Entry);

            liftM3 = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&liftM3_Entry);

            sliftM3s9AP = new Fun4<Closure, Closure, Closure, Closure, Closure>(&sliftM3s9AP_Entry);

            liftM4 = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&liftM4_Entry);

            sliftM4s9Ak = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&sliftM4s9Ak_Entry);

            liftM5 = new Fun7<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&liftM5_Entry);

            sliftM5s9zJ = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&sliftM5s9zJ_Entry);

            ap = new Fun3<Closure, Closure, Closure, Closure>(&ap_Entry);

            saps9zs = new Fun2<Closure, Closure, Closure>(&saps9zs_Entry);

            when = new Fun3<Closure, Closure, Closure, Closure>(&when_Entry);

            swhens9zi = new Fun2<Closure, Closure, Closure>(&swhens9zi_Entry);

            liftA = new Fun3<Closure, Closure, Closure, Closure>(&liftA_Entry);

            sliftAs9zb = new Fun2<Closure, Closure, Closure>(&sliftAs9zb_Entry);

            liftA3 = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&liftA3_Entry);

            sliftA3s9yS = new Fun4<Closure, Closure, Closure, Closure, Closure>(&sliftA3s9yS_Entry);

            cLtAstrs9yK = new Fun2<Closure, Closure, Closure>(&cLtAstrs9yK_Entry);

            modInt = new Fun2<Closure, Closure, Closure>(&modInt_Entry);

            divInt = new Fun2<Closure, Closure, Closure>(&divInt_Entry);

            quotRemInt = new Fun2<Closure, Closure, Closure>(&quotRemInt_Entry);

            remInt = new Fun2<Closure, Closure, Closure>(&remInt_Entry);

            quotInt = new Fun2<Closure, Closure, Closure>(&quotInt_Entry);

            getTag = new Fun1<Closure, long>(&getTag_Entry);
            flip = new Fun3<Closure, Closure, Closure, Closure>(&flip_Entry);

            lvls9x0 = new Fun1<Closure, Closure>(&lvls9x0_Entry);
            cGtGts9wZ = new Fun3<Closure, Closure, Closure, Closure>(&cGtGts9wZ_Entry);

            cLtAstrs9wU = new Fun3<Closure, Closure, Closure, Closure>(&cLtAstrs9wU_Entry);

            cAstrGts9wQ = new Fun3<Closure, Closure, Closure, Closure>(&cAstrGts9wQ_Entry);

            cLtDolls9wL = new Fun3<Closure, Closure, Closure, Closure>(&cLtDolls9wL_Entry);

            fMonadPrOComPrC = new Fun1<Closure, Closure>(&fMonadPrOComPrC_Entry);

            lvls9wB = new Fun1<Closure, Closure>(&lvls9wB_Entry);
            cGtGts9wA = new Fun3<Closure, Closure, Closure, Closure>(&cGtGts9wA_Entry);

            fApplicativePrOComPrC = new Fun1<Closure, Closure>(&fApplicativePrOComPrC_Entry);

            cLtAstrs9wg = new Fun3<Closure, Closure, Closure, Closure>(&cLtAstrs9wg_Entry);

            cAstrGts9w5 = new Fun3<Closure, Closure, Closure, Closure>(&cAstrGts9w5_Entry);

            cLtDolls9vY = new Fun2<Closure, Closure, Closure>(&cLtDolls9vY_Entry);

            cLtAstrGts9vT = new Fun2<Closure, Closure, Closure>(&cLtAstrGts9vT_Entry);

            cLtDolls9vN = new Fun2<Closure, Closure, Closure>(&cLtDolls9vN_Entry);

            cmanys9vu = new Fun1<Closure, Closure>(&cmanys9vu_Entry);

            csomes9vd = new Fun1<Closure, Closure>(&csomes9vd_Entry);

            poly_gos9v7 = new Fun1<Closure, Closure>(&poly_gos9v7_Entry);

            eqLtLt = new Fun3<Closure, Closure, Closure, Closure>(&eqLtLt_Entry);

            sEqLtLts9uZ = new Fun2<Closure, Closure, Closure>(&sEqLtLts9uZ_Entry);

            cLtAstrs9uW = new Fun2<Closure, Closure, Closure>(&cLtAstrs9uW_Entry);

            cLtDolls9uQ = new Fun2<Closure, Closure, Closure>(&cLtDolls9uQ_Entry);

            dmLtDoll = new Fun2<Closure, Closure, Closure>(&dmLtDoll_Entry);

            fMonoidDashGt = new Fun1<Closure, Closure>(&fMonoidDashGt_Entry);

            cmconcats9uq = new Fun3<Closure, Closure, Closure, Closure>(&cmconcats9uq_Entry);

            fMonoidPrOComPrC = new Fun2<Closure, Closure, Closure>(&fMonoidPrOComPrC_Entry);

            cmconcats9tZ = new Fun3<Closure, Closure, Closure, Closure>(&cmconcats9tZ_Entry);

            fMonoidPrOComComPrC = new Fun3<Closure, Closure, Closure, Closure>(&fMonoidPrOComComPrC_Entry);

            cmconcats9ts = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cmconcats9ts_Entry);

            fMonoidPrOComComComPrC = new Fun4<Closure, Closure, Closure, Closure, Closure>(&fMonoidPrOComComComPrC_Entry);

            cmconcats9t2 = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cmconcats9t2_Entry);

            fMonoidPrOComComComComPrC = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&fMonoidPrOComComComComPrC_Entry);

            cmconcats9sz = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cmconcats9sz_Entry);

            gos9ss = new Fun1<Closure, Closure>(&gos9ss_Entry);
            fMonoidMaybe = new Fun1<Closure, Closure>(&fMonoidMaybe_Entry);

            cmconcats9sa = new Fun2<Closure, Closure, Closure>(&cmconcats9sa_Entry);

            dmmconcat = new Fun2<Closure, Closure, Closure>(&dmmconcat_Entry);

            sequence = new Fun2<Closure, Closure, Closure>(&sequence_Entry);

            mapM = new Fun3<Closure, Closure, Closure, Closure>(&mapM_Entry);

            fSemigroupBrOBrC = new Fun2<Closure, Closure, Closure>(&fSemigroupBrOBrC_Entry);

            plusPlus = new Fun2<Closure, Closure, Closure>(&plusPlus_Entry);

            map = new Fun2<Closure, Closure, Closure>(&map_Entry);
            foldr = new Fun3<Closure, Closure, Closure, Closure>(&foldr_Entry);

            mapFB = new Fun4<Closure, Closure, Closure, Closure, Closure>(&mapFB_Entry);

            dot = new Fun3<Closure, Closure, Closure, Closure>(&dot_Entry);

            dmLtAstr = new Fun1<Closure, Closure>(&dmLtAstr_Entry);
            asTypeOf = new Fun2<Closure, Closure, Closure>(&asTypeOf_Entry);

            @const = new Fun2<Closure, Closure, Closure>(&@const_Entry);

            breakpointCond = new Fun2<Closure, Closure, Closure>(&breakpointCond_Entry);

            breakpoint = new Fun1<Closure, Closure>(&breakpoint_Entry);

            assert = new Fun2<Closure, Closure, Closure>(&assert_Entry);

            dmAstrGt = new Fun3<Closure, Closure, Closure, Closure>(&dmAstrGt_Entry);

            dmLtAstrGt = new Fun1<Closure, Closure>(&dmLtAstrGt_Entry);

            join = new Fun2<Closure, Closure, Closure>(&join_Entry);

            id = new Fun1<Closure, Closure>(&id_Entry);
            ord = new Fun1<Closure, Closure>(&ord_Entry);
            unsafeChr = new Fun1<Closure, Closure>(&unsafeChr_Entry);

            iShiftRLHash = new Fun2<long, long, long>(&iShiftRLHash_Entry);

            iShiftRAHash = new Fun2<long, long, long>(&iShiftRAHash_Entry);

            iShiftLHash = new Fun2<long, long, long>(&iShiftLHash_Entry);

            shiftRLHash = new Fun2<ulong, long, ulong>(&shiftRLHash_Entry);

            shiftLHash = new Fun2<ulong, long, ulong>(&shiftLHash_Entry);

            divModInt = new Fun2<Closure, Closure, Closure>(&divModInt_Entry);

            divModIntHash = new Fun2<long, long, (long x0, long x1)>(&divModIntHash_Entry);

            until = new Fun3<Closure, Closure, Closure, Closure>(&until_Entry);

            augment = new Fun2<Closure, Closure, Closure>(&augment_Entry);

            build = new Fun1<Closure, Closure>(&build_Entry);
            ltAstrAstrGt = new Fun1<Closure, Closure>(&ltAstrAstrGt_Entry);

            lvls9on = new Fun2<Closure, Closure, Closure>(&lvls9on_Entry);

            ifThenElse = new Fun3<Closure, Closure, Closure, Closure>(&ifThenElse_Entry);

            dmmappend = new Fun1<Closure, Closure>(&dmmappend_Entry);

            dmliftA2 = new Fun3<Closure, Closure, Closure, Closure>(&dmliftA2_Entry);

            dmsome = new Fun2<Closure, Closure, Closure>(&dmsome_Entry);

            dmmany = new Fun2<Closure, Closure, Closure>(&dmmany_Entry);

            dmGtGt = new Fun3<Closure, Closure, Closure, Closure>(&dmGtGt_Entry);

            dmreturn = new Fun1<Closure, Closure>(&dmreturn_Entry);
            dmfail = new Fun2<Closure, Closure, Closure>(&dmfail_Entry);

            dmmzero = new Fun1<Closure, Closure>(&dmmzero_Entry);
            dmmplus = new Fun1<Closure, Closure>(&dmmplus_Entry);
            cGtGtEqs9no = new Fun2<Closure, Closure, Closure>(&cGtGtEqs9no_Entry);

            cfails9nm = new Fun1<Closure, Closure>(&cfails9nm_Entry);

            cGtGtEqs9nh = new Fun2<Closure, Closure, Closure>(&cGtGtEqs9nh_Entry);

            cfails9nf = new Fun1<Closure, Closure>(&cfails9nf_Entry);

            cGtGtEqs9na = new Fun3<Closure, Closure, Closure, Closure>(&cGtGtEqs9na_Entry);

            cGtGtEqs9mZ = new Fun3<Closure, Closure, Closure, Closure>(&cGtGtEqs9mZ_Entry);

            cLtPipeGts9mU = new Fun2<Closure, Closure, Closure>(&cLtPipeGts9mU_Entry);

            cpures9mS = new Fun1<Closure, Closure>(&cpures9mS_Entry);

            cLtAstrGts9mC = new Fun2<Closure, Closure, Closure>(&cLtAstrGts9mC_Entry);

            cliftA2s9ml = new Fun3<Closure, Closure, Closure, Closure>(&cliftA2s9ml_Entry);

            cAstrGts9mc = new Fun2<Closure, Closure, Closure>(&cAstrGts9mc_Entry);

            cliftA2s9m3 = new Fun3<Closure, Closure, Closure, Closure>(&cliftA2s9m3_Entry);

            cAstrGts9lY = new Fun2<Closure, Closure, Closure>(&cAstrGts9lY_Entry);

            cLtAstrGts9lT = new Fun3<Closure, Closure, Closure, Closure>(&cLtAstrGts9lT_Entry);

            cliftA2s9lM = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cliftA2s9lM_Entry);

            cLtAstrGts9lA = new Fun3<Closure, Closure, Closure, Closure>(&cLtAstrGts9lA_Entry);

            cliftA2s9ln = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cliftA2s9ln_Entry);

            cfmaps9lh = new Fun2<Closure, Closure, Closure>(&cfmaps9lh_Entry);

            cfmaps9la = new Fun2<Closure, Closure, Closure>(&cfmaps9la_Entry);

            cp1Monoids9kL = new Fun7<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cp1Monoids9kL_Entry);

            cmemptys9kA = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cmemptys9kA_Entry);

            cp1Monoids9kf = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cp1Monoids9kf_Entry);

            cmemptys9k6 = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cmemptys9k6_Entry);

            cp1Monoids9jP = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cp1Monoids9jP_Entry);

            cmemptys9jI = new Fun3<Closure, Closure, Closure, Closure>(&cmemptys9jI_Entry);

            cp1Monoids9jv = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cp1Monoids9jv_Entry);

            cmemptys9jq = new Fun2<Closure, Closure, Closure>(&cmemptys9jq_Entry);

            cmconcats9jo = new Fun1<Closure, Closure>(&cmconcats9jo_Entry);

            cp1Monoids9jh = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cp1Monoids9jh_Entry);

            cmconcats9jf = new Fun1<Closure, Closure>(&cmconcats9jf_Entry);

            poly_gos9j9 = new Fun1<Closure, Closure>(&poly_gos9j9_Entry);

            fSemigroupMaybe = new Fun3<Closure, Closure, Closure, Closure>(&fSemigroupMaybe_Entry);

            cLtGts9iZ = new Fun3<Closure, Closure, Closure, Closure>(&cLtGts9iZ_Entry);

            fSemigroupOrdering = new Fun2<Closure, Closure, Closure>(&fSemigroupOrdering_Entry);

            cLtGts9iU = new Fun2<Closure, Closure, Closure>(&cLtGts9iU_Entry);

            fSemigroupPrOComComComComPrC = new Fun7<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&fSemigroupPrOComComComComPrC_Entry);

            cLtGts9iu = new Fun7<Closure, Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cLtGts9iu_Entry);

            fSemigroupPrOComComComPrC = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&fSemigroupPrOComComComPrC_Entry);

            cLtGts9i8 = new Fun6<Closure, Closure, Closure, Closure, Closure, Closure, Closure>(&cLtGts9i8_Entry);

            fSemigroupPrOComComPrC = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&fSemigroupPrOComComPrC_Entry);

            cLtGts9hQ = new Fun5<Closure, Closure, Closure, Closure, Closure, Closure>(&cLtGts9hQ_Entry);

            fSemigroupPrOComPrC = new Fun4<Closure, Closure, Closure, Closure, Closure>(&fSemigroupPrOComPrC_Entry);

            cLtGts9hC = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cLtGts9hC_Entry);

            fSemigroupPrOPrC = new Fun2<Closure, Closure, Closure>(&fSemigroupPrOPrC_Entry);

            cLtGts9hy = new Fun2<Closure, Closure, Closure>(&cLtGts9hy_Entry);

            fSemigroupDashGt = new Fun4<Closure, Closure, Closure, Closure, Closure>(&fSemigroupDashGt_Entry);

            cLtGts9hq = new Fun4<Closure, Closure, Closure, Closure, Closure>(&cLtGts9hq_Entry);

            fMonadPlusMaybe = new GHC.Base.CColMonadPlus((Closure)null, (Closure)null, GHC.Maybe.nothing_DataCon, cLtPipeGts9mU);
            fAlternativeMaybe = new GHC.Base.CColAlternative((Closure)null, GHC.Maybe.nothing_DataCon, cLtPipeGts9mU, csomes9Bx, cmanys9BH);
            lvls9BG = new GHC.Maybe.Just(GHC.Types.nil_DataCon);
            fMonadMaybe = new GHC.Base.CColMonad((Closure)null, cGtGtEqs9nh, cAstrGts9lY, GHC.Maybe.just_DataCon, cfails9nf);
            lvls9zh = new GHC.Maybe.Just(GHC.Tuple.unit_DataCon);
            fApplicativeMaybe = new GHC.Base.CColApplicative((Closure)null, GHC.Maybe.just_DataCon, cLtAstrGts9vT, cliftA2s9m3, cAstrGts9lY, cLtAstrs9yK);
            fMonadDashGt = new GHC.Base.CColMonad((Closure)null, cGtGtEqs9na, cGtGts9wZ, GHC.Base.@const, lvls9x0);
            fApplicativeDashGt = new GHC.Base.CColApplicative((Closure)null, GHC.Base.@const, cLtAstrGts9lT, cliftA2s9lM, cAstrGts9wQ, cLtAstrs9wU);
            fFunctorDashGt = new GHC.Base.CColFunctor(GHC.Base.dot, cLtDolls9wL);
            fFunctorPrOComPrC = new GHC.Base.CColFunctor(cfmaps9la, cLtDolls9vY);
            fFunctorMaybe = new GHC.Base.CColFunctor(cfmaps9lh, cLtDolls9vN);
            fMonadPlusBrOBrC = new GHC.Base.CColMonadPlus((Closure)null, (Closure)null, GHC.Types.nil_DataCon, GHC.Base.plusPlus);
            fAlternativeBrOBrC = new GHC.Base.CColAlternative((Closure)null, GHC.Types.nil_DataCon, GHC.Base.plusPlus, csomes9vd, cmanys9vu);
            lvls9v6 = new GHC.Types.Cons(GHC.Types.nil_DataCon, GHC.Types.nil_DataCon);
            fMonadBrOBrC = new GHC.Base.CColMonad((Closure)null, cGtGtEqs9no, cAstrGts9mc, cpures9mS, cfails9nm);
            fApplicativeBrOBrC = new GHC.Base.CColApplicative((Closure)null, cpures9mS, cLtAstrGts9mC, cliftA2s9ml, cAstrGts9mc, cLtAstrs9uW);
            fFunctorBrOBrC = new GHC.Base.CColFunctor(GHC.Base.map, cLtDolls9uQ);
            fMonoidOrdering = new GHC.Base.CColMonoid(cLtGts9iU, GHC.Types.eQ_DataCon, cLtGts9iU, gos9ss);
            fMonoidBrOBrC = new GHC.Base.CColMonoid(GHC.Base.plusPlus, GHC.Types.nil_DataCon, GHC.Base.plusPlus, cmconcats9jf);
            maxInt = new GHC.Types.IHash(9223372036854775807);
            minInt = new GHC.Types.IHash(-9223372036854775808);
            otherwise = new GHC.Types.True();
            fMonoidPrOPrC = new GHC.Base.CColMonoid(cLtGts9hy, GHC.Tuple.unit_DataCon, cLtGts9hy, cmconcats9jo);
            fApplicativeBrOBrC.x0 = GHC.Base.fFunctorBrOBrC;
            fMonadBrOBrC.x0 = GHC.Base.fApplicativeBrOBrC;
            fAlternativeBrOBrC.x0 = GHC.Base.fApplicativeBrOBrC;
            fMonadPlusBrOBrC.x0 = GHC.Base.fAlternativeBrOBrC;
            fMonadPlusBrOBrC.x1 = GHC.Base.fMonadBrOBrC;
            fApplicativeDashGt.x0 = GHC.Base.fFunctorDashGt;
            fMonadDashGt.x0 = GHC.Base.fApplicativeDashGt;
            fApplicativeMaybe.x0 = GHC.Base.fFunctorMaybe;
            fMonadMaybe.x0 = GHC.Base.fApplicativeMaybe;
            fAlternativeMaybe.x0 = GHC.Base.fApplicativeMaybe;
            fMonadPlusMaybe.x0 = GHC.Base.fAlternativeMaybe;
            fMonadPlusMaybe.x1 = GHC.Base.fMonadMaybe;
            ltGt = new Fun1<Closure, Closure>(&ltGt_Entry);
            p1Monoid = new Fun1<Closure, Closure>(&p1Monoid_Entry);
            mempty = new Fun1<Closure, Closure>(&mempty_Entry);
            mappend = new Fun1<Closure, Closure>(&mappend_Entry);
            mconcat = new Fun1<Closure, Closure>(&mconcat_Entry);
            fmap = new Fun1<Closure, Closure>(&fmap_Entry);
            ltDoll = new Fun1<Closure, Closure>(&ltDoll_Entry);
            p1Applicative = new Fun1<Closure, Closure>(&p1Applicative_Entry);

            pure = new Fun1<Closure, Closure>(&pure_Entry);
            ltAstrGt = new Fun1<Closure, Closure>(&ltAstrGt_Entry);
            liftA2 = new Fun1<Closure, Closure>(&liftA2_Entry);
            astrGt = new Fun1<Closure, Closure>(&astrGt_Entry);
            ltAstr = new Fun1<Closure, Closure>(&ltAstr_Entry);
            p1Alternative = new Fun1<Closure, Closure>(&p1Alternative_Entry);

            empty = new Fun1<Closure, Closure>(&empty_Entry);
            ltPipeGt = new Fun1<Closure, Closure>(&ltPipeGt_Entry);
            some = new Fun1<Closure, Closure>(&some_Entry);
            many = new Fun1<Closure, Closure>(&many_Entry);
            p1Monad = new Fun1<Closure, Closure>(&p1Monad_Entry);
            gtGtEq = new Fun1<Closure, Closure>(&gtGtEq_Entry);
            gtGt = new Fun1<Closure, Closure>(&gtGt_Entry);
            @return = new Fun1<Closure, Closure>(&@return_Entry);
            fail = new Fun1<Closure, Closure>(&fail_Entry);
            p1MonadPlus = new Fun1<Closure, Closure>(&p1MonadPlus_Entry);

            p2MonadPlus = new Fun1<Closure, Closure>(&p2MonadPlus_Entry);

            mzero = new Fun1<Closure, Closure>(&mzero_Entry);
            mplus = new Fun1<Closure, Closure>(&mplus_Entry);
        }
        public static Closure cColMonoid_DataCon_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonoid(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColFunctor_DataCon_Entry(Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColFunctor(etaB2, etaB1);
        }
        public static Closure cColApplicative_DataCon_Entry(Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColApplicative(etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColAlternative_DataCon_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColAlternative(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColMonad_DataCon_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonad(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColMonadPlus_DataCon_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return new GHC.Base.CColMonadPlus(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cColSemigroup_DataCon_Entry(Closure etaB1)
        {
            return new GHC.Base.CColSemigroup(etaB1);
        }
        public static Closure eqString_Entry(Closure dss9BS, Closure dss9BT)
        {
            var wilds9BU = dss9BS.Eval();
            switch (wilds9BU)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9BU_Nil:
                    {
                        var wilds9BV = dss9BT.Eval();
                        switch (wilds9BV)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Types.Nil wilds9BV_Nil:
                                {
                                    return GHC.Types.true_DataCon.Eval();
                                }
                            case GHC.Types.Cons wilds9BV_Cons:
                                {
                                    var ipvs9BW = wilds9BV_Cons.x0;
                                    var ipvs9BX = wilds9BV_Cons.x1;
                                    return GHC.Types.false_DataCon.Eval();
                                }
                        }
                    }
                case GHC.Types.Cons wilds9BU_Cons:
                    {
                        var c1s9BY = wilds9BU_Cons.x0;
                        var cs1s9BZ = wilds9BU_Cons.x1;
                        var wilds9C0 = dss9BT.Eval();
                        switch (wilds9C0)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Types.Nil wilds9C0_Nil:
                                {
                                    return GHC.Types.false_DataCon.Eval();
                                }
                            case GHC.Types.Cons wilds9C0_Cons:
                                {
                                    var c2s9C1 = wilds9C0_Cons.x0;
                                    var cs2s9C2 = wilds9C0_Cons.x1;
                                    var wilds9C3 = c1s9BY.Eval();
                                    var wilds9C3_CHash = wilds9C3 as GHC.Types.CHash;
                                    var xs9C4 = wilds9C3_CHash.x0;
                                    var wild1s9C5 = c2s9C1.Eval();
                                    var wild1s9C5_CHash = wild1s9C5 as GHC.Types.CHash;
                                    var ys9C6 = wild1s9C5_CHash.x0;
                                    var lwilds9C7 = (xs9C4 == ys9C6) ? 1 : 0;
                                    switch (lwilds9C7)
                                    {
                                        default: { return GHC.Types.false_DataCon.Eval(); }
                                        case 1: { return eqString_Entry(cs1s9BZ, cs2s9C2); }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure cmanys9BH_Entry(Closure vs9BI)
        {
            var many_v_Frees9BJ = (vs9BI, (Closure)null);
            var many_vs9BJ = new Updatable<(Closure x0, Closure x1)>(&many_vs9BJ_Entry, many_v_Frees9BJ);
            many_vs9BJ.free.x1 = many_vs9BJ; return many_vs9BJ.Eval();
        }
        public static Closure many_vs9BJ_Entry(in (Closure x0, Closure x1) many_v_Frees9BJ)
        {
            var vs9BI = many_v_Frees9BJ.x0;
            var many_vs9BJ = many_v_Frees9BJ.x1;
            var wilds9BK = vs9BI.Eval();
            switch (wilds9BK)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9BK_Nothing: { return lvls9BG.Eval(); }
                case GHC.Maybe.Just wilds9BK_Just:
                    {
                        var xs9BL = wilds9BK_Just.x0;
                        var wilds9BM = many_vs9BJ.Eval();
                        switch (wilds9BM)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9BM_Nothing: { return lvls9BG.Eval(); }
                            case GHC.Maybe.Just wilds9BM_Just:
                                {
                                    var ys9BN = wilds9BM_Just.x0;
                                    var sats9BO = new GHC.Types.Cons(xs9BL, ys9BN);
                                    return new GHC.Maybe.Just(sats9BO);
                                }
                        }
                    }
            }
        }
        public static Closure csomes9Bx_Entry(Closure vs9By)
        {
            var some_v_Frees9Bz = (vs9By, (Closure)null);
            var some_vs9Bz = new Updatable<(Closure x0, Closure x1)>(&some_vs9Bz_Entry, some_v_Frees9Bz);
            some_vs9Bz.free.x1 = some_vs9Bz; return some_vs9Bz.Eval();
        }
        public static Closure some_vs9Bz_Entry(in (Closure x0, Closure x1) some_v_Frees9Bz)
        {
            var vs9By = some_v_Frees9Bz.x0;
            var some_vs9Bz = some_v_Frees9Bz.x1;
            var wilds9BA = vs9By.Eval();
            switch (wilds9BA)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9BA_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9BA_Just:
                    {
                        var xs9BB = wilds9BA_Just.x0;
                        var wilds9BC = some_vs9Bz.Eval();
                        switch (wilds9BC)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9BC_Nothing:
                                {
                                    var sats9BD = new GHC.Types.Cons(xs9BB, GHC.Types.nil_DataCon);
                                    return new GHC.Maybe.Just(sats9BD);
                                }
                            case GHC.Maybe.Just wilds9BC_Just:
                                {
                                    var ipvs9BE = wilds9BC_Just.x0;
                                    var sats9BF = new GHC.Types.Cons(xs9BB, ipvs9BE);
                                    return new GHC.Maybe.Just(sats9BF);
                                }
                        }
                    }
            }
        }
        public static Closure liftM_Entry(Closure dMonads9Br, Closure fs9Bs, Closure m1s9Bt)
        {
            var sat_Frees9Bw = (dMonads9Br, fs9Bs);
            var sats9Bw = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9Bw_Entry, sat_Frees9Bw);
            return GHC.Base.gtGtEq_Entry(dMonads9Br).Apply<Closure, Closure, Closure>(m1s9Bt, sats9Bw);
        }
        public static Closure sats9Bw_Entry(in (Closure x0, Closure x1) sat_Frees9Bw, Closure x1s9Bu)
        {
            var dMonads9Br = sat_Frees9Bw.x0;
            var fs9Bs = sat_Frees9Bw.x1;
            var sat_Frees9Bv = (fs9Bs, x1s9Bu);
            var sats9Bv = new Updatable<(Closure x0, Closure x1)>(&sats9Bv_Entry, sat_Frees9Bv);
            return GHC.Base.@return_Entry(dMonads9Br).Apply<Closure, Closure>(sats9Bv);
        }
        public static Closure sats9Bv_Entry(in (Closure x0, Closure x1) sat_Frees9Bv)
        {
            var fs9Bs = sat_Frees9Bv.x0;
            var x1s9Bu = sat_Frees9Bv.x1;
            return fs9Bs.Apply<Closure, Closure>(x1s9Bu);
        }
        public static Closure sliftMs9Bp_Entry(Closure etaB2, Closure etaB1)
        {
            return cfmaps9lh_Entry(etaB2, etaB1);
        }
        public static Closure liftM2_Entry(Closure dMonads9Bg, Closure fs9Bh, Closure m1s9Bi, Closure m2s9Bj)
        {
            var sat_Frees9Bo = (dMonads9Bg, fs9Bh, m2s9Bj);
            var sats9Bo = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&sats9Bo_Entry, sat_Frees9Bo);
            return GHC.Base.gtGtEq_Entry(dMonads9Bg).Apply<Closure, Closure, Closure>(m1s9Bi, sats9Bo);
        }
        public static Closure sats9Bo_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9Bo, Closure x1s9Bk)
        {
            var dMonads9Bg = sat_Frees9Bo.x0;
            var fs9Bh = sat_Frees9Bo.x1;
            var m2s9Bj = sat_Frees9Bo.x2;
            var sat_Frees9Bn = (dMonads9Bg, fs9Bh, x1s9Bk);
            var sats9Bn = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&sats9Bn_Entry, sat_Frees9Bn);
            return GHC.Base.gtGtEq_Entry(dMonads9Bg).Apply<Closure, Closure, Closure>(m2s9Bj, sats9Bn);
        }
        public static Closure sats9Bn_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9Bn, Closure x2s9Bl)
        {
            var dMonads9Bg = sat_Frees9Bn.x0;
            var fs9Bh = sat_Frees9Bn.x1;
            var x1s9Bk = sat_Frees9Bn.x2;
            var sat_Frees9Bm = (fs9Bh, x1s9Bk, x2s9Bl);
            var sats9Bm = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9Bm_Entry, sat_Frees9Bm);
            return GHC.Base.@return_Entry(dMonads9Bg).Apply<Closure, Closure>(sats9Bm);
        }
        public static Closure sats9Bm_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9Bm)
        {
            var fs9Bh = sat_Frees9Bm.x0;
            var x1s9Bk = sat_Frees9Bm.x1;
            var x2s9Bl = sat_Frees9Bm.x2;
            return fs9Bh.Apply<Closure, Closure, Closure>(x1s9Bk, x2s9Bl);
        }
        public static Closure sliftM2s9Be_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cliftA2s9m3_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure liftM3_Entry(Closure dMonads9B2, Closure fs9B3, Closure m1s9B4, Closure m2s9B5, Closure m3s9B6)
        {
            var sat_Frees9Bd = (dMonads9B2, fs9B3, m2s9B5, m3s9B6);
            var sats9Bd = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&sats9Bd_Entry, sat_Frees9Bd);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m1s9B4, sats9Bd);
        }
        public static Closure sats9Bd_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9Bd, Closure x1s9B7)
        {
            var dMonads9B2 = sat_Frees9Bd.x0;
            var fs9B3 = sat_Frees9Bd.x1;
            var m2s9B5 = sat_Frees9Bd.x2;
            var m3s9B6 = sat_Frees9Bd.x3;
            var sat_Frees9Bc = (dMonads9B2, fs9B3, m3s9B6, x1s9B7);
            var sats9Bc = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&sats9Bc_Entry, sat_Frees9Bc);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m2s9B5, sats9Bc);
        }
        public static Closure sats9Bc_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9Bc, Closure x2s9B8)
        {
            var dMonads9B2 = sat_Frees9Bc.x0;
            var fs9B3 = sat_Frees9Bc.x1;
            var m3s9B6 = sat_Frees9Bc.x2;
            var x1s9B7 = sat_Frees9Bc.x3;
            var sat_Frees9Bb = (dMonads9B2, fs9B3, x1s9B7, x2s9B8);
            var sats9Bb = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&sats9Bb_Entry, sat_Frees9Bb);
            return GHC.Base.gtGtEq_Entry(dMonads9B2).Apply<Closure, Closure, Closure>(m3s9B6, sats9Bb);
        }
        public static Closure sats9Bb_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9Bb, Closure x3s9B9)
        {
            var dMonads9B2 = sat_Frees9Bb.x0;
            var fs9B3 = sat_Frees9Bb.x1;
            var x1s9B7 = sat_Frees9Bb.x2;
            var x2s9B8 = sat_Frees9Bb.x3;
            var sat_Frees9Ba = (fs9B3, x1s9B7, x2s9B8, x3s9B9);
            var sats9Ba = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3)>(&sats9Ba_Entry, sat_Frees9Ba);
            return GHC.Base.@return_Entry(dMonads9B2).Apply<Closure, Closure>(sats9Ba);
        }
        public static Closure sats9Ba_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9Ba)
        {
            var fs9B3 = sat_Frees9Ba.x0;
            var x1s9B7 = sat_Frees9Ba.x1;
            var x2s9B8 = sat_Frees9Ba.x2;
            var x3s9B9 = sat_Frees9Ba.x3;
            return fs9B3.Apply<Closure, Closure, Closure, Closure>(x1s9B7, x2s9B8, x3s9B9);
        }
        public static Closure sliftM3s9AP_Entry(Closure fs9AQ, Closure m1s9AR, Closure m2s9AS, Closure m3s9AT)
        {
            var wilds9AU = m1s9AR.Eval();
            switch (wilds9AU)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9AU_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9AU_Just:
                    {
                        var xs9AV = wilds9AU_Just.x0;
                        var wilds9AW = m2s9AS.Eval();
                        switch (wilds9AW)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9AW_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9AW_Just:
                                {
                                    var xs9AX = wilds9AW_Just.x0;
                                    var wilds9AY = m3s9AT.Eval();
                                    switch (wilds9AY)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9AY_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9AY_Just:
                                            {
                                                var xs9AZ = wilds9AY_Just.x0;
                                                var sat_Frees9B0 = (fs9AQ, xs9AV, xs9AX, xs9AZ);
                                                var sats9B0 = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3)>(&sats9B0_Entry, sat_Frees9B0);
                                                return new GHC.Maybe.Just(sats9B0);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9B0_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9B0)
        {
            var fs9AQ = sat_Frees9B0.x0;
            var xs9AV = sat_Frees9B0.x1;
            var xs9AX = sat_Frees9B0.x2;
            var xs9AZ = sat_Frees9B0.x3;
            return fs9AQ.Apply<Closure, Closure, Closure, Closure>(xs9AV, xs9AX, xs9AZ);
        }
        public static Closure liftM4_Entry(Closure dMonads9AA, Closure fs9AB, Closure m1s9AC, Closure m2s9AD, Closure m3s9AE, Closure m4s9AF)
        {
            var sat_Frees9AO = (dMonads9AA, fs9AB, m2s9AD, m3s9AE, m4s9AF);
            var sats9AO = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&sats9AO_Entry, sat_Frees9AO);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m1s9AC, sats9AO);
        }
        public static Closure sats9AO_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9AO, Closure x1s9AG)
        {
            var dMonads9AA = sat_Frees9AO.x0;
            var fs9AB = sat_Frees9AO.x1;
            var m2s9AD = sat_Frees9AO.x2;
            var m3s9AE = sat_Frees9AO.x3;
            var m4s9AF = sat_Frees9AO.x4;
            var sat_Frees9AN = (dMonads9AA, fs9AB, m3s9AE, m4s9AF, x1s9AG);
            var sats9AN = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&sats9AN_Entry, sat_Frees9AN);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m2s9AD, sats9AN);
        }
        public static Closure sats9AN_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9AN, Closure x2s9AH)
        {
            var dMonads9AA = sat_Frees9AN.x0;
            var fs9AB = sat_Frees9AN.x1;
            var m3s9AE = sat_Frees9AN.x2;
            var m4s9AF = sat_Frees9AN.x3;
            var x1s9AG = sat_Frees9AN.x4;
            var sat_Frees9AM = (dMonads9AA, fs9AB, m4s9AF, x1s9AG, x2s9AH);
            var sats9AM = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&sats9AM_Entry, sat_Frees9AM);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m3s9AE, sats9AM);
        }
        public static Closure sats9AM_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9AM, Closure x3s9AI)
        {
            var dMonads9AA = sat_Frees9AM.x0;
            var fs9AB = sat_Frees9AM.x1;
            var m4s9AF = sat_Frees9AM.x2;
            var x1s9AG = sat_Frees9AM.x3;
            var x2s9AH = sat_Frees9AM.x4;
            var sat_Frees9AL = (dMonads9AA, fs9AB, x1s9AG, x2s9AH, x3s9AI);
            var sats9AL = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&sats9AL_Entry, sat_Frees9AL);
            return GHC.Base.gtGtEq_Entry(dMonads9AA).Apply<Closure, Closure, Closure>(m4s9AF, sats9AL);
        }
        public static Closure sats9AL_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9AL, Closure x4s9AJ)
        {
            var dMonads9AA = sat_Frees9AL.x0;
            var fs9AB = sat_Frees9AL.x1;
            var x1s9AG = sat_Frees9AL.x2;
            var x2s9AH = sat_Frees9AL.x3;
            var x3s9AI = sat_Frees9AL.x4;
            var sat_Frees9AK = (fs9AB, x1s9AG, x2s9AH, x3s9AI, x4s9AJ);
            var sats9AK = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)>(&sats9AK_Entry, sat_Frees9AK);
            return GHC.Base.@return_Entry(dMonads9AA).Apply<Closure, Closure>(sats9AK);
        }
        public static Closure sats9AK_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9AK)
        {
            var fs9AB = sat_Frees9AK.x0;
            var x1s9AG = sat_Frees9AK.x1;
            var x2s9AH = sat_Frees9AK.x2;
            var x3s9AI = sat_Frees9AK.x3;
            var x4s9AJ = sat_Frees9AK.x4;
            return fs9AB.Apply<Closure, Closure, Closure, Closure, Closure>(x1s9AG, x2s9AH, x3s9AI, x4s9AJ);
        }
        public static Closure sliftM4s9Ak_Entry(Closure fs9Al, Closure m1s9Am, Closure m2s9An, Closure m3s9Ao, Closure m4s9Ap)
        {
            var wilds9Aq = m1s9Am.Eval();
            switch (wilds9Aq)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9Aq_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9Aq_Just:
                    {
                        var xs9Ar = wilds9Aq_Just.x0;
                        var wilds9As = m2s9An.Eval();
                        switch (wilds9As)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9As_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9As_Just:
                                {
                                    var xs9At = wilds9As_Just.x0;
                                    var wilds9Au = m3s9Ao.Eval();
                                    switch (wilds9Au)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9Au_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9Au_Just:
                                            {
                                                var xs9Av = wilds9Au_Just.x0;
                                                var wilds9Aw = m4s9Ap.Eval();
                                                switch (wilds9Aw)
                                                {
                                                    default: { throw new ImpossibleException(); }
                                                    case GHC.Maybe.Nothing wilds9Aw_Nothing:
                                                        {
                                                            return GHC.Maybe.nothing_DataCon.Eval();
                                                        }
                                                    case GHC.Maybe.Just wilds9Aw_Just:
                                                        {
                                                            var xs9Ax = wilds9Aw_Just.x0;
                                                            var sat_Frees9Ay = (fs9Al, xs9Ar, xs9At, xs9Av, xs9Ax);
                                                            var sats9Ay = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)>(&sats9Ay_Entry, sat_Frees9Ay);
                                                            return new GHC.Maybe.Just(sats9Ay);
                                                        }
                                                }
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9Ay_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9Ay)
        {
            var fs9Al = sat_Frees9Ay.x0;
            var xs9Ar = sat_Frees9Ay.x1;
            var xs9At = sat_Frees9Ay.x2;
            var xs9Av = sat_Frees9Ay.x3;
            var xs9Ax = sat_Frees9Ay.x4;
            return fs9Al.Apply<Closure, Closure, Closure, Closure, Closure>(xs9Ar, xs9At, xs9Av, xs9Ax);
        }
        public static Closure liftM5_Entry(Closure dMonads9A2, Closure fs9A3, Closure m1s9A4, Closure m2s9A5, Closure m3s9A6, Closure m4s9A7, Closure m5s9A8)
        {
            var sat_Frees9Aj = (dMonads9A2, fs9A3, m2s9A5, m3s9A6, m4s9A7, m5s9A8);
            var sats9Aj = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&sats9Aj_Entry, sat_Frees9Aj);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m1s9A4, sats9Aj);
        }
        public static Closure sats9Aj_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Aj, Closure x1s9A9)
        {
            var dMonads9A2 = sat_Frees9Aj.x0;
            var fs9A3 = sat_Frees9Aj.x1;
            var m2s9A5 = sat_Frees9Aj.x2;
            var m3s9A6 = sat_Frees9Aj.x3;
            var m4s9A7 = sat_Frees9Aj.x4;
            var m5s9A8 = sat_Frees9Aj.x5;
            var sat_Frees9Ai = (dMonads9A2, fs9A3, m3s9A6, m4s9A7, m5s9A8, x1s9A9);
            var sats9Ai = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&sats9Ai_Entry, sat_Frees9Ai);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m2s9A5, sats9Ai);
        }
        public static Closure sats9Ai_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Ai, Closure x2s9Aa)
        {
            var dMonads9A2 = sat_Frees9Ai.x0;
            var fs9A3 = sat_Frees9Ai.x1;
            var m3s9A6 = sat_Frees9Ai.x2;
            var m4s9A7 = sat_Frees9Ai.x3;
            var m5s9A8 = sat_Frees9Ai.x4;
            var x1s9A9 = sat_Frees9Ai.x5;
            var sat_Frees9Ah = (dMonads9A2, fs9A3, m4s9A7, m5s9A8, x1s9A9, x2s9Aa);
            var sats9Ah = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&sats9Ah_Entry, sat_Frees9Ah);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m3s9A6, sats9Ah);
        }
        public static Closure sats9Ah_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Ah, Closure x3s9Ab)
        {
            var dMonads9A2 = sat_Frees9Ah.x0;
            var fs9A3 = sat_Frees9Ah.x1;
            var m4s9A7 = sat_Frees9Ah.x2;
            var m5s9A8 = sat_Frees9Ah.x3;
            var x1s9A9 = sat_Frees9Ah.x4;
            var x2s9Aa = sat_Frees9Ah.x5;
            var sat_Frees9Ag = (dMonads9A2, fs9A3, m5s9A8, x1s9A9, x2s9Aa, x3s9Ab);
            var sats9Ag = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&sats9Ag_Entry, sat_Frees9Ag);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m4s9A7, sats9Ag);
        }
        public static Closure sats9Ag_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Ag, Closure x4s9Ac)
        {
            var dMonads9A2 = sat_Frees9Ag.x0;
            var fs9A3 = sat_Frees9Ag.x1;
            var m5s9A8 = sat_Frees9Ag.x2;
            var x1s9A9 = sat_Frees9Ag.x3;
            var x2s9Aa = sat_Frees9Ag.x4;
            var x3s9Ab = sat_Frees9Ag.x5;
            var sat_Frees9Af = (dMonads9A2, fs9A3, x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac);
            var sats9Af = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&sats9Af_Entry, sat_Frees9Af);
            return GHC.Base.gtGtEq_Entry(dMonads9A2).Apply<Closure, Closure, Closure>(m5s9A8, sats9Af);
        }
        public static Closure sats9Af_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Af, Closure x5s9Ad)
        {
            var dMonads9A2 = sat_Frees9Af.x0;
            var fs9A3 = sat_Frees9Af.x1;
            var x1s9A9 = sat_Frees9Af.x2;
            var x2s9Aa = sat_Frees9Af.x3;
            var x3s9Ab = sat_Frees9Af.x4;
            var x4s9Ac = sat_Frees9Af.x5;
            var sat_Frees9Ae = (fs9A3, x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac, x5s9Ad);
            var sats9Ae = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5)>(&sats9Ae_Entry, sat_Frees9Ae);
            return GHC.Base.@return_Entry(dMonads9A2).Apply<Closure, Closure>(sats9Ae);
        }
        public static Closure sats9Ae_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9Ae)
        {
            var fs9A3 = sat_Frees9Ae.x0;
            var x1s9A9 = sat_Frees9Ae.x1;
            var x2s9Aa = sat_Frees9Ae.x2;
            var x3s9Ab = sat_Frees9Ae.x3;
            var x4s9Ac = sat_Frees9Ae.x4;
            var x5s9Ad = sat_Frees9Ae.x5;
            return fs9A3.Apply<Closure, Closure, Closure, Closure, Closure, Closure>(x1s9A9, x2s9Aa, x3s9Ab, x4s9Ac, x5s9Ad);
        }
        public static Closure sliftM5s9zJ_Entry(Closure fs9zK, Closure m1s9zL, Closure m2s9zM, Closure m3s9zN, Closure m4s9zO, Closure m5s9zP)
        {
            var wilds9zQ = m1s9zL.Eval();
            switch (wilds9zQ)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9zQ_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9zQ_Just:
                    {
                        var xs9zR = wilds9zQ_Just.x0;
                        var wilds9zS = m2s9zM.Eval();
                        switch (wilds9zS)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9zS_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9zS_Just:
                                {
                                    var xs9zT = wilds9zS_Just.x0;
                                    var wilds9zU = m3s9zN.Eval();
                                    switch (wilds9zU)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9zU_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9zU_Just:
                                            {
                                                var xs9zV = wilds9zU_Just.x0;
                                                var wilds9zW = m4s9zO.Eval();
                                                switch (wilds9zW)
                                                {
                                                    default: { throw new ImpossibleException(); }
                                                    case GHC.Maybe.Nothing wilds9zW_Nothing:
                                                        {
                                                            return GHC.Maybe.nothing_DataCon.Eval();
                                                        }
                                                    case GHC.Maybe.Just wilds9zW_Just:
                                                        {
                                                            var xs9zX = wilds9zW_Just.x0;
                                                            var wilds9zY = m5s9zP.Eval();
                                                            switch (wilds9zY)
                                                            {
                                                                default: { throw new ImpossibleException(); }
                                                                case GHC.Maybe.Nothing wilds9zY_Nothing:
                                                                    {
                                                                        return GHC.Maybe.nothing_DataCon.Eval();
                                                                    }
                                                                case GHC.Maybe.Just wilds9zY_Just:
                                                                    {
                                                                        var xs9zZ = wilds9zY_Just.x0;
                                                                        var sat_Frees9A0 = (fs9zK, xs9zR, xs9zT, xs9zV, xs9zX, xs9zZ);
                                                                        var sats9A0 = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5)>(&sats9A0_Entry, sat_Frees9A0);
                                                                        return new GHC.Maybe.Just(sats9A0);
                                                                    }
                                                            }
                                                        }
                                                }
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9A0_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) sat_Frees9A0)
        {
            var fs9zK = sat_Frees9A0.x0;
            var xs9zR = sat_Frees9A0.x1;
            var xs9zT = sat_Frees9A0.x2;
            var xs9zV = sat_Frees9A0.x3;
            var xs9zX = sat_Frees9A0.x4;
            var xs9zZ = sat_Frees9A0.x5;
            return fs9zK.Apply<Closure, Closure, Closure, Closure, Closure, Closure>(xs9zR, xs9zT, xs9zV, xs9zX, xs9zZ);
        }
        public static Closure ap_Entry(Closure dMonads9zB, Closure m1s9zC, Closure m2s9zD)
        {
            var sat_Frees9zI = (dMonads9zB, m2s9zD);
            var sats9zI = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9zI_Entry, sat_Frees9zI);
            return GHC.Base.gtGtEq_Entry(dMonads9zB).Apply<Closure, Closure, Closure>(m1s9zC, sats9zI);
        }
        public static Closure sats9zI_Entry(in (Closure x0, Closure x1) sat_Frees9zI, Closure x1s9zE)
        {
            var dMonads9zB = sat_Frees9zI.x0;
            var m2s9zD = sat_Frees9zI.x1;
            var sat_Frees9zH = (dMonads9zB, x1s9zE);
            var sats9zH = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9zH_Entry, sat_Frees9zH);
            return GHC.Base.gtGtEq_Entry(dMonads9zB).Apply<Closure, Closure, Closure>(m2s9zD, sats9zH);
        }
        public static Closure sats9zH_Entry(in (Closure x0, Closure x1) sat_Frees9zH, Closure x2s9zF)
        {
            var dMonads9zB = sat_Frees9zH.x0;
            var x1s9zE = sat_Frees9zH.x1;
            var sat_Frees9zG = (x1s9zE, x2s9zF);
            var sats9zG = new Updatable<(Closure x0, Closure x1)>(&sats9zG_Entry, sat_Frees9zG);
            return GHC.Base.@return_Entry(dMonads9zB).Apply<Closure, Closure>(sats9zG);
        }
        public static Closure sats9zG_Entry(in (Closure x0, Closure x1) sat_Frees9zG)
        {
            var x1s9zE = sat_Frees9zG.x0;
            var x2s9zF = sat_Frees9zG.x1;
            return x1s9zE.Apply<Closure, Closure>(x2s9zF);
        }
        public static Closure saps9zs_Entry(Closure m1s9zt, Closure m2s9zu)
        {
            var wilds9zv = m1s9zt.Eval();
            switch (wilds9zv)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9zv_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9zv_Just:
                    {
                        var xs9zw = wilds9zv_Just.x0;
                        var wilds9zx = m2s9zu.Eval();
                        switch (wilds9zx)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9zx_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9zx_Just:
                                {
                                    var xs9zy = wilds9zx_Just.x0;
                                    var sat_Frees9zz = (xs9zw, xs9zy);
                                    var sats9zz = new Updatable<(Closure x0, Closure x1)>(&sats9zz_Entry, sat_Frees9zz);
                                    return new GHC.Maybe.Just(sats9zz);
                                }
                        }
                    }
            }
        }
        public static Closure sats9zz_Entry(in (Closure x0, Closure x1) sat_Frees9zz)
        {
            var xs9zw = sat_Frees9zz.x0;
            var xs9zy = sat_Frees9zz.x1;
            return xs9zw.Apply<Closure, Closure>(xs9zy);
        }
        public static Closure when_Entry(Closure dApplicatives9zn, Closure ps9zo, Closure ss9zp)
        {
            var wilds9zq = ps9zo.Eval();
            var wilds9zqTags9zq = wilds9zq.Tag;
            switch (wilds9zqTags9zq)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9zq_False = wilds9zq as GHC.Types.False;
                        return GHC.Base.pure_Entry(dApplicatives9zn).Apply<Closure, Closure>(GHC.Tuple.unit_DataCon);
                    }
                case 2:
                    {
                        var wilds9zq_True = wilds9zq as GHC.Types.True;
                        return ss9zp.Eval();
                    }
            }
        }
        public static Closure swhens9zi_Entry(Closure ps9zj, Closure ss9zk)
        {
            var wilds9zl = ps9zj.Eval();
            var wilds9zlTags9zl = wilds9zl.Tag;
            switch (wilds9zlTags9zl)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9zl_False = wilds9zl as GHC.Types.False;
                        return lvls9zh.Eval();
                    }
                case 2:
                    {
                        var wilds9zl_True = wilds9zl as GHC.Types.True;
                        return ss9zk.Eval();
                    }
            }
        }
        public static Closure liftA_Entry(Closure dApplicatives9zd, Closure fs9ze, Closure as9zf)
        {
            var sat_Frees9zg = (dApplicatives9zd, fs9ze);
            var sats9zg = new Updatable<(Closure x0, Closure x1)>(&sats9zg_Entry, sat_Frees9zg);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9zd).Apply<Closure, Closure, Closure>(sats9zg, as9zf);
        }
        public static Closure sats9zg_Entry(in (Closure x0, Closure x1) sat_Frees9zg)
        {
            var dApplicatives9zd = sat_Frees9zg.x0;
            var fs9ze = sat_Frees9zg.x1;
            return GHC.Base.pure_Entry(dApplicatives9zd).Apply<Closure, Closure>(fs9ze);
        }
        public static Closure sliftAs9zb_Entry(Closure etaB2, Closure etaB1)
        {
            return cfmaps9lh_Entry(etaB2, etaB1);
        }
        public static Closure liftA3_Entry(Closure dApplicatives9z5, Closure fs9z6, Closure as9z7, Closure bs9z8, Closure cs9z9)
        {
            var sat_Frees9za = (dApplicatives9z5, fs9z6, as9z7, bs9z8);
            var sats9za = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3)>(&sats9za_Entry, sat_Frees9za);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9z5).Apply<Closure, Closure, Closure>(sats9za, cs9z9);
        }
        public static Closure sats9za_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9za)
        {
            var dApplicatives9z5 = sat_Frees9za.x0;
            var fs9z6 = sat_Frees9za.x1;
            var as9z7 = sat_Frees9za.x2;
            var bs9z8 = sat_Frees9za.x3;
            return GHC.Base.liftA2_Entry(dApplicatives9z5).Apply<Closure, Closure, Closure, Closure>(fs9z6, as9z7, bs9z8);
        }
        public static Closure sliftA3s9yS_Entry(Closure fs9yT, Closure as9yU, Closure bs9yV, Closure cs9yW)
        {
            var wilds9yX = as9yU.Eval();
            switch (wilds9yX)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9yX_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9yX_Just:
                    {
                        var xs9yY = wilds9yX_Just.x0;
                        var wilds9yZ = bs9yV.Eval();
                        switch (wilds9yZ)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9yZ_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9yZ_Just:
                                {
                                    var ys9z0 = wilds9yZ_Just.x0;
                                    var wilds9z1 = cs9yW.Eval();
                                    switch (wilds9z1)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9z1_Nothing:
                                            {
                                                return GHC.Maybe.nothing_DataCon.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9z1_Just:
                                            {
                                                var as9z2 = wilds9z1_Just.x0;
                                                var sat_Frees9z3 = (fs9yT, xs9yY, ys9z0, as9z2);
                                                var sats9z3 = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3)>(&sats9z3_Entry, sat_Frees9z3);
                                                return new GHC.Maybe.Just(sats9z3);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9z3_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9z3)
        {
            var fs9yT = sat_Frees9z3.x0;
            var xs9yY = sat_Frees9z3.x1;
            var ys9z0 = sat_Frees9z3.x2;
            var as9z2 = sat_Frees9z3.x3;
            return fs9yT.Apply<Closure, Closure, Closure, Closure>(xs9yY, ys9z0, as9z2);
        }
        public static Closure cLtAstrs9yK_Entry(Closure dss9yL, Closure dss9yM)
        {
            var wilds9yN = dss9yL.Eval();
            switch (wilds9yN)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9yN_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9yN_Just:
                    {
                        var xs9yO = wilds9yN_Just.x0;
                        var wilds9yP = dss9yM.Eval();
                        switch (wilds9yP)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9yP_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9yP_Just:
                                {
                                    var ys9yQ = wilds9yP_Just.x0; return wilds9yN.Eval();
                                }
                        }
                    }
            }
        }
        public static Closure modInt_Entry(Closure dss9xJ, Closure dss9xK)
        {
            var wilds9xL = dss9xJ.Eval();
            var wilds9xL_IHash = wilds9xL as GHC.Types.IHash;
            var xs9xM = wilds9xL_IHash.x0;
            var wilds9xN = dss9xK.Eval();
            var wilds9xN_IHash = wilds9xN as GHC.Types.IHash;
            var ys9xO = wilds9xN_IHash.x0;
            var wilds9xP = GHC.Classes.modIntHash_Entry(xs9xM, ys9xO);
            return new GHC.Types.IHash(wilds9xP);
        }
        public static Closure divInt_Entry(Closure dss9xB, Closure dss9xC)
        {
            var wilds9xD = dss9xB.Eval();
            var wilds9xD_IHash = wilds9xD as GHC.Types.IHash;
            var xs9xE = wilds9xD_IHash.x0;
            var wilds9xF = dss9xC.Eval();
            var wilds9xF_IHash = wilds9xF as GHC.Types.IHash;
            var ys9xG = wilds9xF_IHash.x0;
            var wilds9xH = GHC.Classes.divIntHash_Entry(xs9xE, ys9xG);
            return new GHC.Types.IHash(wilds9xH);
        }
        public static Closure quotRemInt_Entry(Closure xs9xw, Closure ys9xx)
        {
            var sat_Frees9xz = (xs9xw, ys9xx);
            var sats9xz = new Updatable<(Closure x0, Closure x1)>(&sats9xz_Entry, sat_Frees9xz);
            var sat_Frees9xy = (xs9xw, ys9xx);
            var sats9xy = new Updatable<(Closure x0, Closure x1)>(&sats9xy_Entry, sat_Frees9xy);
            return new GHC.Tuple.Tuple2(sats9xy, sats9xz);
        }
        public static Closure sats9xy_Entry(in (Closure x0, Closure x1) sat_Frees9xy)
        {
            var xs9xw = sat_Frees9xy.x0;
            var ys9xx = sat_Frees9xy.x1;
            return quotInt_Entry(xs9xw, ys9xx);
        }
        public static Closure sats9xz_Entry(in (Closure x0, Closure x1) sat_Frees9xz)
        {
            var xs9xw = sat_Frees9xz.x0;
            var ys9xx = sat_Frees9xz.x1; return remInt_Entry(xs9xw, ys9xx);
        }
        public static Closure remInt_Entry(Closure dss9xo, Closure dss9xp)
        {
            var wilds9xq = dss9xo.Eval();
            var wilds9xq_IHash = wilds9xq as GHC.Types.IHash;
            var xs9xr = wilds9xq_IHash.x0;
            var wilds9xs = dss9xp.Eval();
            var wilds9xs_IHash = wilds9xs as GHC.Types.IHash;
            var ys9xt = wilds9xs_IHash.x0;
            var wilds9xu = xs9xr % ys9xt;
            return new GHC.Types.IHash(wilds9xu);
        }
        public static Closure quotInt_Entry(Closure dss9xg, Closure dss9xh)
        {
            var wilds9xi = dss9xg.Eval();
            var wilds9xi_IHash = wilds9xi as GHC.Types.IHash;
            var xs9xj = wilds9xi_IHash.x0;
            var wilds9xk = dss9xh.Eval();
            var wilds9xk_IHash = wilds9xk as GHC.Types.IHash;
            var ys9xl = wilds9xk_IHash.x0;
            var wilds9xm = xs9xj / ys9xl;
            return new GHC.Types.IHash(wilds9xm);
        }
        public static long getTag_Entry(Closure etaB1)
        {
            return etaB1.Tag;
        }
        public static GenericR dollBang_Entry<GenericR>(Closure fs9xb, Closure xs9xc)
        {
            var vxs9xd = xs9xc.Eval();
            return fs9xb.Apply<Closure, GenericR>(vxs9xd);
        }
        public static GenericR doll_Entry<GenericR>(Closure fs9x8, Closure xs9x9)
        {
            return fs9x8.Apply<Closure, GenericR>(xs9x9);
        }
        public static Closure flip_Entry(Closure fs9x4, Closure xs9x5, Closure ys9x6)
        {
            return fs9x4.Apply<Closure, Closure, Closure>(ys9x6, xs9x5);
        }
        public static Closure lvls9x0_Entry(Closure etas9x1)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(etas9x1);
        }
        public static Closure cGtGts9wZ_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9wQ_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure cLtAstrs9wU_Entry(Closure fs9wV, Closure gs9wW, Closure xs9wX)
        {
            return fs9wV.Apply<Closure, Closure>(xs9wX);
        }
        public static Closure cAstrGts9wQ_Entry(Closure a1s9wR, Closure a2s9wS, Closure xs9wT)
        {
            return a2s9wS.Apply<Closure, Closure>(xs9wT);
        }
        public static Closure cLtDolls9wL_Entry(Closure xs9wM, Closure etas9wN, Closure etas9wO)
        {
            return xs9wM.Eval();
        }
        public static Closure fMonadPrOComPrC_Entry(Closure dMonoids9wE)
        {
            var lvls9wF = new Updatable<Closure>(&lvls9wF_Entry, dMonoids9wE);
            var sats9wK = new Fun1<Closure, Closure, Closure>(&sats9wK_Entry, lvls9wF);
            var sats9wI = new Fun2<Closure, Closure, Closure, Closure>(&sats9wI_Entry, dMonoids9wE);
            var sats9wH = new Fun2<Closure, Closure, Closure, Closure>(&sats9wH_Entry, dMonoids9wE);
            var sats9wG = new Updatable<Closure>(&sats9wG_Entry, dMonoids9wE);
            return new GHC.Base.CColMonad(sats9wG, sats9wH, sats9wI, sats9wK, lvls9wB);
        }
        public static Closure sats9wG_Entry(in Closure dMonoids9wE)
        {
            return fApplicativePrOComPrC_Entry(dMonoids9wE);
        }
        public static Closure sats9wH_Entry(in Closure dMonoids9wE, Closure etaB2, Closure etaB1)
        {
            return cGtGtEqs9mZ_Entry(dMonoids9wE, etaB2, etaB1);
        }
        public static Closure sats9wI_Entry(in Closure dMonoids9wE, Closure etaB2, Closure etaB1)
        {
            return cGtGts9wA_Entry(dMonoids9wE, etaB2, etaB1);
        }
        public static Closure sats9wK_Entry(in Closure lvls9wF, Closure xs9wJ)
        {
            return new GHC.Tuple.Tuple2(lvls9wF, xs9wJ);
        }
        public static Closure lvls9wF_Entry(in Closure dMonoids9wE)
        {
            return GHC.Base.mempty_Entry(dMonoids9wE);
        }
        public static Closure lvls9wB_Entry(Closure etas9wC)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(etas9wC);
        }
        public static Closure cGtGts9wA_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9w5_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure fApplicativePrOComPrC_Entry(Closure dMonoids9ws)
        {
            var lvls9wt = new Updatable<Closure>(&lvls9wt_Entry, dMonoids9ws);
            var sats9wz = new Fun2<Closure, Closure, Closure, Closure>(&sats9wz_Entry, dMonoids9ws);
            var sats9wy = new Fun2<Closure, Closure, Closure, Closure>(&sats9wy_Entry, dMonoids9ws);
            var sats9wx = new Fun3<Closure, Closure, Closure, Closure, Closure>(&sats9wx_Entry, dMonoids9ws);
            var sats9ww = new Fun2<Closure, Closure, Closure, Closure>(&sats9ww_Entry, dMonoids9ws);
            var sats9wv = new Fun1<Closure, Closure, Closure>(&sats9wv_Entry, lvls9wt);
            return new GHC.Base.CColApplicative(GHC.Base.fFunctorPrOComPrC, sats9wv, sats9ww, sats9wx, sats9wy, sats9wz);
        }
        public static Closure sats9wv_Entry(in Closure lvls9wt, Closure xs9wu)
        {
            return new GHC.Tuple.Tuple2(lvls9wt, xs9wu);
        }
        public static Closure sats9ww_Entry(in Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cLtAstrGts9lA_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure sats9wx_Entry(in Closure dMonoids9ws, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cliftA2s9ln_Entry(dMonoids9ws, etaB3, etaB2, etaB1);
        }
        public static Closure sats9wy_Entry(in Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cAstrGts9w5_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure sats9wz_Entry(in Closure dMonoids9ws, Closure etaB2, Closure etaB1)
        {
            return cLtAstrs9wg_Entry(dMonoids9ws, etaB2, etaB1);
        }
        public static Closure lvls9wt_Entry(in Closure dMonoids9ws)
        {
            return GHC.Base.mempty_Entry(dMonoids9ws);
        }
        public static Closure cLtAstrs9wg_Entry(Closure dMonoids9wh, Closure etas9wi, Closure etas9wj)
        {
            var wilds9wk = etas9wi.Eval();
            var wilds9wk_Tuple2 = wilds9wk as GHC.Tuple.Tuple2;
            var us9wl = wilds9wk_Tuple2.x0;
            var xs9wm = wilds9wk_Tuple2.x1;
            var wilds9wn = etas9wj.Eval();
            var wilds9wn_Tuple2 = wilds9wn as GHC.Tuple.Tuple2;
            var vs9wo = wilds9wn_Tuple2.x0;
            var ys9wp = wilds9wn_Tuple2.x1;
            var sat_Frees9wq = (dMonoids9wh, us9wl, vs9wo);
            var sats9wq = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9wq_Entry, sat_Frees9wq);
            return new GHC.Tuple.Tuple2(sats9wq, xs9wm);
        }
        public static Closure sats9wq_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9wq)
        {
            var dMonoids9wh = sat_Frees9wq.x0;
            var us9wl = sat_Frees9wq.x1;
            var vs9wo = sat_Frees9wq.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9wh).Apply<Closure, Closure, Closure>(us9wl, vs9wo);
        }
        public static Closure cAstrGts9w5_Entry(Closure dMonoids9w6, Closure a1s9w7, Closure a2s9w8)
        {
            var wilds9w9 = a1s9w7.Eval();
            var wilds9w9_Tuple2 = wilds9w9 as GHC.Tuple.Tuple2;
            var xs9wa = wilds9w9_Tuple2.x0;
            var ys9wb = wilds9w9_Tuple2.x1;
            var wilds9wc = a2s9w8.Eval();
            var wilds9wc_Tuple2 = wilds9wc as GHC.Tuple.Tuple2;
            var vs9wd = wilds9wc_Tuple2.x0;
            var xs9we = wilds9wc_Tuple2.x1;
            var sat_Frees9wf = (dMonoids9w6, xs9wa, vs9wd);
            var sats9wf = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9wf_Entry, sat_Frees9wf);
            return new GHC.Tuple.Tuple2(sats9wf, xs9we);
        }
        public static Closure sats9wf_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9wf)
        {
            var dMonoids9w6 = sat_Frees9wf.x0;
            var xs9wa = sat_Frees9wf.x1;
            var vs9wd = sat_Frees9wf.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9w6).Apply<Closure, Closure, Closure>(xs9wa, vs9wd);
        }
        public static Closure cLtDolls9vY_Entry(Closure xs9vZ, Closure dss9w0)
        {
            var wilds9w1 = dss9w0.Eval();
            var wilds9w1_Tuple2 = wilds9w1 as GHC.Tuple.Tuple2;
            var xs9w2 = wilds9w1_Tuple2.x0;
            var ys9w3 = wilds9w1_Tuple2.x1;
            return new GHC.Tuple.Tuple2(xs9w2, xs9vZ);
        }
        public static Closure cLtAstrGts9vT_Entry(Closure dss9vU, Closure ms9vV)
        {
            var wilds9vW = dss9vU.Eval();
            switch (wilds9vW)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9vW_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9vW_Just:
                    {
                        var fs9vX = wilds9vW_Just.x0;
                        return cfmaps9lh_Entry(fs9vX, ms9vV);
                    }
            }
        }
        public static Closure cLtDolls9vN_Entry(Closure xs9vO, Closure dss9vP)
        {
            var wilds9vQ = dss9vP.Eval();
            switch (wilds9vQ)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9vQ_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9vQ_Just:
                    {
                        var as9vR = wilds9vQ_Just.x0; return new GHC.Maybe.Just(xs9vO);
                    }
            }
        }
        public static Closure cmanys9vu_Entry(Closure vs9vv)
        {
            var many_v_Frees9vw = (vs9vv, (Closure)null);
            var many_vs9vw = new Updatable<(Closure x0, Closure x1)>(&many_vs9vw_Entry, many_v_Frees9vw);
            many_vs9vw.free.x1 = many_vs9vw; return many_vs9vw.Eval();
        }
        public static Closure many_vs9vw_Entry(in (Closure x0, Closure x1) many_v_Frees9vw)
        {
            var vs9vv = many_v_Frees9vw.x0;
            var many_vs9vw = many_v_Frees9vw.x1;
            var go_Frees9vx = (many_vs9vw, (Closure)null);
            var gos9vx = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9vx_Entry, go_Frees9vx);
            gos9vx.free.x1 = gos9vx;
            var sats9vK = gos9vx.Apply<Closure, Closure>(vs9vv);
            return poly_gos9v7_Entry(sats9vK);
        }
        public static Closure gos9vx_Entry(in (Closure x0, Closure x1) go_Frees9vx, Closure dss9vy)
        {
            var many_vs9vw = go_Frees9vx.x0;
            var gos9vx = go_Frees9vx.x1;
            var wilds9vz = dss9vy.Eval();
            switch (wilds9vz)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vz_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9vz_Cons:
                    {
                        var ys9vA = wilds9vz_Cons.x0;
                        var yss9vB = wilds9vz_Cons.x1;
                        var z_Frees9vC = (gos9vx, yss9vB);
                        var zs9vC = new Updatable<(Closure x0, Closure x1)>(&zs9vC_Entry, z_Frees9vC);
                        var go_Frees9vD = (ys9vA, zs9vC, (Closure)null);
                        var gos9vD = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9vD_Entry, go_Frees9vD);
                        gos9vD.free.x2 = gos9vD;
                        return gos9vD.Apply<Closure, Closure>(many_vs9vw);
                    }
            }
        }
        public static Closure gos9vD_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9vD, Closure dss9vE)
        {
            var ys9vA = go_Frees9vD.x0;
            var zs9vC = go_Frees9vD.x1;
            var gos9vD = go_Frees9vD.x2;
            var wilds9vF = dss9vE.Eval();
            switch (wilds9vF)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vF_Nil: { return zs9vC.Eval(); }
                case GHC.Types.Cons wilds9vF_Cons:
                    {
                        var ys9vG = wilds9vF_Cons.x0;
                        var yss9vH = wilds9vF_Cons.x1;
                        var sat_Frees9vJ = (gos9vD, yss9vH);
                        var sats9vJ = new Updatable<(Closure x0, Closure x1)>(&sats9vJ_Entry, sat_Frees9vJ);
                        var sats9vI = new GHC.Types.Cons(ys9vA, ys9vG);
                        return new GHC.Types.Cons(sats9vI, sats9vJ);
                    }
            }
        }
        public static Closure sats9vJ_Entry(in (Closure x0, Closure x1) sat_Frees9vJ)
        {
            var gos9vD = sat_Frees9vJ.x0;
            var yss9vH = sat_Frees9vJ.x1;
            return gos9vD.Apply<Closure, Closure>(yss9vH);
        }
        public static Closure zs9vC_Entry(in (Closure x0, Closure x1) z_Frees9vC)
        {
            var gos9vx = z_Frees9vC.x0;
            var yss9vB = z_Frees9vC.x1;
            return gos9vx.Apply<Closure, Closure>(yss9vB);
        }
        public static Closure csomes9vd_Entry(Closure vs9ve)
        {
            var some_v_Frees9vf = (vs9ve, (Closure)null);
            var some_vs9vf = new Updatable<(Closure x0, Closure x1)>(&some_vs9vf_Entry, some_v_Frees9vf);
            some_vs9vf.free.x1 = some_vs9vf; return some_vs9vf.Eval();
        }
        public static Closure some_vs9vf_Entry(in (Closure x0, Closure x1) some_v_Frees9vf)
        {
            var vs9ve = some_v_Frees9vf.x0;
            var some_vs9vf = some_v_Frees9vf.x1;
            var yss9vg = new Updatable<Closure>(&yss9vg_Entry, some_vs9vf);
            var go_Frees9vh = (yss9vg, (Closure)null);
            var gos9vh = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9vh_Entry, go_Frees9vh);
            gos9vh.free.x1 = gos9vh;
            return gos9vh.Apply<Closure, Closure>(vs9ve);
        }
        public static Closure gos9vh_Entry(in (Closure x0, Closure x1) go_Frees9vh, Closure dss9vi)
        {
            var yss9vg = go_Frees9vh.x0;
            var gos9vh = go_Frees9vh.x1;
            var wilds9vj = dss9vi.Eval();
            switch (wilds9vj)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vj_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9vj_Cons:
                    {
                        var ys9vk = wilds9vj_Cons.x0;
                        var yss9vl = wilds9vj_Cons.x1;
                        var z_Frees9vm = (gos9vh, yss9vl);
                        var zs9vm = new Updatable<(Closure x0, Closure x1)>(&zs9vm_Entry, z_Frees9vm);
                        var go_Frees9vn = (ys9vk, zs9vm, (Closure)null);
                        var gos9vn = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9vn_Entry, go_Frees9vn);
                        gos9vn.free.x2 = gos9vn;
                        return gos9vn.Apply<Closure, Closure>(yss9vg);
                    }
            }
        }
        public static Closure gos9vn_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9vn, Closure dss9vo)
        {
            var ys9vk = go_Frees9vn.x0;
            var zs9vm = go_Frees9vn.x1;
            var gos9vn = go_Frees9vn.x2;
            var wilds9vp = dss9vo.Eval();
            switch (wilds9vp)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9vp_Nil: { return zs9vm.Eval(); }
                case GHC.Types.Cons wilds9vp_Cons:
                    {
                        var ys9vq = wilds9vp_Cons.x0;
                        var yss9vr = wilds9vp_Cons.x1;
                        var sat_Frees9vt = (gos9vn, yss9vr);
                        var sats9vt = new Updatable<(Closure x0, Closure x1)>(&sats9vt_Entry, sat_Frees9vt);
                        var sats9vs = new GHC.Types.Cons(ys9vk, ys9vq);
                        return new GHC.Types.Cons(sats9vs, sats9vt);
                    }
            }
        }
        public static Closure sats9vt_Entry(in (Closure x0, Closure x1) sat_Frees9vt)
        {
            var gos9vn = sat_Frees9vt.x0;
            var yss9vr = sat_Frees9vt.x1;
            return gos9vn.Apply<Closure, Closure>(yss9vr);
        }
        public static Closure zs9vm_Entry(in (Closure x0, Closure x1) z_Frees9vm)
        {
            var gos9vh = z_Frees9vm.x0;
            var yss9vl = z_Frees9vm.x1;
            return gos9vh.Apply<Closure, Closure>(yss9vl);
        }
        public static Closure yss9vg_Entry(in Closure some_vs9vf)
        {
            return poly_gos9v7_Entry(some_vs9vf);
        }
        public static Closure poly_gos9v7_Entry(Closure dss9v8)
        {
            var wilds9v9 = dss9v8.Eval();
            switch (wilds9v9)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9v9_Nil: { return lvls9v6.Eval(); }
                case GHC.Types.Cons wilds9v9_Cons:
                    {
                        var ys9va = wilds9v9_Cons.x0;
                        var yss9vb = wilds9v9_Cons.x1;
                        var sats9vc = new Updatable<Closure>(&sats9vc_Entry, yss9vb);
                        return new GHC.Types.Cons(ys9va, sats9vc);
                    }
            }
        }
        public static Closure sats9vc_Entry(in Closure yss9vb)
        {
            return poly_gos9v7_Entry(yss9vb);
        }
        public static Closure eqLtLt_Entry(Closure dMonads9v3, Closure fs9v4, Closure xs9v5)
        {
            return GHC.Base.gtGtEq_Entry(dMonads9v3).Apply<Closure, Closure, Closure>(xs9v5, fs9v4);
        }
        public static Closure sEqLtLts9uZ_Entry(Closure fs9v0, Closure xs9v1)
        {
            return cGtGtEqs9no_Entry(xs9v1, fs9v0);
        }
        public static Closure cLtAstrs9uW_Entry(Closure etaB2, Closure etaB1)
        {
            return cliftA2s9ml_Entry(GHC.Base.@const, etaB2, etaB1);
        }
        public static Closure cLtDolls9uQ_Entry(Closure xs9uR, Closure etas9uS)
        {
            var sats9uU = new Fun1<Closure, Closure, Closure>(&sats9uU_Entry, xs9uR);
            return map_Entry(sats9uU, etas9uS);
        }
        public static Closure sats9uU_Entry(in Closure xs9uR, Closure dss9uT)
        {
            return xs9uR.Eval();
        }
        public static Closure dmLtDoll_Entry(Closure dFunctors9uM, Closure etas9uN)
        {
            var sats9uP = new Fun1<Closure, Closure, Closure>(&sats9uP_Entry, etas9uN);
            return GHC.Base.fmap_Entry(dFunctors9uM).Apply<Closure, Closure>(sats9uP);
        }
        public static Closure sats9uP_Entry(in Closure etas9uN, Closure dss9uO)
        {
            return etas9uN.Eval();
        }
        public static Closure fMonoidDashGt_Entry(Closure dMonoids9uE)
        {
            var lvls9uF = new Updatable<Closure>(&lvls9uF_Entry, dMonoids9uE);
            var sats9uK = new Fun2<Closure, Closure, Closure, Closure>(&sats9uK_Entry, dMonoids9uE);
            var sats9uJ = new Fun3<Closure, Closure, Closure, Closure, Closure>(&sats9uJ_Entry, dMonoids9uE);
            var sats9uI = new Fun1<Closure, Closure, Closure>(&sats9uI_Entry, lvls9uF);
            var sats9uG = new Fun3<Closure, Closure, Closure, Closure, Closure>(&sats9uG_Entry, dMonoids9uE);
            return new GHC.Base.CColMonoid(sats9uG, sats9uI, sats9uJ, sats9uK);
        }
        public static Closure sats9uG_Entry(in Closure dMonoids9uE, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jh_Entry(dMonoids9uE, etaB3, etaB2, etaB1);
        }
        public static Closure sats9uI_Entry(in Closure lvls9uF, Closure dss9uH)
        {
            return lvls9uF.Eval();
        }
        public static Closure sats9uJ_Entry(in Closure dMonoids9uE, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cp1Monoids9jh_Entry(dMonoids9uE, etaB3, etaB2, etaB1);
        }
        public static Closure sats9uK_Entry(in Closure dMonoids9uE, Closure etaB2, Closure etaB1)
        {
            return cmconcats9uq_Entry(dMonoids9uE, etaB2, etaB1);
        }
        public static Closure lvls9uF_Entry(in Closure dMonoids9uE)
        {
            return GHC.Base.mempty_Entry(dMonoids9uE);
        }
        public static Closure cmconcats9uq_Entry(Closure dMonoids9ur, Closure etas9us, Closure etas9ut)
        {
            var lvls9uu = new Updatable<Closure>(&lvls9uu_Entry, dMonoids9ur);
            var go_Frees9uv = (dMonoids9ur, lvls9uu, (Closure)null);
            var gos9uv = new Fun2<(Closure x0, Closure x1, Closure x2), Closure, Closure, Closure>(&gos9uv_Entry, go_Frees9uv);
            gos9uv.free.x2 = gos9uv;
            return gos9uv.Apply<Closure, Closure, Closure>(etas9us, etas9ut);
        }
        public static Closure gos9uv_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9uv, Closure dss9uw, Closure etas9ux)
        {
            var dMonoids9ur = go_Frees9uv.x0;
            var lvls9uu = go_Frees9uv.x1;
            var gos9uv = go_Frees9uv.x2;
            var wilds9uy = dss9uw.Eval();
            switch (wilds9uy)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9uy_Nil: { return lvls9uu.Eval(); }
                case GHC.Types.Cons wilds9uy_Cons:
                    {
                        var ys9uz = wilds9uy_Cons.x0;
                        var yss9uA = wilds9uy_Cons.x1;
                        var sat_Frees9uC = (gos9uv, etas9ux, yss9uA);
                        var sats9uC = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9uC_Entry, sat_Frees9uC);
                        var sat_Frees9uB = (etas9ux, ys9uz);
                        var sats9uB = new Updatable<(Closure x0, Closure x1)>(&sats9uB_Entry, sat_Frees9uB);
                        return GHC.Base.p1Monoid_Entry(dMonoids9ur).Apply<Closure, Closure, Closure>(sats9uB, sats9uC);
                    }
            }
        }
        public static Closure sats9uB_Entry(in (Closure x0, Closure x1) sat_Frees9uB)
        {
            var etas9ux = sat_Frees9uB.x0;
            var ys9uz = sat_Frees9uB.x1;
            return ys9uz.Apply<Closure, Closure>(etas9ux);
        }
        public static Closure sats9uC_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9uC)
        {
            var gos9uv = sat_Frees9uC.x0;
            var etas9ux = sat_Frees9uC.x1;
            var yss9uA = sat_Frees9uC.x2;
            return gos9uv.Apply<Closure, Closure, Closure>(yss9uA, etas9ux);
        }
        public static Closure lvls9uu_Entry(in Closure dMonoids9ur)
        {
            return GHC.Base.mempty_Entry(dMonoids9ur);
        }
        public static Closure fMonoidPrOComPrC_Entry(Closure dMonoids9uk, Closure dMonoids9ul)
        {
            var sat_Frees9up = (dMonoids9uk, dMonoids9ul);
            var sats9up = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9up_Entry, sat_Frees9up);
            var sat_Frees9uo = (dMonoids9uk, dMonoids9ul);
            var sats9uo = new Fun2<(Closure x0, Closure x1), Closure, Closure, Closure>(&sats9uo_Entry, sat_Frees9uo);
            var sat_Frees9un = (dMonoids9uk, dMonoids9ul);
            var sats9un = new Updatable<(Closure x0, Closure x1)>(&sats9un_Entry, sat_Frees9un);
            var sat_Frees9um = (dMonoids9uk, dMonoids9ul);
            var sats9um = new Fun2<(Closure x0, Closure x1), Closure, Closure, Closure>(&sats9um_Entry, sat_Frees9um);
            return new GHC.Base.CColMonoid(sats9um, sats9un, sats9uo, sats9up);
        }
        public static Closure sats9um_Entry(in (Closure x0, Closure x1) sat_Frees9um, Closure etaB2, Closure etaB1)
        {
            var dMonoids9uk = sat_Frees9um.x0;
            var dMonoids9ul = sat_Frees9um.x1;
            return cp1Monoids9jv_Entry(dMonoids9uk, dMonoids9ul, etaB2, etaB1);
        }
        public static Closure sats9un_Entry(in (Closure x0, Closure x1) sat_Frees9un)
        {
            var dMonoids9uk = sat_Frees9un.x0;
            var dMonoids9ul = sat_Frees9un.x1;
            return cmemptys9jq_Entry(dMonoids9uk, dMonoids9ul);
        }
        public static Closure sats9uo_Entry(in (Closure x0, Closure x1) sat_Frees9uo, Closure etaB2, Closure etaB1)
        {
            var dMonoids9uk = sat_Frees9uo.x0;
            var dMonoids9ul = sat_Frees9uo.x1;
            return cp1Monoids9jv_Entry(dMonoids9uk, dMonoids9ul, etaB2, etaB1);
        }
        public static Closure sats9up_Entry(in (Closure x0, Closure x1) sat_Frees9up, Closure etaB1)
        {
            var dMonoids9uk = sat_Frees9up.x0;
            var dMonoids9ul = sat_Frees9up.x1;
            return cmconcats9tZ_Entry(dMonoids9uk, dMonoids9ul, etaB1);
        }
        public static Closure cmconcats9tZ_Entry(Closure dMonoids9u0, Closure dMonoids9u1, Closure etas9u2)
        {
            var zs9u3 = new Updatable<Closure>(&zs9u3_Entry, dMonoids9u0);
            var zs9u4 = new Updatable<Closure>(&zs9u4_Entry, dMonoids9u1);
            var zs9u5 = new GHC.Tuple.Tuple2(zs9u3, zs9u4);
            var go_Frees9u6 = (dMonoids9u0, dMonoids9u1, zs9u5, (Closure)null);
            var gos9u6 = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&gos9u6_Entry, go_Frees9u6);
            gos9u6.free.x3 = gos9u6;
            return gos9u6.Apply<Closure, Closure>(etas9u2);
        }
        public static Closure gos9u6_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) go_Frees9u6, Closure dss9u7)
        {
            var dMonoids9u0 = go_Frees9u6.x0;
            var dMonoids9u1 = go_Frees9u6.x1;
            var zs9u5 = go_Frees9u6.x2;
            var gos9u6 = go_Frees9u6.x3;
            var wilds9u8 = dss9u7.Eval();
            switch (wilds9u8)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9u8_Nil: { return zs9u5.Eval(); }
                case GHC.Types.Cons wilds9u8_Cons:
                    {
                        var ys9u9 = wilds9u8_Cons.x0;
                        var yss9ua = wilds9u8_Cons.x1;
                        var wilds9ub = ys9u9.Eval();
                        var wilds9ub_Tuple2 = wilds9ub as GHC.Tuple.Tuple2;
                        var as9uc = wilds9ub_Tuple2.x0;
                        var bs9ud = wilds9ub_Tuple2.x1;
                        var wilds9ue = gos9u6.Apply<Closure, Closure>(yss9ua);
                        var wilds9ue_Tuple2 = wilds9ue as GHC.Tuple.Tuple2;
                        var a_s9uf = wilds9ue_Tuple2.x0;
                        var b_s9ug = wilds9ue_Tuple2.x1;
                        var sat_Frees9ui = (dMonoids9u1, bs9ud, b_s9ug);
                        var sats9ui = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9ui_Entry, sat_Frees9ui);
                        var sat_Frees9uh = (dMonoids9u0, as9uc, a_s9uf);
                        var sats9uh = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9uh_Entry, sat_Frees9uh);
                        return new GHC.Tuple.Tuple2(sats9uh, sats9ui);
                    }
            }
        }
        public static Closure sats9uh_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9uh)
        {
            var dMonoids9u0 = sat_Frees9uh.x0;
            var as9uc = sat_Frees9uh.x1;
            var a_s9uf = sat_Frees9uh.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9u0).Apply<Closure, Closure, Closure>(as9uc, a_s9uf);
        }
        public static Closure sats9ui_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9ui)
        {
            var dMonoids9u1 = sat_Frees9ui.x0;
            var bs9ud = sat_Frees9ui.x1;
            var b_s9ug = sat_Frees9ui.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9u1).Apply<Closure, Closure, Closure>(bs9ud, b_s9ug);
        }
        public static Closure zs9u4_Entry(in Closure dMonoids9u1)
        {
            return GHC.Base.mempty_Entry(dMonoids9u1);
        }
        public static Closure zs9u3_Entry(in Closure dMonoids9u0)
        {
            return GHC.Base.mempty_Entry(dMonoids9u0);
        }
        public static Closure fMonoidPrOComComPrC_Entry(Closure dMonoids9tS, Closure dMonoids9tT, Closure dMonoids9tU)
        {
            var sat_Frees9tY = (dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tY = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&sats9tY_Entry, sat_Frees9tY);
            var sat_Frees9tX = (dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tX = new Fun2<(Closure x0, Closure x1, Closure x2), Closure, Closure, Closure>(&sats9tX_Entry, sat_Frees9tX);
            var sat_Frees9tW = (dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tW = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9tW_Entry, sat_Frees9tW);
            var sat_Frees9tV = (dMonoids9tS, dMonoids9tT, dMonoids9tU);
            var sats9tV = new Fun2<(Closure x0, Closure x1, Closure x2), Closure, Closure, Closure>(&sats9tV_Entry, sat_Frees9tV);
            return new GHC.Base.CColMonoid(sats9tV, sats9tW, sats9tX, sats9tY);
        }
        public static Closure sats9tV_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tV, Closure etaB2, Closure etaB1)
        {
            var dMonoids9tS = sat_Frees9tV.x0;
            var dMonoids9tT = sat_Frees9tV.x1;
            var dMonoids9tU = sat_Frees9tV.x2;
            return cp1Monoids9jP_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB2, etaB1);
        }
        public static Closure sats9tW_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tW)
        {
            var dMonoids9tS = sat_Frees9tW.x0;
            var dMonoids9tT = sat_Frees9tW.x1;
            var dMonoids9tU = sat_Frees9tW.x2;
            return cmemptys9jI_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU);
        }
        public static Closure sats9tX_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tX, Closure etaB2, Closure etaB1)
        {
            var dMonoids9tS = sat_Frees9tX.x0;
            var dMonoids9tT = sat_Frees9tX.x1;
            var dMonoids9tU = sat_Frees9tX.x2;
            return cp1Monoids9jP_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB2, etaB1);
        }
        public static Closure sats9tY_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tY, Closure etaB1)
        {
            var dMonoids9tS = sat_Frees9tY.x0;
            var dMonoids9tT = sat_Frees9tY.x1;
            var dMonoids9tU = sat_Frees9tY.x2;
            return cmconcats9ts_Entry(dMonoids9tS, dMonoids9tT, dMonoids9tU, etaB1);
        }
        public static Closure cmconcats9ts_Entry(Closure dMonoids9tt, Closure dMonoids9tu, Closure dMonoids9tv, Closure etas9tw)
        {
            var zs9tx = new Updatable<Closure>(&zs9tx_Entry, dMonoids9tt);
            var zs9ty = new Updatable<Closure>(&zs9ty_Entry, dMonoids9tu);
            var zs9tz = new Updatable<Closure>(&zs9tz_Entry, dMonoids9tv);
            var zs9tA = new GHC.Tuple.Tuple3(zs9tx, zs9ty, zs9tz);
            var go_Frees9tB = (dMonoids9tt, dMonoids9tu, dMonoids9tv, zs9tA, (Closure)null);
            var gos9tB = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&gos9tB_Entry, go_Frees9tB);
            gos9tB.free.x4 = gos9tB;
            return gos9tB.Apply<Closure, Closure>(etas9tw);
        }
        public static Closure gos9tB_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) go_Frees9tB, Closure dss9tC)
        {
            var dMonoids9tt = go_Frees9tB.x0;
            var dMonoids9tu = go_Frees9tB.x1;
            var dMonoids9tv = go_Frees9tB.x2;
            var zs9tA = go_Frees9tB.x3;
            var gos9tB = go_Frees9tB.x4;
            var wilds9tD = dss9tC.Eval();
            switch (wilds9tD)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9tD_Nil: { return zs9tA.Eval(); }
                case GHC.Types.Cons wilds9tD_Cons:
                    {
                        var ys9tE = wilds9tD_Cons.x0;
                        var yss9tF = wilds9tD_Cons.x1;
                        var wws9tG = ys9tE.Eval();
                        var wws9tG_Tuple3 = wws9tG as GHC.Tuple.Tuple3;
                        var wws9tH = wws9tG_Tuple3.x0;
                        var wws9tI = wws9tG_Tuple3.x1;
                        var wws9tJ = wws9tG_Tuple3.x2;
                        var wws9tK = gos9tB.Apply<Closure, Closure>(yss9tF);
                        var wws9tK_Tuple3 = wws9tK as GHC.Tuple.Tuple3;
                        var wws9tL = wws9tK_Tuple3.x0;
                        var wws9tM = wws9tK_Tuple3.x1;
                        var wws9tN = wws9tK_Tuple3.x2;
                        var sat_Frees9tQ = (dMonoids9tv, wws9tJ, wws9tN);
                        var sats9tQ = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9tQ_Entry, sat_Frees9tQ);
                        var sat_Frees9tP = (dMonoids9tu, wws9tI, wws9tM);
                        var sats9tP = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9tP_Entry, sat_Frees9tP);
                        var sat_Frees9tO = (dMonoids9tt, wws9tH, wws9tL);
                        var sats9tO = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9tO_Entry, sat_Frees9tO);
                        return new GHC.Tuple.Tuple3(sats9tO, sats9tP, sats9tQ);
                    }
            }
        }
        public static Closure sats9tO_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tO)
        {
            var dMonoids9tt = sat_Frees9tO.x0;
            var wws9tH = sat_Frees9tO.x1;
            var wws9tL = sat_Frees9tO.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9tt).Apply<Closure, Closure, Closure>(wws9tH, wws9tL);
        }
        public static Closure sats9tP_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tP)
        {
            var dMonoids9tu = sat_Frees9tP.x0;
            var wws9tI = sat_Frees9tP.x1;
            var wws9tM = sat_Frees9tP.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9tu).Apply<Closure, Closure, Closure>(wws9tI, wws9tM);
        }
        public static Closure sats9tQ_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9tQ)
        {
            var dMonoids9tv = sat_Frees9tQ.x0;
            var wws9tJ = sat_Frees9tQ.x1;
            var wws9tN = sat_Frees9tQ.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9tv).Apply<Closure, Closure, Closure>(wws9tJ, wws9tN);
        }
        public static Closure zs9tz_Entry(in Closure dMonoids9tv)
        {
            return GHC.Base.mempty_Entry(dMonoids9tv);
        }
        public static Closure zs9ty_Entry(in Closure dMonoids9tu)
        {
            return GHC.Base.mempty_Entry(dMonoids9tu);
        }
        public static Closure zs9tx_Entry(in Closure dMonoids9tt)
        {
            return GHC.Base.mempty_Entry(dMonoids9tt);
        }
        public static Closure fMonoidPrOComComComPrC_Entry(Closure dMonoids9tk, Closure dMonoids9tl, Closure dMonoids9tm, Closure dMonoids9tn)
        {
            var sat_Frees9tr = (dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9tr = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&sats9tr_Entry, sat_Frees9tr);
            var sat_Frees9tq = (dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9tq = new Fun2<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure, Closure>(&sats9tq_Entry, sat_Frees9tq);
            var sat_Frees9tp = (dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9tp = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3)>(&sats9tp_Entry, sat_Frees9tp);
            var sat_Frees9to = (dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
            var sats9to = new Fun2<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure, Closure>(&sats9to_Entry, sat_Frees9to);
            return new GHC.Base.CColMonoid(sats9to, sats9tp, sats9tq, sats9tr);
        }
        public static Closure sats9to_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9to, Closure etaB2, Closure etaB1)
        {
            var dMonoids9tk = sat_Frees9to.x0;
            var dMonoids9tl = sat_Frees9to.x1;
            var dMonoids9tm = sat_Frees9to.x2;
            var dMonoids9tn = sat_Frees9to.x3;
            return cp1Monoids9kf_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB2, etaB1);
        }
        public static Closure sats9tp_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9tp)
        {
            var dMonoids9tk = sat_Frees9tp.x0;
            var dMonoids9tl = sat_Frees9tp.x1;
            var dMonoids9tm = sat_Frees9tp.x2;
            var dMonoids9tn = sat_Frees9tp.x3;
            return cmemptys9k6_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn);
        }
        public static Closure sats9tq_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9tq, Closure etaB2, Closure etaB1)
        {
            var dMonoids9tk = sat_Frees9tq.x0;
            var dMonoids9tl = sat_Frees9tq.x1;
            var dMonoids9tm = sat_Frees9tq.x2;
            var dMonoids9tn = sat_Frees9tq.x3;
            return cp1Monoids9kf_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB2, etaB1);
        }
        public static Closure sats9tr_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) sat_Frees9tr, Closure etaB1)
        {
            var dMonoids9tk = sat_Frees9tr.x0;
            var dMonoids9tl = sat_Frees9tr.x1;
            var dMonoids9tm = sat_Frees9tr.x2;
            var dMonoids9tn = sat_Frees9tr.x3;
            return cmconcats9t2_Entry(dMonoids9tk, dMonoids9tl, dMonoids9tm, dMonoids9tn, etaB1);
        }
        public static Closure cmconcats9t2_Entry(Closure dMonoids9t3, Closure dMonoids9t4, Closure dMonoids9t5, Closure dMonoids9t6, Closure etas9t7)
        {
            var zs9t8 = new Updatable<Closure>(&zs9t8_Entry, dMonoids9t3);
            var zs9t9 = new Updatable<Closure>(&zs9t9_Entry, dMonoids9t4);
            var zs9ta = new Updatable<Closure>(&zs9ta_Entry, dMonoids9t5);
            var zs9tb = new Updatable<Closure>(&zs9tb_Entry, dMonoids9t6);
            var zs9tc = new GHC.Tuple.Tuple4(zs9t8, zs9t9, zs9ta, zs9tb);
            var go_Frees9td = (dMonoids9t3, dMonoids9t4, dMonoids9t5, dMonoids9t6, zs9tc, (Closure)null);
            var gos9td = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5), Closure, Closure>(&gos9td_Entry, go_Frees9td);
            gos9td.free.x5 = gos9td;
            return gos9td.Apply<Closure, Closure>(etas9t7);
        }
        public static Closure gos9td_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5) go_Frees9td, Closure dss9te)
        {
            var dMonoids9t3 = go_Frees9td.x0;
            var dMonoids9t4 = go_Frees9td.x1;
            var dMonoids9t5 = go_Frees9td.x2;
            var dMonoids9t6 = go_Frees9td.x3;
            var zs9tc = go_Frees9td.x4;
            var gos9td = go_Frees9td.x5;
            var wilds9tf = dss9te.Eval();
            switch (wilds9tf)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9tf_Nil: { return zs9tc.Eval(); }
                case GHC.Types.Cons wilds9tf_Cons:
                    {
                        var ys9tg = wilds9tf_Cons.x0;
                        var yss9th = wilds9tf_Cons.x1;
                        var sats9ti = gos9td.Apply<Closure, Closure>(yss9th);
                        return cp1Monoids9kf_Entry(dMonoids9t3, dMonoids9t4, dMonoids9t5, dMonoids9t6, ys9tg, sats9ti);
                    }
            }
        }
        public static Closure zs9tb_Entry(in Closure dMonoids9t6)
        {
            return GHC.Base.mempty_Entry(dMonoids9t6);
        }
        public static Closure zs9ta_Entry(in Closure dMonoids9t5)
        {
            return GHC.Base.mempty_Entry(dMonoids9t5);
        }
        public static Closure zs9t9_Entry(in Closure dMonoids9t4)
        {
            return GHC.Base.mempty_Entry(dMonoids9t4);
        }
        public static Closure zs9t8_Entry(in Closure dMonoids9t3)
        {
            return GHC.Base.mempty_Entry(dMonoids9t3);
        }
        public static Closure fMonoidPrOComComComComPrC_Entry(Closure dMonoids9sT, Closure dMonoids9sU, Closure dMonoids9sV, Closure dMonoids9sW, Closure dMonoids9sX)
        {
            var sat_Frees9t1 = (dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9t1 = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure>(&sats9t1_Entry, sat_Frees9t1);
            var sat_Frees9t0 = (dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9t0 = new Fun2<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure, Closure>(&sats9t0_Entry, sat_Frees9t0);
            var sat_Frees9sZ = (dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9sZ = new Updatable<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)>(&sats9sZ_Entry, sat_Frees9sZ);
            var sat_Frees9sY = (dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
            var sats9sY = new Fun2<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4), Closure, Closure, Closure>(&sats9sY_Entry, sat_Frees9sY);
            return new GHC.Base.CColMonoid(sats9sY, sats9sZ, sats9t0, sats9t1);
        }
        public static Closure sats9sY_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9sY, Closure etaB2, Closure etaB1)
        {
            var dMonoids9sT = sat_Frees9sY.x0;
            var dMonoids9sU = sat_Frees9sY.x1;
            var dMonoids9sV = sat_Frees9sY.x2;
            var dMonoids9sW = sat_Frees9sY.x3;
            var dMonoids9sX = sat_Frees9sY.x4;
            return cp1Monoids9kL_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB2, etaB1);
        }
        public static Closure sats9sZ_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9sZ)
        {
            var dMonoids9sT = sat_Frees9sZ.x0;
            var dMonoids9sU = sat_Frees9sZ.x1;
            var dMonoids9sV = sat_Frees9sZ.x2;
            var dMonoids9sW = sat_Frees9sZ.x3;
            var dMonoids9sX = sat_Frees9sZ.x4;
            return cmemptys9kA_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX);
        }
        public static Closure sats9t0_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9t0, Closure etaB2, Closure etaB1)
        {
            var dMonoids9sT = sat_Frees9t0.x0;
            var dMonoids9sU = sat_Frees9t0.x1;
            var dMonoids9sV = sat_Frees9t0.x2;
            var dMonoids9sW = sat_Frees9t0.x3;
            var dMonoids9sX = sat_Frees9t0.x4;
            return cp1Monoids9kL_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB2, etaB1);
        }
        public static Closure sats9t1_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4) sat_Frees9t1, Closure etaB1)
        {
            var dMonoids9sT = sat_Frees9t1.x0;
            var dMonoids9sU = sat_Frees9t1.x1;
            var dMonoids9sV = sat_Frees9t1.x2;
            var dMonoids9sW = sat_Frees9t1.x3;
            var dMonoids9sX = sat_Frees9t1.x4;
            return cmconcats9sz_Entry(dMonoids9sT, dMonoids9sU, dMonoids9sV, dMonoids9sW, dMonoids9sX, etaB1);
        }
        public static Closure cmconcats9sz_Entry(Closure dMonoids9sA, Closure dMonoids9sB, Closure dMonoids9sC, Closure dMonoids9sD, Closure dMonoids9sE, Closure etas9sF)
        {
            var zs9sG = new Updatable<Closure>(&zs9sG_Entry, dMonoids9sA);
            var zs9sH = new Updatable<Closure>(&zs9sH_Entry, dMonoids9sB);
            var zs9sI = new Updatable<Closure>(&zs9sI_Entry, dMonoids9sC);
            var zs9sJ = new Updatable<Closure>(&zs9sJ_Entry, dMonoids9sD);
            var zs9sK = new Updatable<Closure>(&zs9sK_Entry, dMonoids9sE);
            var zs9sL = new GHC.Tuple.Tuple5(zs9sG, zs9sH, zs9sI, zs9sJ, zs9sK);
            var go_Frees9sM = (dMonoids9sA, dMonoids9sB, dMonoids9sC, dMonoids9sD, dMonoids9sE, zs9sL, (Closure)null);
            var gos9sM = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5, Closure x6), Closure, Closure>(&gos9sM_Entry, go_Frees9sM);
            gos9sM.free.x6 = gos9sM;
            return gos9sM.Apply<Closure, Closure>(etas9sF);
        }
        public static Closure gos9sM_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5, Closure x6) go_Frees9sM, Closure dss9sN)
        {
            var dMonoids9sA = go_Frees9sM.x0;
            var dMonoids9sB = go_Frees9sM.x1;
            var dMonoids9sC = go_Frees9sM.x2;
            var dMonoids9sD = go_Frees9sM.x3;
            var dMonoids9sE = go_Frees9sM.x4;
            var zs9sL = go_Frees9sM.x5;
            var gos9sM = go_Frees9sM.x6;
            var wilds9sO = dss9sN.Eval();
            switch (wilds9sO)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9sO_Nil: { return zs9sL.Eval(); }
                case GHC.Types.Cons wilds9sO_Cons:
                    {
                        var ys9sP = wilds9sO_Cons.x0;
                        var yss9sQ = wilds9sO_Cons.x1;
                        var sats9sR = gos9sM.Apply<Closure, Closure>(yss9sQ);
                        return cp1Monoids9kL_Entry(dMonoids9sA, dMonoids9sB, dMonoids9sC, dMonoids9sD, dMonoids9sE, ys9sP, sats9sR);
                    }
            }
        }
        public static Closure zs9sK_Entry(in Closure dMonoids9sE)
        {
            return GHC.Base.mempty_Entry(dMonoids9sE);
        }
        public static Closure zs9sJ_Entry(in Closure dMonoids9sD)
        {
            return GHC.Base.mempty_Entry(dMonoids9sD);
        }
        public static Closure zs9sI_Entry(in Closure dMonoids9sC)
        {
            return GHC.Base.mempty_Entry(dMonoids9sC);
        }
        public static Closure zs9sH_Entry(in Closure dMonoids9sB)
        {
            return GHC.Base.mempty_Entry(dMonoids9sB);
        }
        public static Closure zs9sG_Entry(in Closure dMonoids9sA)
        {
            return GHC.Base.mempty_Entry(dMonoids9sA);
        }
        public static Closure gos9ss_Entry(Closure dss9st)
        {
            var wilds9su = dss9st.Eval();
            switch (wilds9su)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9su_Nil:
                    {
                        return GHC.Types.eQ_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9su_Cons:
                    {
                        var ys9sv = wilds9su_Cons.x0;
                        var yss9sw = wilds9su_Cons.x1;
                        var wilds9sx = ys9sv.Eval();
                        var wilds9sxTags9sx = wilds9sx.Tag;
                        switch (wilds9sxTags9sx)
                        {
                            default: { throw new ImpossibleException(); }
                            case 1:
                                {
                                    var wilds9sx_LT = wilds9sx as GHC.Types.LT;
                                    return GHC.Types.lT_DataCon.Eval();
                                }
                            case 2:
                                {
                                    var wilds9sx_EQ = wilds9sx as GHC.Types.EQ;
                                    return gos9ss_Entry(yss9sw);
                                }
                            case 3:
                                {
                                    var wilds9sx_GT = wilds9sx as GHC.Types.GT;
                                    return GHC.Types.gT_DataCon.Eval();
                                }
                        }
                    }
            }
        }
        public static Closure fMonoidMaybe_Entry(Closure dSemigroups9so)
        {
            var sats9sr = new Fun1<Closure, Closure, Closure>(&sats9sr_Entry, dSemigroups9so);
            var sats9sq = new Fun2<Closure, Closure, Closure, Closure>(&sats9sq_Entry, dSemigroups9so);
            var sats9sp = new Fun2<Closure, Closure, Closure, Closure>(&sats9sp_Entry, dSemigroups9so);
            return new GHC.Base.CColMonoid(sats9sp, GHC.Maybe.nothing_DataCon, sats9sq, sats9sr);
        }
        public static Closure sats9sp_Entry(in Closure dSemigroups9so, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(dSemigroups9so, etaB2, etaB1);
        }
        public static Closure sats9sq_Entry(in Closure dSemigroups9so, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(dSemigroups9so, etaB2, etaB1);
        }
        public static Closure sats9sr_Entry(in Closure dSemigroups9so, Closure etaB1)
        {
            return cmconcats9sa_Entry(dSemigroups9so, etaB1);
        }
        public static Closure cmconcats9sa_Entry(Closure dSemigroups9sb, Closure etas9sc)
        {
            var go_Frees9sd = (dSemigroups9sb, (Closure)null);
            var gos9sd = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9sd_Entry, go_Frees9sd);
            gos9sd.free.x1 = gos9sd;
            return gos9sd.Apply<Closure, Closure>(etas9sc);
        }
        public static Closure gos9sd_Entry(in (Closure x0, Closure x1) go_Frees9sd, Closure dss9se)
        {
            var dSemigroups9sb = go_Frees9sd.x0;
            var gos9sd = go_Frees9sd.x1;
            var wilds9sf = dss9se.Eval();
            switch (wilds9sf)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9sf_Nil:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9sf_Cons:
                    {
                        var ys9sg = wilds9sf_Cons.x0;
                        var yss9sh = wilds9sf_Cons.x1;
                        var wilds9si = ys9sg.Eval();
                        switch (wilds9si)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9si_Nothing:
                                {
                                    return gos9sd.Apply<Closure, Closure>(yss9sh);
                                }
                            case GHC.Maybe.Just wilds9si_Just:
                                {
                                    var ipvs9sj = wilds9si_Just.x0;
                                    var wilds9sk = gos9sd.Apply<Closure, Closure>(yss9sh);
                                    switch (wilds9sk)
                                    {
                                        default: { throw new ImpossibleException(); }
                                        case GHC.Maybe.Nothing wilds9sk_Nothing:
                                            {
                                                return wilds9si.Eval();
                                            }
                                        case GHC.Maybe.Just wilds9sk_Just:
                                            {
                                                var ipvs9sl = wilds9sk_Just.x0;
                                                var sat_Frees9sm = (dSemigroups9sb, ipvs9sj, ipvs9sl);
                                                var sats9sm = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9sm_Entry, sat_Frees9sm);
                                                return new GHC.Maybe.Just(sats9sm);
                                            }
                                    }
                                }
                        }
                    }
            }
        }
        public static Closure sats9sm_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9sm)
        {
            var dSemigroups9sb = sat_Frees9sm.x0;
            var ipvs9sj = sat_Frees9sm.x1;
            var ipvs9sl = sat_Frees9sm.x2;
            return dSemigroups9sb.Apply<Closure, Closure, Closure>(ipvs9sj, ipvs9sl);
        }
        public static Closure dmmconcat_Entry(Closure dMonoids9s1, Closure etas9s2)
        {
            var zs9s3 = new Updatable<Closure>(&zs9s3_Entry, dMonoids9s1);
            var go_Frees9s4 = (dMonoids9s1, zs9s3, (Closure)null);
            var gos9s4 = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9s4_Entry, go_Frees9s4);
            gos9s4.free.x2 = gos9s4;
            return gos9s4.Apply<Closure, Closure>(etas9s2);
        }
        public static Closure gos9s4_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9s4, Closure dss9s5)
        {
            var dMonoids9s1 = go_Frees9s4.x0;
            var zs9s3 = go_Frees9s4.x1;
            var gos9s4 = go_Frees9s4.x2;
            var wilds9s6 = dss9s5.Eval();
            switch (wilds9s6)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9s6_Nil: { return zs9s3.Eval(); }
                case GHC.Types.Cons wilds9s6_Cons:
                    {
                        var ys9s7 = wilds9s6_Cons.x0;
                        var yss9s8 = wilds9s6_Cons.x1;
                        var sat_Frees9s9 = (gos9s4, yss9s8);
                        var sats9s9 = new Updatable<(Closure x0, Closure x1)>(&sats9s9_Entry, sat_Frees9s9);
                        return GHC.Base.mappend_Entry(dMonoids9s1).Apply<Closure, Closure, Closure>(ys9s7, sats9s9);
                    }
            }
        }
        public static Closure sats9s9_Entry(in (Closure x0, Closure x1) sat_Frees9s9)
        {
            var gos9s4 = sat_Frees9s9.x0;
            var yss9s8 = sat_Frees9s9.x1;
            return gos9s4.Apply<Closure, Closure>(yss9s8);
        }
        public static Closure zs9s3_Entry(in Closure dMonoids9s1)
        {
            return GHC.Base.mempty_Entry(dMonoids9s1);
        }
        public static Closure sequence_Entry(Closure dMonads9rZ, Closure etaB1)
        {
            return mapM_Entry(dMonads9rZ, GHC.Base.id, etaB1);
        }
        public static Closure mapM_Entry(Closure dMonads9rI, Closure etas9rJ, Closure etas9rK)
        {
            var zs9rL = new Updatable<Closure>(&zs9rL_Entry, dMonads9rI);
            var go_Frees9rM = (dMonads9rI, etas9rJ, zs9rL, (Closure)null);
            var gos9rM = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&gos9rM_Entry, go_Frees9rM);
            gos9rM.free.x3 = gos9rM;
            return gos9rM.Apply<Closure, Closure>(etas9rK);
        }
        public static Closure gos9rM_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) go_Frees9rM, Closure dss9rN)
        {
            var dMonads9rI = go_Frees9rM.x0;
            var etas9rJ = go_Frees9rM.x1;
            var zs9rL = go_Frees9rM.x2;
            var gos9rM = go_Frees9rM.x3;
            var wilds9rO = dss9rN.Eval();
            switch (wilds9rO)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rO_Nil: { return zs9rL.Eval(); }
                case GHC.Types.Cons wilds9rO_Cons:
                    {
                        var ys9rP = wilds9rO_Cons.x0;
                        var yss9rQ = wilds9rO_Cons.x1;
                        var r_Frees9rR = (gos9rM, yss9rQ);
                        var rs9rR = new Updatable<(Closure x0, Closure x1)>(&rs9rR_Entry, r_Frees9rR);
                        var sat_Frees9rX = (dMonads9rI, rs9rR);
                        var sats9rX = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9rX_Entry, sat_Frees9rX);
                        var sat_Frees9rS = (etas9rJ, ys9rP);
                        var sats9rS = new Updatable<(Closure x0, Closure x1)>(&sats9rS_Entry, sat_Frees9rS);
                        return GHC.Base.gtGtEq_Entry(dMonads9rI).Apply<Closure, Closure, Closure>(sats9rS, sats9rX);
                    }
            }
        }
        public static Closure sats9rS_Entry(in (Closure x0, Closure x1) sat_Frees9rS)
        {
            var etas9rJ = sat_Frees9rS.x0;
            var ys9rP = sat_Frees9rS.x1;
            return etas9rJ.Apply<Closure, Closure>(ys9rP);
        }
        public static Closure sats9rX_Entry(in (Closure x0, Closure x1) sat_Frees9rX, Closure xs9rT)
        {
            var dMonads9rI = sat_Frees9rX.x0;
            var rs9rR = sat_Frees9rX.x1;
            var sat_Frees9rW = (dMonads9rI, xs9rT);
            var sats9rW = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&sats9rW_Entry, sat_Frees9rW);
            return GHC.Base.gtGtEq_Entry(dMonads9rI).Apply<Closure, Closure, Closure>(rs9rR, sats9rW);
        }
        public static Closure sats9rW_Entry(in (Closure x0, Closure x1) sat_Frees9rW, Closure xss9rU)
        {
            var dMonads9rI = sat_Frees9rW.x0;
            var xs9rT = sat_Frees9rW.x1;
            var sats9rV = new GHC.Types.Cons(xs9rT, xss9rU);
            return GHC.Base.@return_Entry(dMonads9rI).Apply<Closure, Closure>(sats9rV);
        }
        public static Closure rs9rR_Entry(in (Closure x0, Closure x1) r_Frees9rR)
        {
            var gos9rM = r_Frees9rR.x0;
            var yss9rQ = r_Frees9rR.x1;
            return gos9rM.Apply<Closure, Closure>(yss9rQ);
        }
        public static Closure zs9rL_Entry(in Closure dMonads9rI)
        {
            return GHC.Base.@return_Entry(dMonads9rI).Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure fSemigroupBrOBrC_Entry(Closure etaB2, Closure etaB1)
        {
            return plusPlus_Entry(etaB2, etaB1);
        }
        public static Closure plusPlus_Entry(Closure dss9rt, Closure yss9ru)
        {
            var wilds9rv = dss9rt.Eval();
            switch (wilds9rv)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rv_Nil: { return yss9ru.Eval(); }
                case GHC.Types.Cons wilds9rv_Cons:
                    {
                        var xs9rw = wilds9rv_Cons.x0;
                        var xss9rx = wilds9rv_Cons.x1;
                        var sat_Frees9rE = (yss9ru, xss9rx);
                        var sats9rE = new Updatable<(Closure x0, Closure x1)>(&sats9rE_Entry, sat_Frees9rE);
                        return new GHC.Types.Cons(xs9rw, sats9rE);
                    }
            }
        }
        public static Closure plusPlus_DollsPlusPlus_Entry(Closure h, Closure t, Closure xs)
        {
            return plusPlus_Entry(new GHC.Types.Cons(h, t), xs); //TODO check if this works
        }
        public static Closure sats9rE_Entry(in (Closure x0, Closure x1) sat_Frees9rE)
        {
            var yss9ru = sat_Frees9rE.x0;
            var xss9rx = sat_Frees9rE.x1;
            var go_Frees9ry = (yss9ru, (Closure)null);
            var gos9ry = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9ry_Entry, go_Frees9ry);
            gos9ry.free.x1 = gos9ry;
            return gos9ry.Apply<Closure, Closure>(xss9rx);
        }
        public static Closure gos9ry_Entry(in (Closure x0, Closure x1) go_Frees9ry, Closure dss9rz)
        {
            var yss9ru = go_Frees9ry.x0;
            var gos9ry = go_Frees9ry.x1;
            var wilds9rA = dss9rz.Eval();
            switch (wilds9rA)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rA_Nil: { return yss9ru.Eval(); }
                case GHC.Types.Cons wilds9rA_Cons:
                    {
                        var ys9rB = wilds9rA_Cons.x0;
                        var yss9rC = wilds9rA_Cons.x1;
                        var sat_Frees9rD = (gos9ry, yss9rC);
                        var sats9rD = new Updatable<(Closure x0, Closure x1)>(&sats9rD_Entry, sat_Frees9rD);
                        return new GHC.Types.Cons(ys9rB, sats9rD);
                    }
            }
        }
        public static Closure sats9rD_Entry(in (Closure x0, Closure x1) sat_Frees9rD)
        {
            var gos9ry = sat_Frees9rD.x0;
            var yss9rC = sat_Frees9rD.x1;
            return gos9ry.Apply<Closure, Closure>(yss9rC);
        }
        public static Closure map_Entry(Closure dss9rl, Closure dss9rm)
        {
            var wilds9rn = dss9rm.Eval();
            switch (wilds9rn)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rn_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9rn_Cons:
                    {
                        var xs9ro = wilds9rn_Cons.x0;
                        var xss9rp = wilds9rn_Cons.x1;
                        var sat_Frees9rr = (dss9rl, xss9rp);
                        var sats9rr = new Updatable<(Closure x0, Closure x1)>(&sats9rr_Entry, sat_Frees9rr);
                        var sat_Frees9rq = (dss9rl, xs9ro);
                        var sats9rq = new Updatable<(Closure x0, Closure x1)>(&sats9rq_Entry, sat_Frees9rq);
                        return new GHC.Types.Cons(sats9rq, sats9rr);
                    }
            }
        }
        public static Closure sats9rq_Entry(in (Closure x0, Closure x1) sat_Frees9rq)
        {
            var dss9rl = sat_Frees9rq.x0;
            var xs9ro = sat_Frees9rq.x1;
            return dss9rl.Apply<Closure, Closure>(xs9ro);
        }
        public static Closure sats9rr_Entry(in (Closure x0, Closure x1) sat_Frees9rr)
        {
            var dss9rl = sat_Frees9rr.x0;
            var xss9rp = sat_Frees9rr.x1; return map_Entry(dss9rl, xss9rp);
        }
        public static Closure foldr_Entry(Closure ks9rc, Closure zs9rd, Closure etas9re)
        {
            var go_Frees9rf = (ks9rc, zs9rd, (Closure)null);
            var gos9rf = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9rf_Entry, go_Frees9rf);
            gos9rf.free.x2 = gos9rf;
            return gos9rf.Apply<Closure, Closure>(etas9re);
        }
        public static Closure gos9rf_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9rf, Closure dss9rg)
        {
            var ks9rc = go_Frees9rf.x0;
            var zs9rd = go_Frees9rf.x1;
            var gos9rf = go_Frees9rf.x2;
            var wilds9rh = dss9rg.Eval();
            switch (wilds9rh)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9rh_Nil: { return zs9rd.Eval(); }
                case GHC.Types.Cons wilds9rh_Cons:
                    {
                        var ys9ri = wilds9rh_Cons.x0;
                        var yss9rj = wilds9rh_Cons.x1;
                        var sat_Frees9rk = (gos9rf, yss9rj);
                        var sats9rk = new Updatable<(Closure x0, Closure x1)>(&sats9rk_Entry, sat_Frees9rk);
                        return ks9rc.Apply<Closure, Closure, Closure>(ys9ri, sats9rk);
                    }
            }
        }
        public static Closure sats9rk_Entry(in (Closure x0, Closure x1) sat_Frees9rk)
        {
            var gos9rf = sat_Frees9rk.x0;
            var yss9rj = sat_Frees9rk.x1;
            return gos9rf.Apply<Closure, Closure>(yss9rj);
        }
        public static Closure mapFB_Entry(Closure cs9r5, Closure fs9r6, Closure xs9r7, Closure yss9r8)
        {
            var sat_Frees9r9 = (fs9r6, xs9r7);
            var sats9r9 = new Updatable<(Closure x0, Closure x1)>(&sats9r9_Entry, sat_Frees9r9);
            return cs9r5.Apply<Closure, Closure, Closure>(sats9r9, yss9r8);
        }
        public static Closure sats9r9_Entry(in (Closure x0, Closure x1) sat_Frees9r9)
        {
            var fs9r6 = sat_Frees9r9.x0;
            var xs9r7 = sat_Frees9r9.x1;
            return fs9r6.Apply<Closure, Closure>(xs9r7);
        }
        public static Closure dot_Entry(Closure fs9r0, Closure gs9r1, Closure xs9r2)
        {
            var sat_Frees9r3 = (gs9r1, xs9r2);
            var sats9r3 = new Updatable<(Closure x0, Closure x1)>(&sats9r3_Entry, sat_Frees9r3);
            return fs9r0.Apply<Closure, Closure>(sats9r3);
        }
        public static Closure sats9r3_Entry(in (Closure x0, Closure x1) sat_Frees9r3)
        {
            var gs9r1 = sat_Frees9r3.x0;
            var xs9r2 = sat_Frees9r3.x1;
            return gs9r1.Apply<Closure, Closure>(xs9r2);
        }
        public static Closure dmLtAstr_Entry(Closure dApplicatives9qY)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9qY).Apply<Closure, Closure>(GHC.Base.@const);
        }
        public static Closure asTypeOf_Entry(Closure etaB2, Closure etaB1)
        {
            return @const_Entry(etaB2, etaB1);
        }
        public static Closure @const_Entry(Closure xs9qU, Closure dss9qV)
        {
            return xs9qU.Eval();
        }
        public static Closure breakpointCond_Entry(Closure etaB2, Closure etaB1)
        {
            return assert_Entry(etaB2, etaB1);
        }
        public static Closure breakpoint_Entry(Closure etaB1)
        {
            return id_Entry(etaB1);
        }
        public static Closure assert_Entry(Closure _preds9qP, Closure rs9qQ)
        {
            return rs9qQ.Eval();
        }
        public static Closure dmAstrGt_Entry(Closure dApplicatives9qJ, Closure etas9qK, Closure etas9qL)
        {
            var sat_Frees9qN = (dApplicatives9qJ, etas9qK);
            var sats9qN = new Updatable<(Closure x0, Closure x1)>(&sats9qN_Entry, sat_Frees9qN);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9qJ).Apply<Closure, Closure, Closure>(sats9qN, etas9qL);
        }
        public static Closure sats9qN_Entry(in (Closure x0, Closure x1) sat_Frees9qN)
        {
            var dApplicatives9qJ = sat_Frees9qN.x0;
            var etas9qK = sat_Frees9qN.x1;
            var sats9qM = GHC.Base.p1Applicative_Entry(dApplicatives9qJ);
            return GHC.Base.ltDoll_Entry(sats9qM).Apply<Closure, Closure, Closure>(GHC.Base.id, etas9qK);
        }
        public static Closure dmLtAstrGt_Entry(Closure dApplicatives9qH)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9qH).Apply<Closure, Closure>(GHC.Base.id);
        }
        public static Closure join_Entry(Closure dMonads9qE, Closure xs9qF)
        {
            return GHC.Base.gtGtEq_Entry(dMonads9qE).Apply<Closure, Closure, Closure>(xs9qF, GHC.Base.id);
        }
        public static Closure id_Entry(Closure xs9qC)
        {
            return xs9qC.Eval();
        }
        public static Closure ord_Entry(Closure dss9qv)
        {
            var wilds9qw = dss9qv.Eval();
            var wilds9qw_CHash = wilds9qw as GHC.Types.CHash;
            var cHashs9qx = wilds9qw_CHash.x0;
            var sats9qy = (int)cHashs9qx;
            return new GHC.Types.IHash(sats9qy);
        }
        public static Closure unsafeChr_Entry(Closure dss9qq)
        {
            var wilds9qr = dss9qq.Eval();
            var wilds9qr_IHash = wilds9qr as GHC.Types.IHash;
            var iHashs9qs = wilds9qr_IHash.x0;
            var sats9qt = (char)iHashs9qs;
            return new GHC.Types.CHash(sats9qt);
        }
        public static long iShiftRLHash_Entry(long as9qm, long bs9qn)
        {
            var lwilds9qo = (bs9qn >= 64) ? 1 : 0;
            switch (lwilds9qo)
            {
                default: { return (long)(((ulong)as9qm) >> (int)bs9qn); }
                case 1: { return 0; }
            }
        }
        public static long iShiftRAHash_Entry(long etaB2, long etaB1)
        {
            return etaB2 >> (int)etaB1;
        }
        public static long iShiftLHash_Entry(long as9qh, long bs9qi)
        {
            var lwilds9qj = (bs9qi >= 64) ? 1 : 0;
            switch (lwilds9qj)
            {
                default: { return as9qh << (int)bs9qi; }
                case 1: { return 0; }
            }
        }
        public static ulong shiftRLHash_Entry(ulong as9qd, long bs9qe)
        {
            var lwilds9qf = (bs9qe >= 64) ? 1 : 0;
            switch (lwilds9qf)
            {
                default: { return as9qd >> (int)bs9qe; }
                case 1: { return 0UL; }
            }
        }
        public static ulong shiftLHash_Entry(ulong as9q9, long bs9qa)
        {
            var lwilds9qb = (bs9qa >= 64) ? 1 : 0;
            switch (lwilds9qb)
            {
                default: { return as9q9 << (int)bs9qa; }
                case 1: { return 0UL; }
            }
        }
        public static Closure divModInt_Entry(Closure ws9pb, Closure ws9pc)
        {
            var wws9pd = ws9pb.Eval();
            var wws9pd_IHash = wws9pd as GHC.Types.IHash;
            var wws9pe = wws9pd_IHash.x0;
            var wws9pf = ws9pc.Eval();
            var wws9pf_IHash = wws9pf as GHC.Types.IHash;
            var wws9pg = wws9pf_IHash.x0;
            var lwilds9ph = (wws9pe > 0) ? 1 : 0;
            switch (lwilds9ph)
            {
                default:
                    {
                        var lwilds9pi = (wws9pe < 0) ? 1 : 0;
                        switch (lwilds9pi)
                        {
                            default:
                                {
                                    var dss9pj = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                    var dss9pj_RawTuple = dss9pj;
                                    var ipvs9pk = dss9pj_RawTuple.x0;
                                    var ipvs9pl = dss9pj_RawTuple.x1;
                                    var sats9pn = new GHC.Types.IHash(ipvs9pl);
                                    var sats9pm = new GHC.Types.IHash(ipvs9pk);
                                    return new GHC.Tuple.Tuple2(sats9pm, sats9pn);
                                }
                            case 1:
                                {
                                    var lwilds9po = (wws9pg > 0) ? 1 : 0;
                                    switch (lwilds9po)
                                    {
                                        default:
                                            {
                                                var dss9pp = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                var dss9pp_RawTuple = dss9pp;
                                                var ipvs9pq = dss9pp_RawTuple.x0;
                                                var ipvs9pr = dss9pp_RawTuple.x1;
                                                var sats9pt = new GHC.Types.IHash(ipvs9pr);
                                                var sats9ps = new GHC.Types.IHash(ipvs9pq);
                                                return new GHC.Tuple.Tuple2(sats9ps, sats9pt);
                                            }
                                        case 1:
                                            {
                                                var sats9pu = wws9pe + 1;
                                                var dss9pv = (x0: sats9pu / wws9pg, x1: sats9pu % wws9pg);
                                                var dss9pv_RawTuple = dss9pv;
                                                var ipvs9pw = dss9pv_RawTuple.x0;
                                                var ipvs9px = dss9pv_RawTuple.x1;
                                                var sats9pA = ipvs9px + wws9pg;
                                                var sats9pB = sats9pA - 1;
                                                var sats9pC = new GHC.Types.IHash(sats9pB);
                                                var sats9py = ipvs9pw - 1;
                                                var sats9pz = new GHC.Types.IHash(sats9py);
                                                return new GHC.Tuple.Tuple2(sats9pz, sats9pC);
                                            }
                                    }
                                }
                        }
                    }
                case 1:
                    {
                        var lwilds9pD = (wws9pg < 0) ? 1 : 0;
                        switch (lwilds9pD)
                        {
                            default:
                                {
                                    var lwilds9pE = (wws9pe < 0) ? 1 : 0;
                                    switch (lwilds9pE)
                                    {
                                        default:
                                            {
                                                var dss9pF = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                var dss9pF_RawTuple = dss9pF;
                                                var ipvs9pG = dss9pF_RawTuple.x0;
                                                var ipvs9pH = dss9pF_RawTuple.x1;
                                                var sats9pJ = new GHC.Types.IHash(ipvs9pH);
                                                var sats9pI = new GHC.Types.IHash(ipvs9pG);
                                                return new GHC.Tuple.Tuple2(sats9pI, sats9pJ);
                                            }
                                        case 1:
                                            {
                                                var lwilds9pK = (wws9pg > 0) ? 1 : 0;
                                                switch (lwilds9pK)
                                                {
                                                    default:
                                                        {
                                                            var dss9pL = (x0: wws9pe / wws9pg, x1: wws9pe % wws9pg);
                                                            var dss9pL_RawTuple = dss9pL;
                                                            var ipvs9pM = dss9pL_RawTuple.x0;
                                                            var ipvs9pN = dss9pL_RawTuple.x1;
                                                            var sats9pP = new GHC.Types.IHash(ipvs9pN);
                                                            var sats9pO = new GHC.Types.IHash(ipvs9pM);
                                                            return new GHC.Tuple.Tuple2(sats9pO, sats9pP);
                                                        }
                                                    case 1:
                                                        {
                                                            var sats9pQ = wws9pe + 1;
                                                            var dss9pR = (x0: sats9pQ / wws9pg, x1: sats9pQ % wws9pg);
                                                            var dss9pR_RawTuple = dss9pR;
                                                            var ipvs9pS = dss9pR_RawTuple.x0;
                                                            var ipvs9pT = dss9pR_RawTuple.x1;
                                                            var sats9pW = ipvs9pT + wws9pg;
                                                            var sats9pX = sats9pW - 1;
                                                            var sats9pY = new GHC.Types.IHash(sats9pX);
                                                            var sats9pU = ipvs9pS - 1;
                                                            var sats9pV = new GHC.Types.IHash(sats9pU);
                                                            return new GHC.Tuple.Tuple2(sats9pV, sats9pY);
                                                        }
                                                }
                                            }
                                    }
                                }
                            case 1:
                                {
                                    var sats9pZ = wws9pe - 1;
                                    var dss9q0 = (x0: sats9pZ / wws9pg, x1: sats9pZ % wws9pg);
                                    var dss9q0_RawTuple = dss9q0;
                                    var ipvs9q1 = dss9q0_RawTuple.x0;
                                    var ipvs9q2 = dss9q0_RawTuple.x1;
                                    var sats9q5 = ipvs9q2 + wws9pg;
                                    var sats9q6 = sats9q5 + 1;
                                    var sats9q7 = new GHC.Types.IHash(sats9q6);
                                    var sats9q3 = ipvs9q1 - 1;
                                    var sats9q4 = new GHC.Types.IHash(sats9q3);
                                    return new GHC.Tuple.Tuple2(sats9q4, sats9q7);
                                }
                        }
                    }
            }
        }
        public static (long x0, long x1) divModIntHash_Entry(long xHashs9oH, long yHashs9oI)
        {
            var lwilds9oJ = (xHashs9oH > 0) ? 1 : 0;
            switch (lwilds9oJ)
            {
                default:
                    {
                        var lwilds9oK = (xHashs9oH < 0) ? 1 : 0;
                        switch (lwilds9oK)
                        {
                            default:
                                {
                                    return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                }
                            case 1:
                                {
                                    var lwilds9oL = (yHashs9oI > 0) ? 1 : 0;
                                    switch (lwilds9oL)
                                    {
                                        default:
                                            {
                                                return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                            }
                                        case 1:
                                            {
                                                var sats9oM = xHashs9oH + 1;
                                                var dss9oN = (x0: sats9oM / yHashs9oI, x1: sats9oM % yHashs9oI);
                                                var dss9oN_RawTuple = dss9oN;
                                                var ipvs9oO = dss9oN_RawTuple.x0;
                                                var ipvs9oP = dss9oN_RawTuple.x1;
                                                var sats9oR = ipvs9oP + yHashs9oI;
                                                var sats9oS = sats9oR - 1;
                                                var sats9oQ = ipvs9oO - 1; return (sats9oQ, sats9oS);
                                            }
                                    }
                                }
                        }
                    }
                case 1:
                    {
                        var lwilds9oT = (yHashs9oI < 0) ? 1 : 0;
                        switch (lwilds9oT)
                        {
                            default:
                                {
                                    var lwilds9oU = (xHashs9oH < 0) ? 1 : 0;
                                    switch (lwilds9oU)
                                    {
                                        default:
                                            {
                                                return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                            }
                                        case 1:
                                            {
                                                var lwilds9oV = (yHashs9oI > 0) ? 1 : 0;
                                                switch (lwilds9oV)
                                                {
                                                    default:
                                                        {
                                                            return (x0: xHashs9oH / yHashs9oI, x1: xHashs9oH % yHashs9oI);
                                                        }
                                                    case 1:
                                                        {
                                                            var sats9oW = xHashs9oH + 1;
                                                            var dss9oX = (x0: sats9oW / yHashs9oI, x1: sats9oW % yHashs9oI);
                                                            var dss9oX_RawTuple = dss9oX;
                                                            var ipvs9oY = dss9oX_RawTuple.x0;
                                                            var ipvs9oZ = dss9oX_RawTuple.x1;
                                                            var sats9p1 = ipvs9oZ + yHashs9oI;
                                                            var sats9p2 = sats9p1 - 1;
                                                            var sats9p0 = ipvs9oY - 1;
                                                            return (sats9p0, sats9p2);
                                                        }
                                                }
                                            }
                                    }
                                }
                            case 1:
                                {
                                    var sats9p3 = xHashs9oH - 1;
                                    var dss9p4 = (x0: sats9p3 / yHashs9oI, x1: sats9p3 % yHashs9oI);
                                    var dss9p4_RawTuple = dss9p4;
                                    var ipvs9p5 = dss9p4_RawTuple.x0;
                                    var ipvs9p6 = dss9p4_RawTuple.x1;
                                    var sats9p8 = ipvs9p6 + yHashs9oI;
                                    var sats9p9 = sats9p8 + 1;
                                    var sats9p7 = ipvs9p5 - 1; return (sats9p7, sats9p9);
                                }
                        }
                    }
            }
        }
        public static Closure until_Entry(Closure ps9oz, Closure fs9oA, Closure etas9oB)
        {
            var go_Frees9oC = (ps9oz, fs9oA, (Closure)null);
            var gos9oC = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9oC_Entry, go_Frees9oC);
            gos9oC.free.x2 = gos9oC;
            return gos9oC.Apply<Closure, Closure>(etas9oB);
        }
        public static Closure gos9oC_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9oC, Closure xs9oD)
        {
            var ps9oz = go_Frees9oC.x0;
            var fs9oA = go_Frees9oC.x1;
            var gos9oC = go_Frees9oC.x2;
            var wilds9oE = ps9oz.Apply<Closure, Closure>(xs9oD);
            var wilds9oETags9oE = wilds9oE.Tag;
            switch (wilds9oETags9oE)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9oE_False = wilds9oE as GHC.Types.False;
                        var sat_Frees9oF = (fs9oA, xs9oD);
                        var sats9oF = new Updatable<(Closure x0, Closure x1)>(&sats9oF_Entry, sat_Frees9oF);
                        return gos9oC.Apply<Closure, Closure>(sats9oF);
                    }
                case 2:
                    {
                        var wilds9oE_True = wilds9oE as GHC.Types.True;
                        return xs9oD.Eval();
                    }
            }
        }
        public static Closure sats9oF_Entry(in (Closure x0, Closure x1) sat_Frees9oF)
        {
            var fs9oA = sat_Frees9oF.x0;
            var xs9oD = sat_Frees9oF.x1;
            return fs9oA.Apply<Closure, Closure>(xs9oD);
        }
        public static Closure augment_Entry(Closure gs9ov, Closure xss9ow)
        {
            return gs9ov.Apply<Closure, Closure, Closure>(GHC.Types.cons_DataCon, xss9ow);
        }
        public static Closure build_Entry(Closure gs9ot)
        {
            return gs9ot.Apply<Closure, Closure, Closure>(GHC.Types.cons_DataCon, GHC.Types.nil_DataCon);
        }
        public static Closure ltAstrAstrGt_Entry(Closure dApplicatives9or)
        {
            return GHC.Base.liftA2_Entry(dApplicatives9or).Apply<Closure, Closure>(lvls9on);
        }
        public static Closure lvls9on_Entry(Closure as9oo, Closure fs9op)
        {
            return fs9op.Apply<Closure, Closure>(as9oo);
        }
        public static Closure ifThenElse_Entry(Closure dss9oj, Closure xs9ok, Closure ys9ol)
        {
            var wilds9om = dss9oj.Eval();
            var wilds9omTags9om = wilds9om.Tag;
            switch (wilds9omTags9om)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9om_False = wilds9om as GHC.Types.False;
                        return ys9ol.Eval();
                    }
                case 2:
                    {
                        var wilds9om_True = wilds9om as GHC.Types.True;
                        return xs9ok.Eval();
                    }
            }
        }
        public static Closure dmmappend_Entry(Closure etaB1)
        {
            return GHC.Base.p1Monoid_Entry(etaB1);
        }
        public static Closure dmliftA2_Entry(Closure dApplicatives9ob, Closure etas9oc, Closure etas9od)
        {
            var sat_Frees9of = (dApplicatives9ob, etas9oc, etas9od);
            var sats9of = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9of_Entry, sat_Frees9of);
            return GHC.Base.ltAstrGt_Entry(dApplicatives9ob).Apply<Closure, Closure>(sats9of);
        }
        public static Closure sats9of_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9of)
        {
            var dApplicatives9ob = sat_Frees9of.x0;
            var etas9oc = sat_Frees9of.x1;
            var etas9od = sat_Frees9of.x2;
            var sats9oe = GHC.Base.p1Applicative_Entry(dApplicatives9ob);
            return GHC.Base.fmap_Entry(sats9oe).Apply<Closure, Closure, Closure>(etas9oc, etas9od);
        }
        public static Closure dmsome_Entry(Closure dAlternatives9nY, Closure etas9nZ)
        {
            var some_v_Frees9o0 = (dAlternatives9nY, etas9nZ, (Closure)null);
            var some_vs9o0 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&some_vs9o0_Entry, some_v_Frees9o0);
            some_vs9o0.free.x2 = some_vs9o0; return some_vs9o0.Eval();
        }
        public static Closure some_vs9o0_Entry(in (Closure x0, Closure x1, Closure x2) some_v_Frees9o0)
        {
            var dAlternatives9nY = some_v_Frees9o0.x0;
            var etas9nZ = some_v_Frees9o0.x1;
            var some_vs9o0 = some_v_Frees9o0.x2;
            var wws9o1 = GHC.Base.p1Alternative_Entry(dAlternatives9nY);
            var wws9o1_CColApplicative = wws9o1 as GHC.Base.CColApplicative;
            var wws9o2 = wws9o1_CColApplicative.x0;
            var wws9o3 = wws9o1_CColApplicative.x1;
            var wws9o4 = wws9o1_CColApplicative.x2;
            var wws9o5 = wws9o1_CColApplicative.x3;
            var wws9o6 = wws9o1_CColApplicative.x4;
            var wws9o7 = wws9o1_CColApplicative.x5;
            var sat_Frees9o9 = (dAlternatives9nY, some_vs9o0, wws9o3);
            var sats9o9 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9o9_Entry, sat_Frees9o9);
            return wws9o5.Apply<Closure, Closure, Closure, Closure>(GHC.Types.cons_DataCon, etas9nZ, sats9o9);
        }
        public static Closure sats9o9_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9o9)
        {
            var dAlternatives9nY = sat_Frees9o9.x0;
            var some_vs9o0 = sat_Frees9o9.x1;
            var wws9o3 = sat_Frees9o9.x2;
            var sats9o8 = new Updatable<Closure>(&sats9o8_Entry, wws9o3);
            return GHC.Base.ltPipeGt_Entry(dAlternatives9nY).Apply<Closure, Closure, Closure>(some_vs9o0, sats9o8);
        }
        public static Closure sats9o8_Entry(in Closure wws9o3)
        {
            return wws9o3.Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure dmmany_Entry(Closure dAlternatives9nR, Closure etas9nS)
        {
            var many_v_Frees9nT = (dAlternatives9nR, etas9nS, (Closure)null);
            var many_vs9nT = new Updatable<(Closure x0, Closure x1, Closure x2)>(&many_vs9nT_Entry, many_v_Frees9nT);
            many_vs9nT.free.x2 = many_vs9nT; return many_vs9nT.Eval();
        }
        public static Closure many_vs9nT_Entry(in (Closure x0, Closure x1, Closure x2) many_v_Frees9nT)
        {
            var dAlternatives9nR = many_v_Frees9nT.x0;
            var etas9nS = many_v_Frees9nT.x1;
            var many_vs9nT = many_v_Frees9nT.x2;
            var dApplicatives9nU = new Updatable<Closure>(&dApplicatives9nU_Entry, dAlternatives9nR);
            var sats9nW = new Updatable<Closure>(&sats9nW_Entry, dApplicatives9nU);
            var sat_Frees9nV = (etas9nS, many_vs9nT, dApplicatives9nU);
            var sats9nV = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9nV_Entry, sat_Frees9nV);
            return GHC.Base.ltPipeGt_Entry(dAlternatives9nR).Apply<Closure, Closure, Closure>(sats9nV, sats9nW);
        }
        public static Closure sats9nV_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9nV)
        {
            var etas9nS = sat_Frees9nV.x0;
            var many_vs9nT = sat_Frees9nV.x1;
            var dApplicatives9nU = sat_Frees9nV.x2;
            return GHC.Base.liftA2_Entry(dApplicatives9nU).Apply<Closure, Closure, Closure, Closure>(GHC.Types.cons_DataCon, etas9nS, many_vs9nT);
        }
        public static Closure sats9nW_Entry(in Closure dApplicatives9nU)
        {
            return GHC.Base.pure_Entry(dApplicatives9nU).Apply<Closure, Closure>(GHC.Types.nil_DataCon);
        }
        public static Closure dApplicatives9nU_Entry(in Closure dAlternatives9nR)
        {
            return GHC.Base.p1Alternative_Entry(dAlternatives9nR);
        }
        public static Closure dmGtGt_Entry(Closure dMonads9nL, Closure ms9nM, Closure ks9nN)
        {
            var sats9nP = new Fun1<Closure, Closure, Closure>(&sats9nP_Entry, ks9nN);
            return GHC.Base.gtGtEq_Entry(dMonads9nL).Apply<Closure, Closure, Closure>(ms9nM, sats9nP);
        }
        public static Closure sats9nP_Entry(in Closure ks9nN, Closure dss9nO)
        {
            return ks9nN.Eval();
        }
        public static Closure dmreturn_Entry(Closure dMonads9nI)
        {
            var sats9nJ = GHC.Base.p1Monad_Entry(dMonads9nI);
            return GHC.Base.pure_Entry(sats9nJ);
        }
        public static Closure dmfail_Entry(Closure dMonads9nF, Closure ss9nG)
        {
            return GHC.Err.errorWithoutStackTrace_Entry<Closure>(ss9nG);
        }
        public static Closure dmmzero_Entry(Closure dMonadPluss9nC)
        {
            var sats9nD = GHC.Base.p1MonadPlus_Entry(dMonadPluss9nC);
            return GHC.Base.empty_Entry(sats9nD);
        }
        public static Closure dmmplus_Entry(Closure dMonadPluss9nz)
        {
            var sats9nA = GHC.Base.p1MonadPlus_Entry(dMonadPluss9nz);
            return GHC.Base.ltPipeGt_Entry(sats9nA);
        }
        public static Closure cGtGtEqs9no_Entry(Closure xss9np, Closure fs9nq)
        {
            var go_Frees9nr = (fs9nq, (Closure)null);
            var gos9nr = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9nr_Entry, go_Frees9nr);
            gos9nr.free.x1 = gos9nr;
            return gos9nr.Apply<Closure, Closure>(xss9np);
        }
        public static Closure gos9nr_Entry(in (Closure x0, Closure x1) go_Frees9nr, Closure dss9ns)
        {
            var fs9nq = go_Frees9nr.x0;
            var gos9nr = go_Frees9nr.x1;
            var wilds9nt = dss9ns.Eval();
            switch (wilds9nt)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9nt_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9nt_Cons:
                    {
                        var ys9nu = wilds9nt_Cons.x0;
                        var yss9nv = wilds9nt_Cons.x1;
                        var sat_Frees9nx = (gos9nr, yss9nv);
                        var sats9nx = new SingleEntry<(Closure x0, Closure x1)>(&sats9nx_Entry, sat_Frees9nx);
                        var sats9nw = fs9nq.Apply<Closure, Closure>(ys9nu);
                        return plusPlus_Entry(sats9nw, sats9nx);
                    }
            }
        }
        public static Closure sats9nx_Entry(in (Closure x0, Closure x1) sat_Frees9nx)
        {
            var gos9nr = sat_Frees9nx.x0;
            var yss9nv = sat_Frees9nx.x1;
            return gos9nr.Apply<Closure, Closure>(yss9nv);
        }
        public static Closure cfails9nm_Entry(Closure dss9nn)
        {
            return GHC.Types.nil_DataCon.Eval();
        }
        public static Closure cGtGtEqs9nh_Entry(Closure dss9ni, Closure ks9nj)
        {
            var wilds9nk = dss9ni.Eval();
            switch (wilds9nk)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9nk_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9nk_Just:
                    {
                        var xs9nl = wilds9nk_Just.x0;
                        return ks9nj.Apply<Closure, Closure>(xs9nl);
                    }
            }
        }
        public static Closure cfails9nf_Entry(Closure dss9ng)
        {
            return GHC.Maybe.nothing_DataCon.Eval();
        }
        public static Closure cGtGtEqs9na_Entry(Closure fs9nb, Closure ks9nc, Closure rs9nd)
        {
            var sat_Frees9ne = (fs9nb, rs9nd);
            var sats9ne = new Updatable<(Closure x0, Closure x1)>(&sats9ne_Entry, sat_Frees9ne);
            return ks9nc.Apply<Closure, Closure, Closure>(sats9ne, rs9nd);
        }
        public static Closure sats9ne_Entry(in (Closure x0, Closure x1) sat_Frees9ne)
        {
            var fs9nb = sat_Frees9ne.x0;
            var rs9nd = sat_Frees9ne.x1;
            return fs9nb.Apply<Closure, Closure>(rs9nd);
        }
        public static Closure cGtGtEqs9mZ_Entry(Closure dMonoids9n0, Closure etas9n1, Closure etas9n2)
        {
            var wilds9n3 = etas9n1.Eval();
            var wilds9n3_Tuple2 = wilds9n3 as GHC.Tuple.Tuple2;
            var us9n4 = wilds9n3_Tuple2.x0;
            var as9n5 = wilds9n3_Tuple2.x1;
            var wilds9n6 = etas9n2.Apply<Closure, Closure>(as9n5);
            var wilds9n6_Tuple2 = wilds9n6 as GHC.Tuple.Tuple2;
            var vs9n7 = wilds9n6_Tuple2.x0;
            var bs9n8 = wilds9n6_Tuple2.x1;
            var sat_Frees9n9 = (dMonoids9n0, us9n4, vs9n7);
            var sats9n9 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9n9_Entry, sat_Frees9n9);
            return new GHC.Tuple.Tuple2(sats9n9, bs9n8);
        }
        public static Closure sats9n9_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9n9)
        {
            var dMonoids9n0 = sat_Frees9n9.x0;
            var us9n4 = sat_Frees9n9.x1;
            var vs9n7 = sat_Frees9n9.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9n0).Apply<Closure, Closure, Closure>(us9n4, vs9n7);
        }
        public static Closure cLtPipeGts9mU_Entry(Closure dss9mV, Closure rs9mW)
        {
            var wilds9mX = dss9mV.Eval();
            switch (wilds9mX)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9mX_Nothing: { return rs9mW.Eval(); }
                case GHC.Maybe.Just wilds9mX_Just:
                    {
                        var ipvs9mY = wilds9mX_Just.x0; return wilds9mX.Eval();
                    }
            }
        }
        public static Closure cpures9mS_Entry(Closure xs9mT)
        {
            return new GHC.Types.Cons(xs9mT, GHC.Types.nil_DataCon);
        }
        public static Closure cLtAstrGts9mC_Entry(Closure fss9mD, Closure xss9mE)
        {
            var go_Frees9mF = (xss9mE, (Closure)null);
            var gos9mF = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9mF_Entry, go_Frees9mF);
            gos9mF.free.x1 = gos9mF;
            return gos9mF.Apply<Closure, Closure>(fss9mD);
        }
        public static Closure gos9mF_Entry(in (Closure x0, Closure x1) go_Frees9mF, Closure dss9mG)
        {
            var xss9mE = go_Frees9mF.x0;
            var gos9mF = go_Frees9mF.x1;
            var wilds9mH = dss9mG.Eval();
            switch (wilds9mH)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mH_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mH_Cons:
                    {
                        var ys9mI = wilds9mH_Cons.x0;
                        var yss9mJ = wilds9mH_Cons.x1;
                        var z_Frees9mK = (gos9mF, yss9mJ);
                        var zs9mK = new Updatable<(Closure x0, Closure x1)>(&zs9mK_Entry, z_Frees9mK);
                        var go_Frees9mL = (ys9mI, zs9mK, (Closure)null);
                        var gos9mL = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9mL_Entry, go_Frees9mL);
                        gos9mL.free.x2 = gos9mL;
                        return gos9mL.Apply<Closure, Closure>(xss9mE);
                    }
            }
        }
        public static Closure gos9mL_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9mL, Closure dss9mM)
        {
            var ys9mI = go_Frees9mL.x0;
            var zs9mK = go_Frees9mL.x1;
            var gos9mL = go_Frees9mL.x2;
            var wilds9mN = dss9mM.Eval();
            switch (wilds9mN)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mN_Nil: { return zs9mK.Eval(); }
                case GHC.Types.Cons wilds9mN_Cons:
                    {
                        var ys9mO = wilds9mN_Cons.x0;
                        var yss9mP = wilds9mN_Cons.x1;
                        var sat_Frees9mR = (gos9mL, yss9mP);
                        var sats9mR = new Updatable<(Closure x0, Closure x1)>(&sats9mR_Entry, sat_Frees9mR);
                        var sat_Frees9mQ = (ys9mI, ys9mO);
                        var sats9mQ = new Updatable<(Closure x0, Closure x1)>(&sats9mQ_Entry, sat_Frees9mQ);
                        return new GHC.Types.Cons(sats9mQ, sats9mR);
                    }
            }
        }
        public static Closure sats9mQ_Entry(in (Closure x0, Closure x1) sat_Frees9mQ)
        {
            var ys9mI = sat_Frees9mQ.x0;
            var ys9mO = sat_Frees9mQ.x1;
            return ys9mI.Apply<Closure, Closure>(ys9mO);
        }
        public static Closure sats9mR_Entry(in (Closure x0, Closure x1) sat_Frees9mR)
        {
            var gos9mL = sat_Frees9mR.x0;
            var yss9mP = sat_Frees9mR.x1;
            return gos9mL.Apply<Closure, Closure>(yss9mP);
        }
        public static Closure zs9mK_Entry(in (Closure x0, Closure x1) z_Frees9mK)
        {
            var gos9mF = z_Frees9mK.x0;
            var yss9mJ = z_Frees9mK.x1;
            return gos9mF.Apply<Closure, Closure>(yss9mJ);
        }
        public static Closure cliftA2s9ml_Entry(Closure fs9mm, Closure xss9mn, Closure yss9mo)
        {
            var go_Frees9mp = (fs9mm, yss9mo, (Closure)null);
            var gos9mp = new Fun1<(Closure x0, Closure x1, Closure x2), Closure, Closure>(&gos9mp_Entry, go_Frees9mp);
            gos9mp.free.x2 = gos9mp;
            return gos9mp.Apply<Closure, Closure>(xss9mn);
        }
        public static Closure gos9mp_Entry(in (Closure x0, Closure x1, Closure x2) go_Frees9mp, Closure dss9mq)
        {
            var fs9mm = go_Frees9mp.x0;
            var yss9mo = go_Frees9mp.x1;
            var gos9mp = go_Frees9mp.x2;
            var wilds9mr = dss9mq.Eval();
            switch (wilds9mr)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mr_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mr_Cons:
                    {
                        var ys9ms = wilds9mr_Cons.x0;
                        var yss9mt = wilds9mr_Cons.x1;
                        var z_Frees9mu = (gos9mp, yss9mt);
                        var zs9mu = new Updatable<(Closure x0, Closure x1)>(&zs9mu_Entry, z_Frees9mu);
                        var go_Frees9mv = (fs9mm, ys9ms, zs9mu, (Closure)null);
                        var gos9mv = new Fun1<(Closure x0, Closure x1, Closure x2, Closure x3), Closure, Closure>(&gos9mv_Entry, go_Frees9mv);
                        gos9mv.free.x3 = gos9mv;
                        return gos9mv.Apply<Closure, Closure>(yss9mo);
                    }
            }
        }
        public static Closure gos9mv_Entry(in (Closure x0, Closure x1, Closure x2, Closure x3) go_Frees9mv, Closure dss9mw)
        {
            var fs9mm = go_Frees9mv.x0;
            var ys9ms = go_Frees9mv.x1;
            var zs9mu = go_Frees9mv.x2;
            var gos9mv = go_Frees9mv.x3;
            var wilds9mx = dss9mw.Eval();
            switch (wilds9mx)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mx_Nil: { return zs9mu.Eval(); }
                case GHC.Types.Cons wilds9mx_Cons:
                    {
                        var ys9my = wilds9mx_Cons.x0;
                        var yss9mz = wilds9mx_Cons.x1;
                        var sat_Frees9mB = (gos9mv, yss9mz);
                        var sats9mB = new Updatable<(Closure x0, Closure x1)>(&sats9mB_Entry, sat_Frees9mB);
                        var sat_Frees9mA = (fs9mm, ys9ms, ys9my);
                        var sats9mA = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9mA_Entry, sat_Frees9mA);
                        return new GHC.Types.Cons(sats9mA, sats9mB);
                    }
            }
        }
        public static Closure sats9mA_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9mA)
        {
            var fs9mm = sat_Frees9mA.x0;
            var ys9ms = sat_Frees9mA.x1;
            var ys9my = sat_Frees9mA.x2;
            return fs9mm.Apply<Closure, Closure, Closure>(ys9ms, ys9my);
        }
        public static Closure sats9mB_Entry(in (Closure x0, Closure x1) sat_Frees9mB)
        {
            var gos9mv = sat_Frees9mB.x0;
            var yss9mz = sat_Frees9mB.x1;
            return gos9mv.Apply<Closure, Closure>(yss9mz);
        }
        public static Closure zs9mu_Entry(in (Closure x0, Closure x1) z_Frees9mu)
        {
            var gos9mp = z_Frees9mu.x0;
            var yss9mt = z_Frees9mu.x1;
            return gos9mp.Apply<Closure, Closure>(yss9mt);
        }
        public static Closure cAstrGts9mc_Entry(Closure xss9md, Closure yss9me)
        {
            var go_Frees9mf = (yss9me, (Closure)null);
            var gos9mf = new Fun1<(Closure x0, Closure x1), Closure, Closure>(&gos9mf_Entry, go_Frees9mf);
            gos9mf.free.x1 = gos9mf;
            return gos9mf.Apply<Closure, Closure>(xss9md);
        }
        public static Closure gos9mf_Entry(in (Closure x0, Closure x1) go_Frees9mf, Closure dss9mg)
        {
            var yss9me = go_Frees9mf.x0;
            var gos9mf = go_Frees9mf.x1;
            var wilds9mh = dss9mg.Eval();
            switch (wilds9mh)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9mh_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9mh_Cons:
                    {
                        var ys9mi = wilds9mh_Cons.x0;
                        var yss9mj = wilds9mh_Cons.x1;
                        var sat_Frees9mk = (gos9mf, yss9mj);
                        var sats9mk = new SingleEntry<(Closure x0, Closure x1)>(&sats9mk_Entry, sat_Frees9mk);
                        return plusPlus_Entry(yss9me, sats9mk);
                    }
            }
        }
        public static Closure sats9mk_Entry(in (Closure x0, Closure x1) sat_Frees9mk)
        {
            var gos9mf = sat_Frees9mk.x0;
            var yss9mj = sat_Frees9mk.x1;
            return gos9mf.Apply<Closure, Closure>(yss9mj);
        }
        public static Closure cliftA2s9m3_Entry(Closure fs9m4, Closure dss9m5, Closure dss9m6)
        {
            var wilds9m7 = dss9m5.Eval();
            switch (wilds9m7)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9m7_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9m7_Just:
                    {
                        var xs9m8 = wilds9m7_Just.x0;
                        var wilds9m9 = dss9m6.Eval();
                        switch (wilds9m9)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9m9_Nothing:
                                {
                                    return GHC.Maybe.nothing_DataCon.Eval();
                                }
                            case GHC.Maybe.Just wilds9m9_Just:
                                {
                                    var ys9ma = wilds9m9_Just.x0;
                                    var sat_Frees9mb = (fs9m4, xs9m8, ys9ma);
                                    var sats9mb = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9mb_Entry, sat_Frees9mb);
                                    return new GHC.Maybe.Just(sats9mb);
                                }
                        }
                    }
            }
        }
        public static Closure sats9mb_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9mb)
        {
            var fs9m4 = sat_Frees9mb.x0;
            var xs9m8 = sat_Frees9mb.x1;
            var ys9ma = sat_Frees9mb.x2;
            return fs9m4.Apply<Closure, Closure, Closure>(xs9m8, ys9ma);
        }
        public static Closure cAstrGts9lY_Entry(Closure dss9lZ, Closure m2s9m0)
        {
            var wilds9m1 = dss9lZ.Eval();
            switch (wilds9m1)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9m1_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9m1_Just:
                    {
                        var _m1s9m2 = wilds9m1_Just.x0; return m2s9m0.Eval();
                    }
            }
        }
        public static Closure cLtAstrGts9lT_Entry(Closure fs9lU, Closure gs9lV, Closure xs9lW)
        {
            var sat_Frees9lX = (gs9lV, xs9lW);
            var sats9lX = new Updatable<(Closure x0, Closure x1)>(&sats9lX_Entry, sat_Frees9lX);
            return fs9lU.Apply<Closure, Closure, Closure>(xs9lW, sats9lX);
        }
        public static Closure sats9lX_Entry(in (Closure x0, Closure x1) sat_Frees9lX)
        {
            var gs9lV = sat_Frees9lX.x0;
            var xs9lW = sat_Frees9lX.x1;
            return gs9lV.Apply<Closure, Closure>(xs9lW);
        }
        public static Closure cliftA2s9lM_Entry(Closure qs9lN, Closure fs9lO, Closure gs9lP, Closure xs9lQ)
        {
            var sat_Frees9lS = (gs9lP, xs9lQ);
            var sats9lS = new Updatable<(Closure x0, Closure x1)>(&sats9lS_Entry, sat_Frees9lS);
            var sat_Frees9lR = (fs9lO, xs9lQ);
            var sats9lR = new Updatable<(Closure x0, Closure x1)>(&sats9lR_Entry, sat_Frees9lR);
            return qs9lN.Apply<Closure, Closure, Closure>(sats9lR, sats9lS);
        }
        public static Closure sats9lR_Entry(in (Closure x0, Closure x1) sat_Frees9lR)
        {
            var fs9lO = sat_Frees9lR.x0;
            var xs9lQ = sat_Frees9lR.x1;
            return fs9lO.Apply<Closure, Closure>(xs9lQ);
        }
        public static Closure sats9lS_Entry(in (Closure x0, Closure x1) sat_Frees9lS)
        {
            var gs9lP = sat_Frees9lS.x0;
            var xs9lQ = sat_Frees9lS.x1;
            return gs9lP.Apply<Closure, Closure>(xs9lQ);
        }
        public static Closure cLtAstrGts9lA_Entry(Closure dMonoids9lB, Closure etas9lC, Closure etas9lD)
        {
            var wilds9lE = etas9lC.Eval();
            var wilds9lE_Tuple2 = wilds9lE as GHC.Tuple.Tuple2;
            var us9lF = wilds9lE_Tuple2.x0;
            var fs9lG = wilds9lE_Tuple2.x1;
            var wilds9lH = etas9lD.Eval();
            var wilds9lH_Tuple2 = wilds9lH as GHC.Tuple.Tuple2;
            var vs9lI = wilds9lH_Tuple2.x0;
            var xs9lJ = wilds9lH_Tuple2.x1;
            var sat_Frees9lL = (fs9lG, xs9lJ);
            var sats9lL = new Updatable<(Closure x0, Closure x1)>(&sats9lL_Entry, sat_Frees9lL);
            var sat_Frees9lK = (dMonoids9lB, us9lF, vs9lI);
            var sats9lK = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9lK_Entry, sat_Frees9lK);
            return new GHC.Tuple.Tuple2(sats9lK, sats9lL);
        }
        public static Closure sats9lK_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9lK)
        {
            var dMonoids9lB = sat_Frees9lK.x0;
            var us9lF = sat_Frees9lK.x1;
            var vs9lI = sat_Frees9lK.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9lB).Apply<Closure, Closure, Closure>(us9lF, vs9lI);
        }
        public static Closure sats9lL_Entry(in (Closure x0, Closure x1) sat_Frees9lL)
        {
            var fs9lG = sat_Frees9lL.x0;
            var xs9lJ = sat_Frees9lL.x1;
            return fs9lG.Apply<Closure, Closure>(xs9lJ);
        }
        public static Closure cliftA2s9ln_Entry(Closure dMonoids9lo, Closure etas9lp, Closure etas9lq, Closure etas9lr)
        {
            var wilds9ls = etas9lq.Eval();
            var wilds9ls_Tuple2 = wilds9ls as GHC.Tuple.Tuple2;
            var us9lt = wilds9ls_Tuple2.x0;
            var xs9lu = wilds9ls_Tuple2.x1;
            var wilds9lv = etas9lr.Eval();
            var wilds9lv_Tuple2 = wilds9lv as GHC.Tuple.Tuple2;
            var vs9lw = wilds9lv_Tuple2.x0;
            var ys9lx = wilds9lv_Tuple2.x1;
            var sat_Frees9lz = (etas9lp, xs9lu, ys9lx);
            var sats9lz = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9lz_Entry, sat_Frees9lz);
            var sat_Frees9ly = (dMonoids9lo, us9lt, vs9lw);
            var sats9ly = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9ly_Entry, sat_Frees9ly);
            return new GHC.Tuple.Tuple2(sats9ly, sats9lz);
        }
        public static Closure sats9ly_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9ly)
        {
            var dMonoids9lo = sat_Frees9ly.x0;
            var us9lt = sat_Frees9ly.x1;
            var vs9lw = sat_Frees9ly.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9lo).Apply<Closure, Closure, Closure>(us9lt, vs9lw);
        }
        public static Closure sats9lz_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9lz)
        {
            var etas9lp = sat_Frees9lz.x0;
            var xs9lu = sat_Frees9lz.x1;
            var ys9lx = sat_Frees9lz.x2;
            return etas9lp.Apply<Closure, Closure, Closure>(xs9lu, ys9lx);
        }
        public static Closure cfmaps9lh_Entry(Closure dss9li, Closure dss9lj)
        {
            var wilds9lk = dss9lj.Eval();
            switch (wilds9lk)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9lk_Nothing:
                    {
                        return GHC.Maybe.nothing_DataCon.Eval();
                    }
                case GHC.Maybe.Just wilds9lk_Just:
                    {
                        var as9ll = wilds9lk_Just.x0;
                        var sat_Frees9lm = (dss9li, as9ll);
                        var sats9lm = new Updatable<(Closure x0, Closure x1)>(&sats9lm_Entry, sat_Frees9lm);
                        return new GHC.Maybe.Just(sats9lm);
                    }
            }
        }
        public static Closure sats9lm_Entry(in (Closure x0, Closure x1) sat_Frees9lm)
        {
            var dss9li = sat_Frees9lm.x0;
            var as9ll = sat_Frees9lm.x1;
            return dss9li.Apply<Closure, Closure>(as9ll);
        }
        public static Closure cfmaps9la_Entry(Closure fs9lb, Closure dss9lc)
        {
            var wilds9ld = dss9lc.Eval();
            var wilds9ld_Tuple2 = wilds9ld as GHC.Tuple.Tuple2;
            var xs9le = wilds9ld_Tuple2.x0;
            var ys9lf = wilds9ld_Tuple2.x1;
            var sat_Frees9lg = (fs9lb, ys9lf);
            var sats9lg = new Updatable<(Closure x0, Closure x1)>(&sats9lg_Entry, sat_Frees9lg);
            return new GHC.Tuple.Tuple2(xs9le, sats9lg);
        }
        public static Closure sats9lg_Entry(in (Closure x0, Closure x1) sat_Frees9lg)
        {
            var fs9lb = sat_Frees9lg.x0;
            var ys9lf = sat_Frees9lg.x1;
            return fs9lb.Apply<Closure, Closure>(ys9lf);
        }
        public static Closure cp1Monoids9kL_Entry(Closure dMonoids9kM, Closure dMonoids9kN, Closure dMonoids9kO, Closure dMonoids9kP, Closure dMonoids9kQ, Closure etas9kR, Closure etas9kS)
        {
            var wilds9kT = etas9kR.Eval();
            var wilds9kT_Tuple5 = wilds9kT as GHC.Tuple.Tuple5;
            var as9kU = wilds9kT_Tuple5.x0;
            var bs9kV = wilds9kT_Tuple5.x1;
            var cs9kW = wilds9kT_Tuple5.x2;
            var ds9kX = wilds9kT_Tuple5.x3;
            var es9kY = wilds9kT_Tuple5.x4;
            var wilds9kZ = etas9kS.Eval();
            var wilds9kZ_Tuple5 = wilds9kZ as GHC.Tuple.Tuple5;
            var a_s9l0 = wilds9kZ_Tuple5.x0;
            var b_s9l1 = wilds9kZ_Tuple5.x1;
            var c_s9l2 = wilds9kZ_Tuple5.x2;
            var d_s9l3 = wilds9kZ_Tuple5.x3;
            var e_s9l4 = wilds9kZ_Tuple5.x4;
            var sat_Frees9l9 = (dMonoids9kQ, es9kY, e_s9l4);
            var sats9l9 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9l9_Entry, sat_Frees9l9);
            var sat_Frees9l8 = (dMonoids9kP, ds9kX, d_s9l3);
            var sats9l8 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9l8_Entry, sat_Frees9l8);
            var sat_Frees9l7 = (dMonoids9kO, cs9kW, c_s9l2);
            var sats9l7 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9l7_Entry, sat_Frees9l7);
            var sat_Frees9l6 = (dMonoids9kN, bs9kV, b_s9l1);
            var sats9l6 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9l6_Entry, sat_Frees9l6);
            var sat_Frees9l5 = (dMonoids9kM, as9kU, a_s9l0);
            var sats9l5 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9l5_Entry, sat_Frees9l5);
            return new GHC.Tuple.Tuple5(sats9l5, sats9l6, sats9l7, sats9l8, sats9l9);
        }
        public static Closure sats9l5_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9l5)
        {
            var dMonoids9kM = sat_Frees9l5.x0;
            var as9kU = sat_Frees9l5.x1;
            var a_s9l0 = sat_Frees9l5.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kM).Apply<Closure, Closure, Closure>(as9kU, a_s9l0);
        }
        public static Closure sats9l6_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9l6)
        {
            var dMonoids9kN = sat_Frees9l6.x0;
            var bs9kV = sat_Frees9l6.x1;
            var b_s9l1 = sat_Frees9l6.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kN).Apply<Closure, Closure, Closure>(bs9kV, b_s9l1);
        }
        public static Closure sats9l7_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9l7)
        {
            var dMonoids9kO = sat_Frees9l7.x0;
            var cs9kW = sat_Frees9l7.x1;
            var c_s9l2 = sat_Frees9l7.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kO).Apply<Closure, Closure, Closure>(cs9kW, c_s9l2);
        }
        public static Closure sats9l8_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9l8)
        {
            var dMonoids9kP = sat_Frees9l8.x0;
            var ds9kX = sat_Frees9l8.x1;
            var d_s9l3 = sat_Frees9l8.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kP).Apply<Closure, Closure, Closure>(ds9kX, d_s9l3);
        }
        public static Closure sats9l9_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9l9)
        {
            var dMonoids9kQ = sat_Frees9l9.x0;
            var es9kY = sat_Frees9l9.x1;
            var e_s9l4 = sat_Frees9l9.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kQ).Apply<Closure, Closure, Closure>(es9kY, e_s9l4);
        }
        public static Closure cmemptys9kA_Entry(Closure dMonoids9kB, Closure dMonoids9kC, Closure dMonoids9kD, Closure dMonoids9kE, Closure dMonoids9kF)
        {
            var sats9kK = new Updatable<Closure>(&sats9kK_Entry, dMonoids9kF);
            var sats9kJ = new Updatable<Closure>(&sats9kJ_Entry, dMonoids9kE);
            var sats9kI = new Updatable<Closure>(&sats9kI_Entry, dMonoids9kD);
            var sats9kH = new Updatable<Closure>(&sats9kH_Entry, dMonoids9kC);
            var sats9kG = new Updatable<Closure>(&sats9kG_Entry, dMonoids9kB);
            return new GHC.Tuple.Tuple5(sats9kG, sats9kH, sats9kI, sats9kJ, sats9kK);
        }
        public static Closure sats9kG_Entry(in Closure dMonoids9kB)
        {
            return GHC.Base.mempty_Entry(dMonoids9kB);
        }
        public static Closure sats9kH_Entry(in Closure dMonoids9kC)
        {
            return GHC.Base.mempty_Entry(dMonoids9kC);
        }
        public static Closure sats9kI_Entry(in Closure dMonoids9kD)
        {
            return GHC.Base.mempty_Entry(dMonoids9kD);
        }
        public static Closure sats9kJ_Entry(in Closure dMonoids9kE)
        {
            return GHC.Base.mempty_Entry(dMonoids9kE);
        }
        public static Closure sats9kK_Entry(in Closure dMonoids9kF)
        {
            return GHC.Base.mempty_Entry(dMonoids9kF);
        }
        public static Closure cp1Monoids9kf_Entry(Closure dMonoids9kg, Closure dMonoids9kh, Closure dMonoids9ki, Closure dMonoids9kj, Closure etas9kk, Closure etas9kl)
        {
            var wilds9km = etas9kk.Eval();
            var wilds9km_Tuple4 = wilds9km as GHC.Tuple.Tuple4;
            var as9kn = wilds9km_Tuple4.x0;
            var bs9ko = wilds9km_Tuple4.x1;
            var cs9kp = wilds9km_Tuple4.x2;
            var ds9kq = wilds9km_Tuple4.x3;
            var wilds9kr = etas9kl.Eval();
            var wilds9kr_Tuple4 = wilds9kr as GHC.Tuple.Tuple4;
            var a_s9ks = wilds9kr_Tuple4.x0;
            var b_s9kt = wilds9kr_Tuple4.x1;
            var c_s9ku = wilds9kr_Tuple4.x2;
            var d_s9kv = wilds9kr_Tuple4.x3;
            var sat_Frees9kz = (dMonoids9kj, ds9kq, d_s9kv);
            var sats9kz = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9kz_Entry, sat_Frees9kz);
            var sat_Frees9ky = (dMonoids9ki, cs9kp, c_s9ku);
            var sats9ky = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9ky_Entry, sat_Frees9ky);
            var sat_Frees9kx = (dMonoids9kh, bs9ko, b_s9kt);
            var sats9kx = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9kx_Entry, sat_Frees9kx);
            var sat_Frees9kw = (dMonoids9kg, as9kn, a_s9ks);
            var sats9kw = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9kw_Entry, sat_Frees9kw);
            return new GHC.Tuple.Tuple4(sats9kw, sats9kx, sats9ky, sats9kz);
        }
        public static Closure sats9kw_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9kw)
        {
            var dMonoids9kg = sat_Frees9kw.x0;
            var as9kn = sat_Frees9kw.x1;
            var a_s9ks = sat_Frees9kw.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kg).Apply<Closure, Closure, Closure>(as9kn, a_s9ks);
        }
        public static Closure sats9kx_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9kx)
        {
            var dMonoids9kh = sat_Frees9kx.x0;
            var bs9ko = sat_Frees9kx.x1;
            var b_s9kt = sat_Frees9kx.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kh).Apply<Closure, Closure, Closure>(bs9ko, b_s9kt);
        }
        public static Closure sats9ky_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9ky)
        {
            var dMonoids9ki = sat_Frees9ky.x0;
            var cs9kp = sat_Frees9ky.x1;
            var c_s9ku = sat_Frees9ky.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9ki).Apply<Closure, Closure, Closure>(cs9kp, c_s9ku);
        }
        public static Closure sats9kz_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9kz)
        {
            var dMonoids9kj = sat_Frees9kz.x0;
            var ds9kq = sat_Frees9kz.x1;
            var d_s9kv = sat_Frees9kz.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9kj).Apply<Closure, Closure, Closure>(ds9kq, d_s9kv);
        }
        public static Closure cmemptys9k6_Entry(Closure dMonoids9k7, Closure dMonoids9k8, Closure dMonoids9k9, Closure dMonoids9ka)
        {
            var sats9ke = new Updatable<Closure>(&sats9ke_Entry, dMonoids9ka);
            var sats9kd = new Updatable<Closure>(&sats9kd_Entry, dMonoids9k9);
            var sats9kc = new Updatable<Closure>(&sats9kc_Entry, dMonoids9k8);
            var sats9kb = new Updatable<Closure>(&sats9kb_Entry, dMonoids9k7);
            return new GHC.Tuple.Tuple4(sats9kb, sats9kc, sats9kd, sats9ke);
        }
        public static Closure sats9kb_Entry(in Closure dMonoids9k7)
        {
            return GHC.Base.mempty_Entry(dMonoids9k7);
        }
        public static Closure sats9kc_Entry(in Closure dMonoids9k8)
        {
            return GHC.Base.mempty_Entry(dMonoids9k8);
        }
        public static Closure sats9kd_Entry(in Closure dMonoids9k9)
        {
            return GHC.Base.mempty_Entry(dMonoids9k9);
        }
        public static Closure sats9ke_Entry(in Closure dMonoids9ka)
        {
            return GHC.Base.mempty_Entry(dMonoids9ka);
        }
        public static Closure cp1Monoids9jP_Entry(Closure ws9jQ, Closure ws9jR, Closure ws9jS, Closure ws9jT, Closure ws9jU)
        {
            var wws9jV = ws9jT.Eval();
            var wws9jV_Tuple3 = wws9jV as GHC.Tuple.Tuple3;
            var wws9jW = wws9jV_Tuple3.x0;
            var wws9jX = wws9jV_Tuple3.x1;
            var wws9jY = wws9jV_Tuple3.x2;
            var wws9jZ = ws9jU.Eval();
            var wws9jZ_Tuple3 = wws9jZ as GHC.Tuple.Tuple3;
            var wws9k0 = wws9jZ_Tuple3.x0;
            var wws9k1 = wws9jZ_Tuple3.x1;
            var wws9k2 = wws9jZ_Tuple3.x2;
            var sat_Frees9k5 = (ws9jS, wws9jY, wws9k2);
            var sats9k5 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9k5_Entry, sat_Frees9k5);
            var sat_Frees9k4 = (ws9jR, wws9jX, wws9k1);
            var sats9k4 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9k4_Entry, sat_Frees9k4);
            var sat_Frees9k3 = (ws9jQ, wws9jW, wws9k0);
            var sats9k3 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9k3_Entry, sat_Frees9k3);
            return new GHC.Tuple.Tuple3(sats9k3, sats9k4, sats9k5);
        }
        public static Closure sats9k3_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9k3)
        {
            var ws9jQ = sat_Frees9k3.x0;
            var wws9jW = sat_Frees9k3.x1;
            var wws9k0 = sat_Frees9k3.x2;
            return GHC.Base.p1Monoid_Entry(ws9jQ).Apply<Closure, Closure, Closure>(wws9jW, wws9k0);
        }
        public static Closure sats9k4_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9k4)
        {
            var ws9jR = sat_Frees9k4.x0;
            var wws9jX = sat_Frees9k4.x1;
            var wws9k1 = sat_Frees9k4.x2;
            return GHC.Base.p1Monoid_Entry(ws9jR).Apply<Closure, Closure, Closure>(wws9jX, wws9k1);
        }
        public static Closure sats9k5_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9k5)
        {
            var ws9jS = sat_Frees9k5.x0;
            var wws9jY = sat_Frees9k5.x1;
            var wws9k2 = sat_Frees9k5.x2;
            return GHC.Base.p1Monoid_Entry(ws9jS).Apply<Closure, Closure, Closure>(wws9jY, wws9k2);
        }
        public static Closure cmemptys9jI_Entry(Closure dMonoids9jJ, Closure dMonoids9jK, Closure dMonoids9jL)
        {
            var sats9jO = new Updatable<Closure>(&sats9jO_Entry, dMonoids9jL);
            var sats9jN = new Updatable<Closure>(&sats9jN_Entry, dMonoids9jK);
            var sats9jM = new Updatable<Closure>(&sats9jM_Entry, dMonoids9jJ);
            return new GHC.Tuple.Tuple3(sats9jM, sats9jN, sats9jO);
        }
        public static Closure sats9jM_Entry(in Closure dMonoids9jJ)
        {
            return GHC.Base.mempty_Entry(dMonoids9jJ);
        }
        public static Closure sats9jN_Entry(in Closure dMonoids9jK)
        {
            return GHC.Base.mempty_Entry(dMonoids9jK);
        }
        public static Closure sats9jO_Entry(in Closure dMonoids9jL)
        {
            return GHC.Base.mempty_Entry(dMonoids9jL);
        }
        public static Closure cp1Monoids9jv_Entry(Closure dMonoids9jw, Closure dMonoids9jx, Closure etas9jy, Closure etas9jz)
        {
            var wilds9jA = etas9jy.Eval();
            var wilds9jA_Tuple2 = wilds9jA as GHC.Tuple.Tuple2;
            var as9jB = wilds9jA_Tuple2.x0;
            var bs9jC = wilds9jA_Tuple2.x1;
            var wilds9jD = etas9jz.Eval();
            var wilds9jD_Tuple2 = wilds9jD as GHC.Tuple.Tuple2;
            var a_s9jE = wilds9jD_Tuple2.x0;
            var b_s9jF = wilds9jD_Tuple2.x1;
            var sat_Frees9jH = (dMonoids9jx, bs9jC, b_s9jF);
            var sats9jH = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9jH_Entry, sat_Frees9jH);
            var sat_Frees9jG = (dMonoids9jw, as9jB, a_s9jE);
            var sats9jG = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9jG_Entry, sat_Frees9jG);
            return new GHC.Tuple.Tuple2(sats9jG, sats9jH);
        }
        public static Closure sats9jG_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9jG)
        {
            var dMonoids9jw = sat_Frees9jG.x0;
            var as9jB = sat_Frees9jG.x1;
            var a_s9jE = sat_Frees9jG.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9jw).Apply<Closure, Closure, Closure>(as9jB, a_s9jE);
        }
        public static Closure sats9jH_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9jH)
        {
            var dMonoids9jx = sat_Frees9jH.x0;
            var bs9jC = sat_Frees9jH.x1;
            var b_s9jF = sat_Frees9jH.x2;
            return GHC.Base.p1Monoid_Entry(dMonoids9jx).Apply<Closure, Closure, Closure>(bs9jC, b_s9jF);
        }
        public static Closure cmemptys9jq_Entry(Closure dMonoids9jr, Closure dMonoids9js)
        {
            var sats9ju = new Updatable<Closure>(&sats9ju_Entry, dMonoids9js);
            var sats9jt = new Updatable<Closure>(&sats9jt_Entry, dMonoids9jr);
            return new GHC.Tuple.Tuple2(sats9jt, sats9ju);
        }
        public static Closure sats9jt_Entry(in Closure dMonoids9jr)
        {
            return GHC.Base.mempty_Entry(dMonoids9jr);
        }
        public static Closure sats9ju_Entry(in Closure dMonoids9js)
        {
            return GHC.Base.mempty_Entry(dMonoids9js);
        }
        public static Closure cmconcats9jo_Entry(Closure dss9jp)
        {
            return GHC.Tuple.unit_DataCon.Eval();
        }
        public static Closure cp1Monoids9jh_Entry(Closure dMonoids9ji, Closure etas9jj, Closure etas9jk, Closure etas9jl)
        {
            var sat_Frees9jn = (etas9jk, etas9jl);
            var sats9jn = new Updatable<(Closure x0, Closure x1)>(&sats9jn_Entry, sat_Frees9jn);
            var sat_Frees9jm = (etas9jj, etas9jl);
            var sats9jm = new Updatable<(Closure x0, Closure x1)>(&sats9jm_Entry, sat_Frees9jm);
            return GHC.Base.p1Monoid_Entry(dMonoids9ji).Apply<Closure, Closure, Closure>(sats9jm, sats9jn);
        }
        public static Closure sats9jm_Entry(in (Closure x0, Closure x1) sat_Frees9jm)
        {
            var etas9jj = sat_Frees9jm.x0;
            var etas9jl = sat_Frees9jm.x1;
            return etas9jj.Apply<Closure, Closure>(etas9jl);
        }
        public static Closure sats9jn_Entry(in (Closure x0, Closure x1) sat_Frees9jn)
        {
            var etas9jk = sat_Frees9jn.x0;
            var etas9jl = sat_Frees9jn.x1;
            return etas9jk.Apply<Closure, Closure>(etas9jl);
        }
        public static Closure cmconcats9jf_Entry(Closure xsss9jg)
        {
            return poly_gos9j9_Entry(xsss9jg);
        }
        public static Closure poly_gos9j9_Entry(Closure dss9ja)
        {
            var wilds9jb = dss9ja.Eval();
            switch (wilds9jb)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Types.Nil wilds9jb_Nil:
                    {
                        return GHC.Types.nil_DataCon.Eval();
                    }
                case GHC.Types.Cons wilds9jb_Cons:
                    {
                        var ys9jc = wilds9jb_Cons.x0;
                        var yss9jd = wilds9jb_Cons.x1;
                        var sats9je = new SingleEntry<Closure>(&sats9je_Entry, yss9jd);
                        return plusPlus_Entry(ys9jc, sats9je);
                    }
            }
        }
        public static Closure sats9je_Entry(in Closure yss9jd)
        {
            return poly_gos9j9_Entry(yss9jd);
        }
        public static Closure fSemigroupMaybe_Entry(Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iZ_Entry(etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9iZ_Entry(Closure dSemigroups9j0, Closure dss9j1, Closure bs9j2)
        {
            var wilds9j3 = dss9j1.Eval();
            switch (wilds9j3)
            {
                default: { throw new ImpossibleException(); }
                case GHC.Maybe.Nothing wilds9j3_Nothing: { return bs9j2.Eval(); }
                case GHC.Maybe.Just wilds9j3_Just:
                    {
                        var ipvs9j4 = wilds9j3_Just.x0;
                        var wilds9j5 = bs9j2.Eval();
                        switch (wilds9j5)
                        {
                            default: { throw new ImpossibleException(); }
                            case GHC.Maybe.Nothing wilds9j5_Nothing:
                                {
                                    return wilds9j3.Eval();
                                }
                            case GHC.Maybe.Just wilds9j5_Just:
                                {
                                    var ipvs9j6 = wilds9j5_Just.x0;
                                    var sat_Frees9j7 = (dSemigroups9j0, ipvs9j4, ipvs9j6);
                                    var sats9j7 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9j7_Entry, sat_Frees9j7);
                                    return new GHC.Maybe.Just(sats9j7);
                                }
                        }
                    }
            }
        }
        public static Closure sats9j7_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9j7)
        {
            var dSemigroups9j0 = sat_Frees9j7.x0;
            var ipvs9j4 = sat_Frees9j7.x1;
            var ipvs9j6 = sat_Frees9j7.x2;
            return dSemigroups9j0.Apply<Closure, Closure, Closure>(ipvs9j4, ipvs9j6);
        }
        public static Closure fSemigroupOrdering_Entry(Closure etaB2, Closure etaB1)
        {
            return cLtGts9iU_Entry(etaB2, etaB1);
        }
        public static Closure cLtGts9iU_Entry(Closure dss9iV, Closure dss9iW)
        {
            var wilds9iX = dss9iV.Eval();
            var wilds9iXTags9iX = wilds9iX.Tag;
            switch (wilds9iXTags9iX)
            {
                default: { throw new ImpossibleException(); }
                case 1:
                    {
                        var wilds9iX_LT = wilds9iX as GHC.Types.LT;
                        return GHC.Types.lT_DataCon.Eval();
                    }
                case 2:
                    {
                        var wilds9iX_EQ = wilds9iX as GHC.Types.EQ; return dss9iW.Eval();
                    }
                case 3:
                    {
                        var wilds9iX_GT = wilds9iX as GHC.Types.GT;
                        return GHC.Types.gT_DataCon.Eval();
                    }
            }
        }
        public static Closure fSemigroupPrOComComComComPrC_Entry(Closure etaB7, Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9iu_Entry(etaB7, etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9iu_Entry(Closure dSemigroups9iv, Closure dSemigroups9iw, Closure dSemigroups9ix, Closure dSemigroups9iy, Closure dSemigroups9iz, Closure dss9iA, Closure dss9iB)
        {
            var wilds9iC = dss9iA.Eval();
            var wilds9iC_Tuple5 = wilds9iC as GHC.Tuple.Tuple5;
            var as9iD = wilds9iC_Tuple5.x0;
            var bs9iE = wilds9iC_Tuple5.x1;
            var cs9iF = wilds9iC_Tuple5.x2;
            var ds9iG = wilds9iC_Tuple5.x3;
            var es9iH = wilds9iC_Tuple5.x4;
            var wilds9iI = dss9iB.Eval();
            var wilds9iI_Tuple5 = wilds9iI as GHC.Tuple.Tuple5;
            var a_s9iJ = wilds9iI_Tuple5.x0;
            var b_s9iK = wilds9iI_Tuple5.x1;
            var c_s9iL = wilds9iI_Tuple5.x2;
            var d_s9iM = wilds9iI_Tuple5.x3;
            var e_s9iN = wilds9iI_Tuple5.x4;
            var sat_Frees9iS = (dSemigroups9iz, es9iH, e_s9iN);
            var sats9iS = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iS_Entry, sat_Frees9iS);
            var sat_Frees9iR = (dSemigroups9iy, ds9iG, d_s9iM);
            var sats9iR = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iR_Entry, sat_Frees9iR);
            var sat_Frees9iQ = (dSemigroups9ix, cs9iF, c_s9iL);
            var sats9iQ = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iQ_Entry, sat_Frees9iQ);
            var sat_Frees9iP = (dSemigroups9iw, bs9iE, b_s9iK);
            var sats9iP = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iP_Entry, sat_Frees9iP);
            var sat_Frees9iO = (dSemigroups9iv, as9iD, a_s9iJ);
            var sats9iO = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iO_Entry, sat_Frees9iO);
            return new GHC.Tuple.Tuple5(sats9iO, sats9iP, sats9iQ, sats9iR, sats9iS);
        }
        public static Closure sats9iO_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iO)
        {
            var dSemigroups9iv = sat_Frees9iO.x0;
            var as9iD = sat_Frees9iO.x1;
            var a_s9iJ = sat_Frees9iO.x2;
            return dSemigroups9iv.Apply<Closure, Closure, Closure>(as9iD, a_s9iJ);
        }
        public static Closure sats9iP_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iP)
        {
            var dSemigroups9iw = sat_Frees9iP.x0;
            var bs9iE = sat_Frees9iP.x1;
            var b_s9iK = sat_Frees9iP.x2;
            return dSemigroups9iw.Apply<Closure, Closure, Closure>(bs9iE, b_s9iK);
        }
        public static Closure sats9iQ_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iQ)
        {
            var dSemigroups9ix = sat_Frees9iQ.x0;
            var cs9iF = sat_Frees9iQ.x1;
            var c_s9iL = sat_Frees9iQ.x2;
            return dSemigroups9ix.Apply<Closure, Closure, Closure>(cs9iF, c_s9iL);
        }
        public static Closure sats9iR_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iR)
        {
            var dSemigroups9iy = sat_Frees9iR.x0;
            var ds9iG = sat_Frees9iR.x1;
            var d_s9iM = sat_Frees9iR.x2;
            return dSemigroups9iy.Apply<Closure, Closure, Closure>(ds9iG, d_s9iM);
        }
        public static Closure sats9iS_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iS)
        {
            var dSemigroups9iz = sat_Frees9iS.x0;
            var es9iH = sat_Frees9iS.x1;
            var e_s9iN = sat_Frees9iS.x2;
            return dSemigroups9iz.Apply<Closure, Closure, Closure>(es9iH, e_s9iN);
        }
        public static Closure fSemigroupPrOComComComPrC_Entry(Closure etaB6, Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9i8_Entry(etaB6, etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9i8_Entry(Closure dSemigroups9i9, Closure dSemigroups9ia, Closure dSemigroups9ib, Closure dSemigroups9ic, Closure dss9id, Closure dss9ie)
        {
            var wilds9if = dss9id.Eval();
            var wilds9if_Tuple4 = wilds9if as GHC.Tuple.Tuple4;
            var as9ig = wilds9if_Tuple4.x0;
            var bs9ih = wilds9if_Tuple4.x1;
            var cs9ii = wilds9if_Tuple4.x2;
            var ds9ij = wilds9if_Tuple4.x3;
            var wilds9ik = dss9ie.Eval();
            var wilds9ik_Tuple4 = wilds9ik as GHC.Tuple.Tuple4;
            var a_s9il = wilds9ik_Tuple4.x0;
            var b_s9im = wilds9ik_Tuple4.x1;
            var c_s9in = wilds9ik_Tuple4.x2;
            var d_s9io = wilds9ik_Tuple4.x3;
            var sat_Frees9is = (dSemigroups9ic, ds9ij, d_s9io);
            var sats9is = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9is_Entry, sat_Frees9is);
            var sat_Frees9ir = (dSemigroups9ib, cs9ii, c_s9in);
            var sats9ir = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9ir_Entry, sat_Frees9ir);
            var sat_Frees9iq = (dSemigroups9ia, bs9ih, b_s9im);
            var sats9iq = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9iq_Entry, sat_Frees9iq);
            var sat_Frees9ip = (dSemigroups9i9, as9ig, a_s9il);
            var sats9ip = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9ip_Entry, sat_Frees9ip);
            return new GHC.Tuple.Tuple4(sats9ip, sats9iq, sats9ir, sats9is);
        }
        public static Closure sats9ip_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9ip)
        {
            var dSemigroups9i9 = sat_Frees9ip.x0;
            var as9ig = sat_Frees9ip.x1;
            var a_s9il = sat_Frees9ip.x2;
            return dSemigroups9i9.Apply<Closure, Closure, Closure>(as9ig, a_s9il);
        }
        public static Closure sats9iq_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9iq)
        {
            var dSemigroups9ia = sat_Frees9iq.x0;
            var bs9ih = sat_Frees9iq.x1;
            var b_s9im = sat_Frees9iq.x2;
            return dSemigroups9ia.Apply<Closure, Closure, Closure>(bs9ih, b_s9im);
        }
        public static Closure sats9ir_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9ir)
        {
            var dSemigroups9ib = sat_Frees9ir.x0;
            var cs9ii = sat_Frees9ir.x1;
            var c_s9in = sat_Frees9ir.x2;
            return dSemigroups9ib.Apply<Closure, Closure, Closure>(cs9ii, c_s9in);
        }
        public static Closure sats9is_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9is)
        {
            var dSemigroups9ic = sat_Frees9is.x0;
            var ds9ij = sat_Frees9is.x1;
            var d_s9io = sat_Frees9is.x2;
            return dSemigroups9ic.Apply<Closure, Closure, Closure>(ds9ij, d_s9io);
        }
        public static Closure fSemigroupPrOComComPrC_Entry(Closure etaB5, Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hQ_Entry(etaB5, etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hQ_Entry(Closure dSemigroups9hR, Closure dSemigroups9hS, Closure dSemigroups9hT, Closure dss9hU, Closure dss9hV)
        {
            var wilds9hW = dss9hU.Eval();
            var wilds9hW_Tuple3 = wilds9hW as GHC.Tuple.Tuple3;
            var as9hX = wilds9hW_Tuple3.x0;
            var bs9hY = wilds9hW_Tuple3.x1;
            var cs9hZ = wilds9hW_Tuple3.x2;
            var wilds9i0 = dss9hV.Eval();
            var wilds9i0_Tuple3 = wilds9i0 as GHC.Tuple.Tuple3;
            var a_s9i1 = wilds9i0_Tuple3.x0;
            var b_s9i2 = wilds9i0_Tuple3.x1;
            var c_s9i3 = wilds9i0_Tuple3.x2;
            var sat_Frees9i6 = (dSemigroups9hT, cs9hZ, c_s9i3);
            var sats9i6 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9i6_Entry, sat_Frees9i6);
            var sat_Frees9i5 = (dSemigroups9hS, bs9hY, b_s9i2);
            var sats9i5 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9i5_Entry, sat_Frees9i5);
            var sat_Frees9i4 = (dSemigroups9hR, as9hX, a_s9i1);
            var sats9i4 = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9i4_Entry, sat_Frees9i4);
            return new GHC.Tuple.Tuple3(sats9i4, sats9i5, sats9i6);
        }
        public static Closure sats9i4_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9i4)
        {
            var dSemigroups9hR = sat_Frees9i4.x0;
            var as9hX = sat_Frees9i4.x1;
            var a_s9i1 = sat_Frees9i4.x2;
            return dSemigroups9hR.Apply<Closure, Closure, Closure>(as9hX, a_s9i1);
        }
        public static Closure sats9i5_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9i5)
        {
            var dSemigroups9hS = sat_Frees9i5.x0;
            var bs9hY = sat_Frees9i5.x1;
            var b_s9i2 = sat_Frees9i5.x2;
            return dSemigroups9hS.Apply<Closure, Closure, Closure>(bs9hY, b_s9i2);
        }
        public static Closure sats9i6_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9i6)
        {
            var dSemigroups9hT = sat_Frees9i6.x0;
            var cs9hZ = sat_Frees9i6.x1;
            var c_s9i3 = sat_Frees9i6.x2;
            return dSemigroups9hT.Apply<Closure, Closure, Closure>(cs9hZ, c_s9i3);
        }
        public static Closure fSemigroupPrOComPrC_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hC_Entry(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hC_Entry(Closure dSemigroups9hD, Closure dSemigroups9hE, Closure dss9hF, Closure dss9hG)
        {
            var wilds9hH = dss9hF.Eval();
            var wilds9hH_Tuple2 = wilds9hH as GHC.Tuple.Tuple2;
            var as9hI = wilds9hH_Tuple2.x0;
            var bs9hJ = wilds9hH_Tuple2.x1;
            var wilds9hK = dss9hG.Eval();
            var wilds9hK_Tuple2 = wilds9hK as GHC.Tuple.Tuple2;
            var a_s9hL = wilds9hK_Tuple2.x0;
            var b_s9hM = wilds9hK_Tuple2.x1;
            var sat_Frees9hO = (dSemigroups9hE, bs9hJ, b_s9hM);
            var sats9hO = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9hO_Entry, sat_Frees9hO);
            var sat_Frees9hN = (dSemigroups9hD, as9hI, a_s9hL);
            var sats9hN = new Updatable<(Closure x0, Closure x1, Closure x2)>(&sats9hN_Entry, sat_Frees9hN);
            return new GHC.Tuple.Tuple2(sats9hN, sats9hO);
        }
        public static Closure sats9hN_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9hN)
        {
            var dSemigroups9hD = sat_Frees9hN.x0;
            var as9hI = sat_Frees9hN.x1;
            var a_s9hL = sat_Frees9hN.x2;
            return dSemigroups9hD.Apply<Closure, Closure, Closure>(as9hI, a_s9hL);
        }
        public static Closure sats9hO_Entry(in (Closure x0, Closure x1, Closure x2) sat_Frees9hO)
        {
            var dSemigroups9hE = sat_Frees9hO.x0;
            var bs9hJ = sat_Frees9hO.x1;
            var b_s9hM = sat_Frees9hO.x2;
            return dSemigroups9hE.Apply<Closure, Closure, Closure>(bs9hJ, b_s9hM);
        }
        public static Closure fSemigroupPrOPrC_Entry(Closure etaB2, Closure etaB1)
        {
            return cLtGts9hy_Entry(etaB2, etaB1);
        }
        public static Closure cLtGts9hy_Entry(Closure dss9hz, Closure dss9hA)
        {
            return GHC.Tuple.unit_DataCon.Eval();
        }
        public static Closure fSemigroupDashGt_Entry(Closure etaB4, Closure etaB3, Closure etaB2, Closure etaB1)
        {
            return cLtGts9hq_Entry(etaB4, etaB3, etaB2, etaB1);
        }
        public static Closure cLtGts9hq_Entry(Closure dSemigroups9hr, Closure fs9hs, Closure gs9ht, Closure xs9hu)
        {
            var sat_Frees9hw = (gs9ht, xs9hu);
            var sats9hw = new Updatable<(Closure x0, Closure x1)>(&sats9hw_Entry, sat_Frees9hw);
            var sat_Frees9hv = (fs9hs, xs9hu);
            var sats9hv = new Updatable<(Closure x0, Closure x1)>(&sats9hv_Entry, sat_Frees9hv);
            return dSemigroups9hr.Apply<Closure, Closure, Closure>(sats9hv, sats9hw);
        }
        public static Closure sats9hv_Entry(in (Closure x0, Closure x1) sat_Frees9hv)
        {
            var fs9hs = sat_Frees9hv.x0;
            var xs9hu = sat_Frees9hv.x1;
            return fs9hs.Apply<Closure, Closure>(xs9hu);
        }
        public static Closure sats9hw_Entry(in (Closure x0, Closure x1) sat_Frees9hw)
        {
            var gs9ht = sat_Frees9hw.x0;
            var xs9hu = sat_Frees9hw.x1;
            return gs9ht.Apply<Closure, Closure>(xs9hu);
        }
        public static Closure ltGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColSemigroup;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure p1Monoid_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure mempty_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure mappend_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure mconcat_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonoid;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure fmap_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColFunctor;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure ltDoll_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColFunctor;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure p1Applicative_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure pure_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure ltAstrGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure liftA2_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure astrGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure ltAstr_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColApplicative;
            var dictItem = dict.x5; return dictItem.Eval();
        }
        public static Closure p1Alternative_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure empty_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure ltPipeGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure some_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure many_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColAlternative;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure p1Monad_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure gtGtEq_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure gtGt_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure @return_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public static Closure fail_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonad;
            var dictItem = dict.x4; return dictItem.Eval();
        }
        public static Closure p1MonadPlus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x0; return dictItem.Eval();
        }
        public static Closure p2MonadPlus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x1; return dictItem.Eval();
        }
        public static Closure mzero_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x2; return dictItem.Eval();
        }
        public static Closure mplus_Entry(Closure a0)
        {
            var dict = a0 as GHC.Base.CColMonadPlus;
            var dictItem = dict.x3; return dictItem.Eval();
        }
        public sealed class CColMonoid : Data
        {
            public Closure x0;
            public Closure x1; public Closure x2; public Closure x3;
            public CColMonoid(Closure x0, Closure x1, Closure x2, Closure x3)
            {
                this.x0 = x0; this.x1 = x1; this.x2 = x2; this.x3 = x3;
            }
            public override int Tag => 1;
        }
        public sealed class CColFunctor : Data
        {
            public Closure x0; public Closure x1;
            public CColFunctor(Closure x0, Closure x1)
            {
                this.x0 = x0; this.x1 = x1;
            }
            public override int Tag => 1;
        }
        public sealed class CColApplicative : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2;
            public Closure x3; public Closure x4; public Closure x5;
            public CColApplicative(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4, Closure x5)
            {
                this.x0 = x0;
                this.x1 = x1;
                this.x2 = x2; this.x3 = x3; this.x4 = x4; this.x5 = x5;
            }
            public override int Tag => 1;
        }
        public sealed class CColAlternative : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2; public Closure x3; public Closure x4;
            public CColAlternative(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)
            {
                this.x0 = x0;
                this.x1 = x1; this.x2 = x2; this.x3 = x3; this.x4 = x4;
            }
            public override int Tag => 1;
        }
        public sealed class CColMonad : Data
        {
            public Closure x0;
            public Closure x1;
            public Closure x2; public Closure x3; public Closure x4;
            public CColMonad(Closure x0, Closure x1, Closure x2, Closure x3, Closure x4)
            {
                this.x0 = x0;
                this.x1 = x1; this.x2 = x2; this.x3 = x3; this.x4 = x4;
            }
            public override int Tag => 1;
        }
        public sealed class CColMonadPlus : Data
        {
            public Closure x0;
            public Closure x1; public Closure x2; public Closure x3;
            public CColMonadPlus(Closure x0, Closure x1, Closure x2, Closure x3)
            {
                this.x0 = x0; this.x1 = x1; this.x2 = x2; this.x3 = x3;
            }
            public override int Tag => 1;
        }
        public sealed class CColSemigroup : Data
        {
            public Closure x0;
            public CColSemigroup(Closure x0) { this.x0 = x0; }
            public override int Tag => 1;
        }
    }
}
